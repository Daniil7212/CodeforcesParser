code~label
"\n n = int(input())\n a = list(map(int, input().split()))\n  \n l = [-1] * n\n st = []\n for i in range(n):\n     while st and a[st[-1]] <= a[i]:\n         st.pop()\n     l[i] = st[-1] if st else -1\n     st.append(i)\n  \n r = [n] * n\n st = []\n for i in range(n - 1, -1, -1):\n     while st and a[st[-1]] <= a[i]:\n         st.pop()\n     r[i] = st[-1] if st else n\n     st.append(i)\n     \n print(" ".join([str(r[i] - l[i] - 1) for i in range(n)]))\n"~0
"def calculate_sum(first_number, second_number):\n    result = first_number + second_number\n    return result"~1
"def compute_total(initial_value, increment):\n    total = initial_value + increment\n    return total"~1
"funcs = {}\n  \n def run_code(code):\n     if code != False:\n         #print('> called func')\n         code.append('endprg')\n     runpointer = 0\n     infunc = 0\n     currentwritingfunc = ""\n     while True:\n         curr_op = ""\n         if code == False:\n             curr_op = input()\n             #print("> running at input")\n         else:\n             curr_op = code[runpointer]\n             runpointer += 1\n         \n         if curr_op == "endprg": break\n  \n         if curr_op[0:8] == "function":\n             infunc += 1\n             currentwritingfunc = curr_op[9:len(curr_op)]\n             funcs[currentwritingfunc] = [1, []]\n             #print("> doing func", currentwritingfunc)\n             continue\n             \n         if curr_op[0:3] == "end":\n             infunc -= 1\n             continue\n             \n         if infunc > 0:\n             funcs[currentwritingfunc][1].append(curr_op)\n             #print('> wrote "'+curr_op+'" to '+currentwritingfunc)\n         else:\n             if curr_op[0:4] == "call":\n                 #print(funcs)\n                 run_code(funcs[curr_op[5:len(curr_op)]][1])\n                 continue\n             if curr_op[0:5] == "print":\n                 print(curr_op[6:len(curr_op)])\n                 continue\n             \n run_code(False)\n "~1
"n = int(input())\n a1 = list(map(int, input().split()))\n a2 = list(map(int, input().split()))\n a3 = list(map(int, input().split()))\n  \n a1p, a2p, a3p = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)\n  \n for i, v in enumerate(a1):\n     a1p[v] = i\n for i, v in enumerate(a2):\n     a2p[v] = i\n for i, v in enumerate(a3):\n     a3p[v] = i\n  \n def check(a, b):\n     count = 0\n     if a1p[a] < a1p[b]:\n         count += 1\n     if a2p[a] < a2p[b]:\n         count += 1\n     if a3p[a] < a3p[b]:\n         count += 1\n     return count >= 2\n     \n cand = 1\n for i in range(2, n + 1):\n     if check(i, cand):\n         cand = i\n  \n for j in range(1, n + 1):\n     if j == cand:\n         continue\n     if not check(cand, j):\n         print(-1)\n         exit(0)\n  \n print(cand)\n "~1
"n = int(input())\n a = list(map(int, input().split()))\n nuts = [i for i, x in enumerate(a) if x == 1]\n  \n     \n if not nuts:\n     print(0)\n else:\n     x = 1\n     for i in range(1, len(nuts)):\n         x *= (nuts[i] - nuts[i - 1])\n     print(x)\n "~1
"n = int(input())\n  \n k = n\n while True:\n     s = sum(int(d) for d in str(k))\n     if s != 0 and k % s == 0:\n         break\n     else:\n         k += 1\n print(k)\n "~0
"n = int(input())\n x = int(input())\n  \n n = n % 6\n  \n for i in range(n, 0, -1):\n     if i % 2 == 1:\n         if x == 0:\n             #print('l -> m')\n             x = 1\n         elif x == 1:\n             #print('m -> l')\n             x = 0\n     else:\n         if x == 1:\n             #print('m -> r')\n             x = 2\n         elif x == 2:\n             #print('r -> m')\n             x = 1\n print(x)\n "~0
"n, p, k = map(int, input().split())\n a, b, c = map(int, input().split())\n  \n pa = a - p\n pb = b - p\n pc = c - p\n  \n f = [\n     (pa, 'a'),\n     (pb, 'b'),\n     (pc, 'c')\n ]\n  \n f.sort(reverse=True, key=lambda x: x[0])\n  \n max_profit = 0\n os = n\n  \n for profit, name in f:\n     if os <= 0:\n         break\n     m = min(k, os)\n     max_profit += m * profit\n     os -= m\n  \n print(max_profit)\n "~1
"n = int(input())\n s = input().strip()\n  \n min_flips = min(\n     n - s.count('N'),\n     n - s.count('S'),\n     n - s.count('W'),\n     n - s.count('E')\n )\n  \n print(min_flips)\n "~1
"n = int(input())\n sm = 0\n a = list(map(int, input().split()))\n a.sort()\n for i in range(n - 1):\n     lf = i - 1\n     r = len(a)\n     while lf + 1 < r:\n         m = (lf + r) // 2\n         if a[i] < a[m] * 0.9:\n             r = m\n         else:\n             lf = m\n     sm += r - i - 1\n print(sm)\n "~0
"n = int(input())\n k = n\n while (k % (sum(map(int, list(str(k))))) != 0):\n     k+=1\n print(k)\n "~0
"n, k = map(int, input().split())\n d = list(map(int, input().split()))\n sm = sum(d)\n  \n def f(m, d):\n     sm = 0\n     for i in d:\n         sm += min(m, i)\n     return sm\n  \n if sm < k:\n     print(-1)\n  \n else:\n     l = -1\n     r = max(d) - 1\n     while (l + 1 < r):\n         m = (l + r) // 2\n         if (f(m, d) >= k):\n             r = m\n         else:\n  \n             l = m\n     print(r)\n "~0
"import bisect\n  \n n = int(input())\n s = list(map(int, input().split()))\n s.sort()\n  \n ans = 0\n for i in range(n):\n     limit = s[i] / 0.9\n     r = bisect.bisect_right(s, limit)\n     ans += r - (i + 1)\n  \n print(ans)\n "~1
"n = int(input())\n arr = [int(i) for i in input().split()]\n l = [-1] * n\n r = [n] * n\n st = []\n for i in range(n):\n     while len(st) != 0 and arr[st[-1]] < arr[i]:\n         r[st[-1]] = i\n         st.pop()\n     st.append(i)\n st = []\n for i in range(n - 1,-1,-1):\n     while len(st) != 0 and arr[st[-1]] < arr[i]:\n         l[st[-1]] = i\n         st.pop()\n     st.append(i)\n for i in range(n):\n     cnt = 1\n     cnt += r[i] - i - 1\n     cnt += i - l[i] - 1\n     print(cnt, end=' ')\n "~0
"n = int(input())\n m = int(input())\n t = int(input())\n l = 0\n r = -(min(n, m) // -2)\n  \n while r - l > 1:\n     mid=(r+l)//2\n     s=n*2*mid+m*2*mid-(4*mid*mid)\n     if s > t:\n         r=mid\n     else:\n         l=mid\n print(l)\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n  \n ind = [i for i in range(n) if a[i] == 1]\n  \n if not ind:\n     print(0)\n else:\n     w = 1\n     for i in range(len(ind) - 1):\n         w *= (ind[i+1] - ind[i])\n     print(w)\n "~0
"n=int(input())\n x=int(input())\n  \n n=n%6\n  \n j=[0,0,0]\n  \n j[x]=1\n  \n for i in range(n,0,-1):\n     if i%2==0:\n         j[1],j[2]=j[2],j[1]\n     else:\n         j[0],j[1]=j[1],j[0]\n print(j.index(1))\n "~0
"n=int(input())\n a=str(input())\n ma=0\n  \n print(len(a)-max(a.count("N"),a.count("S"),a.count("W"),a.count("E")))\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n if sum(a) < 1:\n     print(0)\n elif sum(a) == 1:\n     print(1)\n else:\n     last = 0\n     cnt = 0\n     ans = 1\n     for i in range(n):\n         if a[i] == 1:\n             cnt += 1\n             if cnt != 1:\n                 ans *= i - last\n             last = i\n     print(ans)\n "~0
"n, p, k = map(int, input().split())\n a = list(map(int, input().split()))\n a.sort()\n if p > a[-1]:\n     print(0)\n else:\n     i = 2\n     k1 = k\n     k2 = k\n     k3 = k\n     cnt = 0\n     while p < a[2] and n > 0 and k1 > 0:\n         cnt += a[2] - p\n         k1 -= 1\n         n -= 1\n     while p < a[1] and n > 0 and k2 > 0:\n         cnt += a[1] - p\n         k2 -= 1\n         n -= 1\n     while p < a[0] and n > 0 and k3 > 0:\n         cnt += a[0] - p\n         k3 -= 1\n         n -= 1\n     print(cnt)\n "~0
"a = list(input().split())\n op = []\n f = dict()\n ch = 0\n fun = ""\n while a[0] != "endprg":\n     if a[0] == "function":\n         f[a[1]] = []\n         ch = 1\n         fun = a[1]\n     elif a[0] == "end":\n         ch = 0\n         fun = ""\n     elif ch == 1:\n         if a[0] == "print":\n             f[fun].append(a[1])\n         else:\n             f[fun] += f[a[1]]\n     else:\n         op.append(a)\n     a = list(input().split())\n for z in range(len(op)):\n     if op[z][0] == "print":\n         print(op[z][1])\n     else:\n         i = op[z][1]\n         j = 0\n         while j < len(f[i]):\n             print(f[i][j])\n             j += 1\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n a.insert(0, 10000000000)\n a.append(10000000000)\n st = [0]\n ans = []\n for i in range(1, n + 1):\n     while a[st[-1]] <= a[i]:\n         st.pop()\n     ans.append(st[-1])\n     st.append(i)\n st = [0]\n ans1 = [0] * n\n for i in range(n + 2):\n     while a[i] > a[st[-1]]:\n         ans1[st[-1] - 1] = i\n         st.pop()\n     st.append(i)\n for i in range(1, n + 1):\n     a[i] = ans1[i - 1] - ans[i - 1] - 1\n a = a[:-1]\n a = a[1:]\n print(*a)\n "~0
"n, k = map(int, input().split())\n a = list(map(int, input().split()))\n cnt = [0] * k\n cnt0 = k - 1\n j = 0\n ib = 0\n jb = n\n cnt[a[0] - 1] += 1\n for i in range(n):\n     while cnt0 != 0 and j < n - 1:\n         j += 1\n         cnt[a[j] - 1] += 1\n         if cnt[a[j] - 1] == 1:\n             cnt0 -= 1\n     if cnt0 != 0:\n         break\n     else:\n         if j - i < jb - ib:\n             jb = j\n             ib = i\n     cnt[a[i] - 1] -= 1\n     if cnt[a[i] - 1] == 0:\n         cnt0 += 1\n print(ib + 1, jb + 1)\n "~0
"import sys\n from collections import defaultdict\n \n def solve():\n     n = int(sys.stdin.readline())\n     states = {}\n     for _ in range(n):\n         parts = sys.stdin.readline().split()\n         state_name = ' '.join(parts[:-1])\n         electors = int(parts[-1])\n         states[state_name] = electors\n     \n     # Словарь для подсчета голосов по штатам: {штат: {кандидат: голоса}}\n     state_votes = defaultdict(lambda: defaultdict(int))\n     \n     for line in sys.stdin:\n         line = line.strip()\n         if not line:\n             continue\n         parts = line.split()\n         state_name = ' '.join(parts[:-1])\n         candidate = parts[-1]\n         state_votes[state_name][candidate] += 1\n     \n     # Словарь для итоговых голосов выборщиков: {кандидат: голоса}\n     candidate_electors = defaultdict(int)\n     \n     for state in states:\n         electors = states[state]\n         candidates_votes = state_votes[state]\n         if not candidates_votes:\n             continue  # по условию такого не должно быть\n         \n         max_votes = -1\n         winners = []\n         for candidate, votes in candidates_votes.items():\n             if votes > max_votes:\n                 max_votes = votes\n                 winners = [candidate]\n             elif votes == max_votes:\n                 winners.append(candidate)\n         \n         # Выбираем лексикографически меньшего победителя\n         winners.sort()\n         winner = winners[0]\n         candidate_electors[winner] += electors\n     \n     # Собираем всех кандидатов, которые когда-либо получали голоса (включая тех, у кого 0)\n     all_candidates = set()\n     for state in state_votes:\n         for candidate in state_votes[state]:\n             all_candidates.add(candidate)\n     \n     # Добавляем кандидатов, которые есть в candidate_electors (но возможно, они уже в all_candidates)\n     for candidate in candidate_electors:\n         all_candidates.add(candidate)\n     \n     # Преобразуем в список и сортируем\n     candidates_list = list(all_candidates)\n     # Сортировка: по убыванию голосов, затем по имени в лексикографическом порядке\n     candidates_list.sort(key=lambda x: (-candidate_electors.get(x, 0), x))\n     \n     for candidate in candidates_list:\n         print(candidate, candidate_electors.get(candidate, 0))\n \n if __name__ == '__main__':\n     solve()\n "~1
"def is_valid(s: str) -> bool:\n     stack = []\n     mapping = {')': '(', ']': '[', '}': '{'}\n     for char in s:\n         if char in mapping:\n             top_element = stack.pop() if stack else '#'\n             if mapping[char] != top_element:\n                 return False\n         else:\n             stack.append(char)\n     return not stack\n \n s = input().strip()\n print("yes" if is_valid(s) else "no")\n "~1
"from collections import defaultdict\n \n text = input().split()\n word_counts = defaultdict(int)\n \n for word in text:\n     word_counts[word] += 1\n \n max_count = max(word_counts.values()) if word_counts else 0\n most_common_words = [word for word, count in word_counts.items() if count == max_count]\n most_common_words.sort()\n \n print(most_common_words[0] if most_common_words else "")\n "~1
"import sys\n \n for line in sys.stdin:\n     numbers = list(map(int, line.split()))\n     print(sum(numbers))\n "~1
"import sys\n for i in sys.stdin:\n     l = list(map(int, i.split()))\n     print(sum(l))\n "~1
"w, h, n = map(int, input().split())\n \n # Функция проверки\n def can_fit(s):\n     return (s // w) * (s // h) >= n\n \n left = 0\n right = max(w, h) * n\n \n while right - left > 1:\n     mid = (left + right) // 2\n     if can_fit(mid):\n         right = mid\n     else:\n         left = mid\n \n print(right)\n "~1
"def max_min_distance(N, K, stalls):\n     left = 1\n     right = stalls[-1] - stalls[0]\n     answer = 0\n \n     while left <= right:\n         mid = (left + right) // 2\n         count = 1\n         last_pos = stalls[0]\n \n         for i in range(1, N):\n             if stalls[i] - last_pos >= mid:\n                 count += 1\n                 last_pos = stalls[i]\n                 if count == K:\n                     break\n \n         if count >= K:\n             answer = mid\n             left = mid + 1\n         else:\n             right = mid - 1\n \n     return answer\n \n N, K = map(int, input().split())\n stalls = list(map(int, input().split()))\n print(max_min_distance(N, K, stalls))\n "~1
"import bisect\n \n def find_min_differences(a, b):\n     a_sorted = sorted(a)\n     result = []\n     for num in b:\n         pos = bisect.bisect_left(a_sorted, num)\n         min_diff = float('inf')\n         if pos < len(a_sorted):\n             min_diff = abs(a_sorted[pos] - num)\n         if pos > 0:\n             min_diff = min(min_diff, abs(a_sorted[pos - 1] - num))\n         result.append(min_diff)\n     return result\n \n n = int(input())\n a = list(map(int, input().split()))\n m = int(input())\n b = list(map(int, input().split()))\n \n differences = find_min_differences(a, b)\n print(' '.join(map(str, differences)))\n "~1
"n = int(input())\n a = list(map(int, input().split()))\n \n max_sum = current_sum = a[0]\n start = end = 0\n best_start = best_end = 0\n \n for i in range(1, n):\n     if current_sum + a[i] > a[i]:\n         current_sum += a[i]\n         end = i\n     else:\n         current_sum = a[i]\n         start = end = i\n     \n     if current_sum > max_sum or (current_sum == max_sum and (end < best_end or (end == best_end and start > best_start))):\n         max_sum = current_sum\n         best_start = start\n         best_end = end\n \n print(best_start + 1, best_end + 1)\n "~1
"n = int(input())\n t = list(map(int, input().split()))\n alice_time = 0\n bob_time = 0\n alice_count = 0\n bob_count = 0\n left = 0\n right = n - 1\n \n while left <= right:\n     if alice_time <= bob_time:\n         alice_time += t[left]\n         alice_count += 1\n         left += 1\n     else:\n         bob_time += t[right]\n         bob_count += 1\n         right -= 1\n \n print(alice_count, bob_count)\n "~1
"def F(a):\n     n=len(a)-2\n     ans=[-1]*(n+2)\n     st=[0]\n     for i in range(1,n+2):\n         while a[i]<a[st[-1]]:\n             if i!=n+1:\n                 ans[st[-1]]=i-1\n             else:\n                 ans[st[-1]]=n\n             st.pop()\n         st.append(i)\n     return ans[1:n+1]\n q=list(map(int,input().split()))[1:]\n n=len(q)\n a=[-1]+q+[-1]\n ans1=F(a)\n ans2=F(a[::-1])\n best=0\n for i in range(n):\n     h=q[i]\n     ir=ans1[i]\n     il=n-ans2[n-i-1]\n     w=ir-il\n     if h*w>best:\n         best=h*w\n print(best)\n "~0
"n=int(input())\n a=[-1]+list(map(int,input().split()))+[-1]\n ans=[-1]*(n+2)\n st=[0]\n for i in range(1,n+2):\n     while a[i]<a[st[-1]]:\n         if i!=n+1:\n             ans[st[-1]]=i-1\n         st.pop()\n     st.append(i)\n print(*ans[1:n+1])\n "~0
"n=input()\n st=[]\n for i in n:\n     if st==[]:\n         st.append(i)\n     else:\n         if i==')' or i==']' or i=='}': \n             if (st[-1]=='(' and i==')') or (st[-1]=='{' and i=='}') or (st[-1]=='[' and i==']'):\n                 st.pop()\n             else:\n                 print('no')\n                 exit()\n         else:\n             st.append(i)         \n if st!=[]:\n     print('no')  \n else:\n     print('yes')  \n "~0
"from collections import deque\n n, k =int(input()), int(input())\n a=[int(input()) for _ in range(n)]\n ans=[0 for _ in range(n-k+1)]\n dq=deque()\n for i in range(n):\n     while len(dq)>0 and a[i]<=a[dq[-1]]:\n         dq.pop()\n     dq.append(i)\n     if i >=k-1:\n         if dq[0] <= i-k:\n             dq.popleft()\n         ans[i-k+1]=a[dq[0]]\n \n print("\n ".join(map(str,ans)))\n "~1
"import sys\n from collections import deque\n \n def solve():\n     n, q = map(int, sys.stdin.readline().split())\n     a = list(map(int, sys.stdin.readline().split()))\n     queries = [int(sys.stdin.readline()) for _ in range(q)]\n     \n     dq = deque(a)\n     opers = []\n     max_m = max(queries) if q > 0 else 0\n     max_ops = min(max_m, n - 1) if q > 0 else 0\n     \n     for _ in range(max_ops):\n         A = dq.popleft()\n         B = dq.popleft()\n         opers.append((A, B))\n         if A > B:\n             dq.appendleft(A)\n             dq.append(B)\n         else:\n             dq.appendleft(B)\n             dq.append(A)\n     \n     mx = max(a)\n     d = list(dq)\n     \n     res = []\n     for m in queries:\n         if m <= len(opers):\n             A, B = opers[m - 1]\n         else:\n             index = (m - len(opers) - 1) % (n - 1)\n             A = d[0]\n             B = d[1 + index]\n         res.append(f"{A} {B}")\n     \n     print('\n '.join(res))\n \n solve()\n "~1
"n, k = map(int, input().split())\n d = list(map(int, input().split()))\n sm = sum(d)\n \n def f(m, d):\n     sm = 0\n     for i in d:\n         sm += min(m, i)\n     return sm\n \n if sm < k:\n     print(-1)\n \n else:\n     l = -1\n     r = max(d) - 1\n     while (l + 1 < r):\n         m = (l + r) // 2\n         if (f(m, d) >= k):\n             r = m\n         else:\n \n             l = m\n     print(r)\n "~0
"def gcd(a,b):\n     while b!=0:\n         a,b=b,a%b\n     return a\n x1,y1,x2,y2=map(int,input().split())\n print(gcd(abs(x2-x1),abs(y2-y1))+1)\n "~0
"def F1(a,b):\n     while b!=0:\n         a,b=b,a%b\n     return a\n def F2(a,b):\n     return a*b//F1(a,b)\n q=int(input())\n n=list(map(int,input().split()))\n if q==1:\n     print(n[0]+1)\n else:  \n     a=F2(n[0]+1,n[1]+1)\n     for i in range(2,q):\n         a=F2(a,n[i]+1)\n     print(a)\n "~0
"def fpow(x,y):\n     global m\n     if y==0:\n         return 1\n     if y%2==1:\n         return fpow(x%m,y-1)*x%m\n     else:\n         return fpow(x*x%m,y//2)%m\n x,m=map(int,input().split())\n if fpow(x,x)==0:\n     print('YES')\n else:\n     print('NO')\n "~0
"n=int(input())\n for i in range(n):\n     a,b=map(int,input().split('/'))\n     q,w=a,b\n     while b!=0:\n         a,b=b,a%b\n     print(str(q//a)+'/'+str(w//a))\n "~0
"def prime(x):\n     dict={}\n     q=[]\n     d=2\n     while d*d<=x:\n         if x%d==0:\n             if d in dict:\n                 dict[d]=dict[d]+1\n             else:\n                 dict[d]=1\n                 q.append(d)\n             x//=d\n         else:\n             d+=1\n     if x in dict:\n         dict[x]=dict[x]+1\n     else:\n         q.append(x)\n         dict[x]=1\n     return dict,q\n n=int(input())\n dict,q=prime(n)\n ans=''\n for i in q:\n     if dict[i]==1:\n         ans+=str(i)+'*'\n     else:\n         ans+=str(i)+'^'+str(dict[i])+'*'\n print(ans[:-1])\n "~0
"def ext_gcd(a, b):\n     if b == 0:\n         return a, 1, 0\n     g, x, y = ext_gcd(b, a % b)\n     return g, y, x - a // b * y\n \n \n a, b, c = map(int, input().split())\n res = ext_gcd(a, b)\n x0 = res[1]\n y0 = res[2]\n g = res[0]\n ans = []\n for i in range(-1000, 1001):\n     x = x0 * (c // g) + (b // g) * i\n     y = y0 * (c // g) - (a // g) * i\n     if a * x + b * y == c and x > 0 and y > 0:\n         ans.append((x, y))\n ans.sort(key = lambda x: x[0])\n print(len(ans))\n for i in range(len(ans)):\n     print(*ans[i])\n "~1
"x, k = map(int, input().split())\n x1 = x\n arr = [1] * 1000000\n for i in range(1, len(arr)):\n     if arr[i] == 1:\n         for j in range((i + 1) * (i + 1) - 1, len(arr), i + 1):\n             arr[j] = 0\n sq = []\n for i in range(len(arr)):\n     if arr[i] == 1:\n         sq.append(i + 1)\n cnt = dict()\n d = 2\n while d * d <= x:\n     if x % d == 0:\n         x //= d\n         cnt[d] = cnt.get(d, 0) + 1\n     else:\n         d += 1\n cnt[x] = cnt.get(x, 0) + 1\n summa = 0\n for key in cnt:\n     summa += cnt[key]\n if summa < k:\n     print(-1)\n else:\n     for key in cnt:\n         while k > 1 and cnt[key] > 0:\n             print(key, end = " ")\n             x1 //= key\n             cnt[key] -= 1\n             k -= 1\n     print(x1)\n "~1
"n = int(input())\n a = list(map(int, input().split()))\n arr = [1] * 1000000\n for i in range(1, len(arr)):\n     if arr[i] == 1:\n         for j in range((i + 1) * (i + 1) - 1, len(arr), i + 1):\n             arr[j] = 0\n sq = []\n for i in range(len(arr)):\n     if arr[i] == 1:\n         sq.append((i + 1) * (i + 1))\n for i in range(n):\n     l = -1\n     r = len(sq) - 1\n     while r - l > 1:\n         mid = (r + l) // 2\n         if sq[mid] < a[i]:\n             l = mid\n         else:\n             r = mid\n     if (not sq[r] == a[i]) or a[i] == 1:\n         print("NO")\n     else:\n         print("YES")\n "~0
"l, r = map(int, input().split())\n if l == r:\n     print(l)\n else:\n     print(2)\n "~0
"import sys\n sys.set_int_max_str_digits(1000000)\n n = int(input())\n if n % 4 == 0:\n     print(4)\n else:\n     print(0)\n "~1
"l,r=map(int,input().split())\n if l==r and r%2==1: print(l)\n else: print(2)\n "~0
"n,k=map(int,input().split())\n d=2\n a=[]\n count=0\n while d*d<=n and count<k-1:\n     if n%d==0:\n         a.append(d)\n         n//=d\n         count+=1\n     else: d+=1\n a.append(n)\n if len(a)<k: print(-1)\n else: print(*a)\n "~0
"def prime(n):\n     d=2\n     while d*d<=n:\n         if n%d==0:\n             dict[d]=dict.get(d, 0)+1\n             n//=d\n         else:\n             d+=1\n     dict[n] = dict.get(n, 0) + 1\n n=int(input())\n o=10**9+7\n dict=dict()\n for i in range(2,n+1):\n     prime(i)\n p=1\n for i in dict.keys():\n     p=(p*(dict[i]+1)%o)%o\n print(p)\n "~0
"def fast_pow(a,n,m):\n     if n==0: return 1\n     elif n%2==1: return ((fast_pow(a,n-1,m)%m)*(a%m))%m\n     else:\n         x=a%m\n         return fast_pow(x*x,n//2,m)\n x,k=map(int,input().split())\n if fast_pow(x,x,k): print("NO")\n else: print("YES")\n "~0
"n = int(input())\n l = list(map(int, input().split()))\n count = [0] * 8\n for i in l:\n     count[i] += 1\n if count[5] > 0 or count[7] > 0:\n     print(-1)\n else:\n     e = min(count[4], count[2], count[1])\n     count[4] -= e\n     count[2] -= e\n     count[1] -= e\n     if count[6] == count[1] and count[6] == count[3] + count[2]:\n         for _ in range(e):\n             print(1, 2, 4)\n         for _ in range(count[2]):\n             print(1, 2, 6)\n         for _ in range(count[3]):\n             print(1, 3, 6)\n     else:\n         print(-1)\n "~1
"from string import ascii_uppercase\n  \n  \n a = input()\n _ = False\n Up = False\n for i in a:\n     if i in ascii_uppercase:\n         Up = True\n     if i == "_":\n         _ = True\n if _ == Up:\n     if _ == Up == 0:\n         print(a)\n     else:\n         print("Error!")\n elif "__" in a or a[0] == "_" or a[-1] == "_" or a[0] in ascii_uppercase:\n     print("Error!")\n else:\n     if "_" in a:\n         a = a.title()\n         a = a.replace("_", "")\n         a = a.replace(a[0], a[0].lower(), 1)\n         print(a)\n     else:\n         s = ""\n         for i in a:\n             if i.isupper():\n                 s += f"_{i.lower()}"\n             else:\n                 s += i\n         print(s)\n \n "~1
"a = int(input())\n s = []\n for i in range(a):\n     s.append(list(map(int, input().split())))\n input()\n k = list(map(int, input().split()))\n l = 0\n for i in range(a):\n     for j in range(i + 1, a):\n         if s[i][j] == 1 and k[i] != k[j]:\n             l += 1\n print(l)\n "~0
"def is_prime(s):\n     for i in range(2, int(__import__("math").sqrt(s)) + 1):\n         if s % i == 0:\n             return False\n     return True\n  \n  \n a = int(input())\n if is_prime(int("".join(sorted(str(a))))) and is_prime(int("".join(sorted(str(a), reverse=True)))):\n     print("Yes")\n else:\n     print("No")\n "~1
"n = int(input())\n petya = (n / 3) * 1.625\n vasya = (n / 3) * 0.5\n kolya = (n / 3) * 0.875\n print(int(petya), int(vasya), int(kolya))\n "~1
"a, b, c = input().split()\n a = set(a)\n b = set(b)\n c = set(c)\n a = a.intersection(b)\n a = a.intersection(c)\n print(len(a))\n if len(a) > 0:\n     a = sorted(a)\n     print(*a)\n "~0
"a, b = map(int, input().split())\n s = []\n for i in range(a):\n     s.append(list(map(int, input().split())))\n d = list(zip(*s))\n hori = [min(s[i]) for i in range(a)]\n vert = [max(d[i]) for i in range(b)]\n k = 0\n for i in range(a):\n     for j in range(b):\n         if s[i][j] == hori[i] and s[i][j] == vert[j]:\n             k += 1\n print(k)\n \n "~0
"# Получаем ввод числа\n n = int(input())\n # Внешний цикл для создания строк с числами от 1 до n\n for i in range(1, n + 1):\n     # Внутренний цикл для повторения числа i в строке i раз\n     for j in range(i):\n         print(i, end='')  # Выводим число i\n     print()  # Переходим на новую строку после каждой строки\n "~1
"# Получаем ввод числа\n n = int(input())\n # Находим середину пирамиды\n centr = n // 2 + 1\n # Инициализируем счетчик звездочек в строке\n count = 0\n # Проходим по строкам пирамиды от 1 до n\n for i in range(1, n + 1):\n     if i > centr:\n         count -= 1  # Если перешли за середину, уменьшаем количество звездочек\n     else:\n         count += 1  # В противном случае увеличиваем количество звездочек\n     \n     # Выводим звездочки в строке\n     for _ in range(count):\n         print('*', end='')\n     # Переходим на новую строку для следующей строки пирамиды\n     print()\n "~1
"a , b = int(input()), int(input())\n total_maximum = 0                 \n digit = 0                            \n for i in range(a, b + 1):         \n     maximum = 0                   \n     for j in range(1, i + 1):    \n         if i % j == 0:             \n             maximum += j         \n         if maximum >= total_maximum:  \n             total_maximum = maximum\n             digit = j\n print(digit, total_maximum)\n "~1
"n=int(input())\n while n > 9:       \n     s = 0    \n     while (n > 0):\n         last_digit = n % 10\n         s += last_digit\n         n = n // 10          \n     n = s\n     \n print(n)\n "~1
"num = int(input())\n total = 0\n factorial = 1 \n for i in range(1, num+1):\n     for j in range(1, i+1):\n         factorial *= j\n     total += factorial\n     factorial = 1\n print(total)\n "~1
"s = input()  # Считываем первую строку\n r = input()  # Считываем вторую строку\n # Преобразуем первую строку s в список символов\n # Затем объединяем символы из списка, используя вторую строку r в качестве разделителя\n res = r.join(list(s))\n # Выводим результат\n print(res)\n "~1
"def quick_merge(lst1, lst2):\n     res = []       # Результирующий список\n     p1, p2 = 0, 0  # Индексы текущих элементов для lst1 и lst2\n     # Пока есть элементы в обоих списках, сравниваем их и добавляем минимальный в res\n     while p1 < len(lst1) and p2 < len(lst2):\n         if lst1[p1] < lst2[p2]:\n             res.append(lst1[p1])\n             p1 += 1\n         else:\n             res.append(lst2[p2])\n             p2 += 1\n     # Если все элементы lst1 были добавлены, добавляем оставшиеся элементы lst2 и наоборот\n     if p1 == len(lst1):\n         res += lst2[p2:]\n     else:\n         res += lst1[p1:]\n     return res\n res = []  # Результирующий список\n # Считываем количество списков для сортировки\n for _ in range(int(input())):\n     num = [int(c) for c in input().split()]  # Считываем список чисел\n     res = quick_merge(res, num)  # Вызываем quick_merge() для сортировки и объединения списков\n # Выводим отсортированный результирующий список\n print(*res)\n "~1
"\n def merge(list1, list2):\n     l = list1 + list2\n     \n     l.sort()\n     \n     return l\n \n numbers1 = [int(c) for c in input().split()]\n numbers2 = [int(c) for c in input().split()]\n \n print(merge(numbers1, numbers2))\n "~1
"def get_factors(num):\n     l = []\n     for i in range(1, num // 2 + 1):  \n         if num % i == 0: \n             l.append(i)\n     l.append(num)  \n     return l\n \n n = int(input())\n \n print(get_factors(n))\n "~1
"def convert_to_miles(km):\n     return km * 0.6214\n \n num = int(input())\n \n print(convert_to_miles(num))\n "~1
"def get_middle_point(x1, y1, x2, y2):\n     return (x1 + x2) / 2, (y1 + y2) / 2\n \n x_1, y_1 = int(input()), int(input())\n x_2, y_2 = int(input()), int(input())\n \n x, y = get_middle_point(x_1, y_1, x_2, y_2)\n print(x, y)\n "~1
"import math\n def get_circle(radius):\n     return 2 * math.pi * radius, math.pi * (radius ** 2)\n \n r = float(input())\n \n length, square = get_circle(r)\n print(length, square)\n "~1
"def is_palindrome(num):\n     return str(num) == str(num)[::-1]\n \n def is_prime(num):\n     if num == 1:\n         return False\n     \n     for i in range(2, int(num ** 0.5) + 1):\n         if num % i == 0:\n             return False\n         \n     return True\n \n def is_even(num):\n     return num % 2 == 0\n \n def is_valid_password(password):\n     l = password.split(":")\n     \n     if len(l) == 3:  \n         l = [int(el) for el in l]\n         a, b, c = l[0], l[1], l[2]\n         return is_palindrome(a) and is_prime(b) and is_even(c)\n     \n     return False\n \n psw = input()\n \n print(is_valid_password(psw))\n "~1
"a = int(input())\n b = int(input())\n c = int(input())\n d = int(input())\n spisok=[]\n for i in range(c+ (a-c+d-1)//d*d, b+1, d):\n     spisok.append(i)\n print(*spisok)\n "~1
"n = int(input())\n c3 = n // 60\n c2 = (n % 60) // 10\n c1 = n % 10\n if c1 * 15 > 125:\n   c1 = 0\n   c2 += 1\n if c1 * 15 + c2 * 125 > 440:\n   c1 = 0\n   c2 = 0\n   c3 += 1\n print(c1, c2, c3)\n "~0
"def ToLower(S):\n   return s.lower()\n \n s = input()\n print(ToLower(s))\n "~1
"a = int(input())\n if a == 0:\n     print(0)\n else:\n     fib_prev, fib_next = 0, 1\n     n = 1\n     while fib_next <= a:\n         if fib_next == a:\n             print(n)\n             break\n         fib_prev, fib_next = fib_next, fib_prev + fib_next\n         n += 1\n     else:\n         print(-1)\n "~1
"n = int(input())\n l = []\n while n != 0:\n     l.append(n)\n     n = int(input())\n l.remove(max(l))\n print(max(l))\n "~0
"a, b, c = map(int, input().split())\n print(str(a) + "+" + str(b) + "+" + str(c) + "=" + str(a + b + c))\n print(str(a) + "*" + str(b) + "*" + str(c) + "=" + str(a * b * c))\n print("(" + str(a) + "+" + str(b) + "+" + str(c) + ")" + "/3" + "=" + str(f'{((a + b + c) / 3):.3f}'))\n "~1
"s = input()\n if len(s) % 2 == 0:\n     print(s[-(len(s) // 2):] + s[:-(len(s) // 2)])\n else:\n     print(s[-(len(s) // 2):] + s[:-(len(s) // 2)])\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n m = int(input())\n for i in range(m):\n     s = input().split()\n     x, y = int(s[0]), int(s[1])\n     print(sum(a[x - 1:y]))\n "~0
"n = int(input())\n a = [int(i) for i in input().split()]\n pref = [0] * (n + 1)\n minpref = 10 ** 4 + 1\n imn = 0\n jmx = 1\n maxsumm = -10 ** 8\n for i in range(1, len(pref)):\n     pref[i] = pref[i - 1] + a[i - 1]\n \n for i in range(1, len(pref)):\n     if pref[i] < minpref:\n         minpref = pref[i - 1]\n         imn = i - 1\n     if pref[i] - pref[imn] > maxsumm:\n         maxsumm = pref[i] - pref[imn]\n         jmx = i\n         imnotv = imn + 2\n print(imnotv, jmx, maxsumm + 1)\n "~1
"s = list(map(int, input().split()))\n n, r = s[0], s[1]\n i = 0\n j = 1\n cnt = 0\n a = list(map(int, input().split()))\n \n while j < n:\n     if a[j] - a[i] <= r:\n         j += 1\n     else:\n         i += 1\n         cnt += n - j\n \n print(cnt)\n "~0
"s = input()\n l = []\n c = 0\n for i in s:\n     try:\n         a = int(i)\n         c += 1\n     except:\n         a = 0\n print(c)\n "~0
"s = ''\n stack = []\n while s != "exit":\n     s = input()\n     if "push_front" in s:\n         stack.insert(0, s.split()[1])\n     elif "push_back" in s:\n         stack.append(s.split()[1])\n     elif "pop_front" in s:\n         if len(stack) != 0:\n             print(stack.pop(0))\n         else:\n             print("error")\n     elif "pop_back" in s:\n         if len(stack) != 0:\n             print(stack.pop(-1))\n         else:\n             print("error")\n     elif "size" in s:\n         print(len(stack))\n     elif "clear" in s:\n         stack.clear()\n         print("ok")\n     elif "front" in s:\n         if len(stack) != 0:\n             print(stack[0])\n         else:\n             print("error")\n     elif "back" in s:\n         if len(stack) != 0:\n             print(stack[-1])\n         else:\n             print("error")\n     elif "exit" in s:\n         print("bye")\n "~0
"s = input()\n l = []\n for i in s:\n     l.append(i)\n for i in range(len(s)):\n     if (l[i] == "(" and l[i + 1] == ")") or (l[i] == "[" and l[i + 1] == "]") or (l[i] == "{" and l[i + 1] == "}"):\n         l.pop(i)\n         l.pop(i + 1)\n print(l)\n "~0
"a1, a2, a3 = map(int, input().split())\n b1, b2, b3 = map(int, input().split())\n n = 0\n m = 0\n k = 0\n l = 0\n ans = 0\n if a1 > b1:\n     n = a1 - b1\n     ans += b1\n else:\n     k = b1 - a1\n     ans += a1\n \n if a2 > b2:\n     m = a2 - b2\n     ans += b2\n else:\n     l = b2 - a2\n     ans += a2\n \n if a3 > b3:\n     ans += b3\n     ans += min(k + l, a3 - b3)\n else:\n     ans += a3\n     ans += min(n + m, b3 - a3)\n \n print(ans)\n "~0
"import math\n \n n = int(input())\n for i in range(n):\n     m = int(input())\n     if len(str(m)) < 3 or len(str(m)) > 6:\n         print("NO")\n         continue\n     s = str(m)\n     ln = len(s)\n     flag = False\n     for j in range(math.ceil(ln / 3), ln - 1):\n         a = int(s[:j])\n         for k in range(j + math.ceil((ln - j) / 2), ln):\n             b = int(s[j:k])\n             c = int(s[k:])\n             if c <= b <= a < 19:\n                 flag = True\n                 break\n         if flag:\n             break\n     if flag:\n         print("YES")\n     else:\n         print("NO")\n \n "~0
"n = int(input())\n l = list(map(int, input().split()))\n ans = 0\n for i in range(n):\n     ans += i\n if float(l[0]) >= l[n - 1] * 0.8:\n     print(ans)\n else:\n     for i in range(n):\n         for j in range(i + 1, n):\n             if float(l[i]) < l[j]*0.8:\n                 ans -= n - j\n                 break\n     print(ans)\n \n \n "~0
"cnt = 0\n def f(t):\n     global cnt\n     for i in list(range(1, len(t) + 1))[::-1]:\n         if t[:i] == t[:i][::-1]:\n             cnt += 1\n             f(t[i:])\n             break\n \n s = input()\n f(s)\n print(cnt)\n "~0
"n = int(input())\n l = list(map(int, input().split()))\n x = 0\n y = 0\n k = 1\n while x + y != n - 1:\n     if k == 1:\n         if l[x] > l[n - y - 1]:\n             y+=1\n         else:\n             x += 1\n         k = 2\n     else:\n         if l[x] < l[n - y - 1]:\n             y+=1\n         else:\n             x += 1\n         k = 1\n print(l[x])\n "~0
"import math\n \n def extended_gcd(a, b):\n     if b == 0:\n         return (a, 1, 0)\n     else:\n         g, x, y = extended_gcd(b, a % b)\n         return (g, y, x - (a // b) * y)\n \n a, b, c = map(int, input().split())\n g, x, y = extended_gcd(a, b)\n if c % g != 0:\n     print("Impossible")\n else:\n     k = c // g\n     x0 = x * k\n     y0 = y * k\n     # x0 + (b/g)*t >= 0 => t >= -x0 * g / b\n     b_div_g = b // g\n     a_div_g = a // g\n     t = (-x0) // b_div_g\n     min_x = None\n     best_t = None\n     for possible_t in [t - 1, t, t + 1, t + 2]:\n         current_x = x0 + b_div_g * possible_t\n         if current_x >= 0:\n             if min_x is None or current_x < min_x:\n                 min_x = current_x\n                 best_t = possible_t\n     if min_x is not None:\n         x_ans = x0 + b_div_g * best_t\n         y_ans = y0 - a_div_g * best_t\n         print(x_ans, y_ans)\n     else:\n         print("Impossible")\n "~1
"import math\n \n def sieve(max_num):\n     is_prime = [True] * (max_num + 1)\n     is_prime[0] = is_prime[1] = False\n     for i in range(2, int(math.sqrt(max_num)) + 1):\n         if is_prime[i]:\n             for j in range(i * i, max_num + 1, i):\n                 is_prime[j] = False\n     return is_prime\n \n input = input().split()\n N = int(input[0])\n numbers = list(map(int, input[1:N+1]))\n max_num = max(numbers)\n is_prime = sieve(max_num)\n output = []\n for num in numbers:\n     output.append('1' if is_prime[num] else '0')\n print(''.join(output))\n "~1
"n = int(input())\n \n if n % 2 == 0:\n     k = n // 2\n     print(k)\n     print(' '.join(['2'] * k))\n else:\n     k = (n - 3) // 2 + 1\n     print(k)\n     print(' '.join(['2'] * ((n - 3) // 2) + ['3']))\n "~1
"def factorize(k):\n     factors = {}\n     # Обрабатываем делитель 2 отдельно\n     if k % 2 == 0:\n         count = 0\n         while k % 2 == 0:\n             count += 1\n             k = k // 2\n         factors[2] = count\n     # Проверяем нечетные делители от 3 до sqrt(k)\n     i = 3\n     max_factor = int(k**0.5) + 1\n     while i <= max_factor:\n         if k % i == 0:\n             count = 0\n             while k % i == 0:\n                 count += 1\n                 k = k // i\n             factors[i] = count\n             max_factor = int(k**0.5) + 1\n         i += 2\n     if k > 1:\n         factors[k] = 1\n     return factors\n \n def count_p_in_factorial(n, p):\n     count = 0\n     power = p\n     while power <= n:\n         count += n // power\n         power *= p\n     return count\n \n n, k = map(int, input().split())\n factors = factorize(k)\n min_zeros = float('inf')\n \n for p, m in factors.items():\n     cnt = count_p_in_factorial(n, p)\n     min_zeros = min(min_zeros, cnt // m)\n \n print(min_zeros)\n "~1
"import heapq\n \n n, k = map(int, input().split())\n servers = []\n for _ in range(k):\n     heapq.heappush(servers, (0, _))  # (время освобождения, номер сервера)\n \n output = []\n for _ in range(n):\n     s, m = map(int, input().split())\n     free_time, server_id = heapq.heappop(servers)\n     start_time = max(free_time, s)\n     end_time = start_time + m\n     output.append(end_time)\n     heapq.heappush(servers, (end_time, server_id))\n \n print('\n '.join(map(str, output)))\n "~1
"def getdivs(n):\n     start = []\n     end = []\n     i = 1\n     while i * i < n:\n         if n % i == 0:\n             start.append(i)\n             end.append(n // i)\n         i += 1\n     if i * i == n:\n         start.append(i)\n \n     return start, end\n \n def getelem(k):\n     if len(start) > k:\n         return start[k]\n     elif len(start) + len(end) > k:\n         return end[-k + len(start) -1]\n     \n def gcd(a, b):\n     while b != 0:\n         a, b = b, a % b\n     return a\n     \n n = int(input())\n start, end = getdivs(n)\n result = 0\n for i in range(len(start) + len(end) - 1):\n     for j in range(i + 1, len(start) + len(end)):\n         if gcd(getelem(i), getelem(j)) == 1 and getelem(i) * getelem(j) <= n:\n             result += 1\n print(result)\n "~0
"def gcd(a, b):\n     while b != 0:\n         a, b = b, a % b\n     return a\n \n n = int(input())\n for i in range(n):\n     a, b = map(int, input().split(sep = "/"))\n     g = gcd(a, b)\n     print(str(a // g) + "/" + str(b // g))\n "~0
"def pow(a, n):\n     a %= k\n     if n == 1:\n         return a\n     if n % 2 == 1:\n         return pow(a, n - 1) * a\n     else:\n         return pow(a * a, n // 2)\n     \n x, k = map(int, input().split())\n \n if pow(x, x) % k == 0:\n     print("YES")\n else:\n     print("NO")\n "~0
"n, k = map(int, input().split())\n a = list(map(int, input().split()))\n used_maximum = set()\n for i in range(k):\n     maximum = -1\n     index_of_maximum = 0\n     for j in range(n):\n         if ((j not in used_maximum) and (a[j] > maximum)):\n             maximum = a[j]\n             index_of_maximum = j\n     used_maximum.add(index_of_maximum)\n print(maximum)\n "~1
"def bubble_sort(a):\n     global c\n     n = len(a)\n     unordered = True\n     while unordered:\n         unordered = False\n         for j in range(n - 1):\n             if a[j] > a[j + 1]:\n                 a[j], a[j + 1] = a[j + 1], a[j]\n                 unordered = True\n                 c += 1\n                 \n         n -= 1\n c = 0\n n = int(input())\n a = list(map(int, input().split()))\n \n bubble_sort(a)\n print(c)\n "~1
"n = int(input())\n a = [int(x) for x in input().split()]\n for i in range(1, len(a)):\n     f = False\n     t = a[i]\n     j = i - 1\n     while j >= 0 and a[j] > t:\n         a[j + 1] = a[j]\n         j -= 1\n         f = True\n     a[j + 1] = t\n     if f:\n         print(*a)\n "~0
"n = int(input())\n f = []\n  \n for i in range(n):\n     f.append(list(map(int,input().split())))\n  \n for i in range(n):\n     for j in range(n - 1):\n         if f[j][1] < f[j + 1][1]:\n             f[j], f[j + 1] = f[j + 1], f[j]\n         elif f[j][1] == f[j + 1][1]:\n             if f[j][0] > f[j + 1][0]:\n                 f[j], f[j + 1] = f[j + 1], f[j]\n  \n  \n for i in range(n):\n     print(f[i][0], " ", f[i][1], sep = "", end = "\n ")\n "~0
"n = int(input())\n lst1 = input().split()\n m = int(input())\n lst2 = input().split()\n if set(lst1) == set(lst2):\n   print("YES")\n else:\n   print("NO")\n "~0
"def mergeSort(alist):\n     if len(alist) > 1:\n         mid = len(alist) // 2\n         lefthalf = alist[:mid]\n         righthalf = alist[mid:]\n  \n         mergeSort(lefthalf)\n         mergeSort(righthalf)\n  \n         i = 0\n         j = 0\n         k = 0\n         while i < len(lefthalf) and j < len(righthalf):\n             if lefthalf[i] < righthalf[j]:\n                 alist[k] = lefthalf[i]\n                 i = i + 1\n             else:\n                 alist[k] = righthalf[j]\n                 j = j + 1\n             k = k + 1\n  \n         while i < len(lefthalf):\n             alist[k] = lefthalf[i]\n             i = i + 1\n             k = k + 1\n  \n         while j < len(righthalf):\n             alist[k] = righthalf[j]\n             j = j + 1\n             k = k + 1\n  \n  \n n=int(input())\n alist = list(map(int, input().split()))[:n]\n mergeSort(alist)\n print(*alist)\n "~1
"x = int(input())\n \n c = []\n \n for i in range(x+2):\n     c.append(i**2)\n     c.append(i**3)\n \n c = list(set(c))\n \n c.sort()\n \n print(c[x])\n "~0
"n = int(input())\n limit = list(map(int, input().split()))\n  \n press = int(input())\n press_num = list(map(int, input().split()))\n  \n for i in range(press):\n         limit[press_num[i] -1] -= 1\n  \n for button in limit:\n         if button < 0:\n                 print('yes')\n         else:\n                print('no')\n "~1
"res = list(filter(lambda x:x.isdigit(), input()))\n print(''.join(sorted(res,reverse = True)) if res else -1)\n "~1
"def push(e):\n     stack.append(e)\n  \n         \n def pop():\n     if len(stack)<1:\n         c='error'\n     else:\n         c=stack.pop();\n     return c\n  \n def back(stack):\n     if len(stack)<1:\n         d='error' \n     else:\n         d=stack[-1]\n     return(d)\n  \n  \n def size(stack):\n     return len(stack)\n  \n  \n def clear(stack):\n     while len(stack)>0:\n         stack.pop()\n       \n         \n def exit():\n     print("bye")\n     b=False\n  \n stack=list([])\n b=True\n while b==True:\n     a=input()\n     if a[1]=="u":\n         p,n=a.split()\n         n=int(n)\n         push(n)\n         print("ok")\n     \n     if a=="pop":\n         print(pop())\n     if a=="size":\n         print(size(stack))\n     if a=="back":\n         print(back(stack))\n     if a=="clear":\n         clear(stack)\n         print("ok")\n     if a=="exit":\n         exit()\n         break\n "~0
"def is_correct_brackets(expr) : \n     stack = [] \n     for char in expr: \n         if char in ["(", "{", "["]: \n             stack.append(char) \n         else:  \n             if not stack: \n                 return False\n             current_char = stack.pop() \n             if current_char == '(': \n                 if char != ")": \n                     return False\n             if current_char == '{': \n                 if char != "}": \n                     return False\n             if current_char == '[': \n                 if char != "]": \n                     return False\n     if stack: \n         return False\n     return True\n     \n a = input()\n if is_correct_brackets(a):\n   print("yes")\n else:\n   print("no")\n "~1
"a=list(input().strip().split())\n #a=list('8 9 + 1 7 - *'.split())\n n=[]\n i=-1\n for s in a:\n     if s[0]>='0' and s[0]<='9' or len(s)>1 and s[0]=='-':\n         cf=-1 if s[0]=='-' else 1\n         n.append(0)\n         i+=1\n         for c in s:\n             if c!='-':\n                 n[i]=n[i]*10+cf*int(c)\n     else:\n         if s=='+':\n             n[i-1]+=n[i]\n         elif s=='-':\n             n[i-1]-=n[i]\n         elif s=='*':\n             n[i-1]*=n[i]\n         else:\n             n[i-1]/=n[i]\n         n.pop(i)\n         i-=1\n  \n print(n[0])\n "~0
"a = []\n b = []\n cnt = 0\n \n a = list(map(int, input().split()))\n b = list(map(int, input().split()))\n \n while len(a) > 0 and len(b) > 0:\n     if cnt >= 10**6:\n         break\n     if a[0] == 0 and b[0] == 9:\n         a.append(a[0])\n         a.append(b[0])\n         a.pop(0)\n         b.pop(0)\n     elif a[0] == 9 and b[0] == 0:\n         b.append(a[0])\n         b.append(b[0])\n         a.pop(0)\n         b.pop(0)\n     elif a[0] > b[0]:\n         a.append(a[0])\n         a.append(b[0])\n         a.pop(0)\n         b.pop(0)\n     else:\n         b.append(a[0])\n         b.append(b[0])\n         a.pop(0)\n         b.pop(0)\n     cnt += 1\n \n if len(a) <= 0:\n     print("second " + str(cnt))\n elif len(b) <= 0:\n     print("first " + str(cnt))\n else:\n     print("botva")\n "~0
"st = [] \n st2 = [] \n mn = [] #Поддержание минимума в 1 стеке\n mn2 = []#Поддержание минимума во 2 стеке\n  \n def push(a):\n     global st\n     global mn\n     st.append(a)\n     if  not mn or a < mn[-1]:\n         mn.append(a)\n     else:\n         mn.append(mn[-1])\n  \n def get_min():\n     global st\n     global st2\n     global mn\n     global mn2\n     if not st2 and st:\n         for i in range(len(st)):       \n             if  not mn2 or st[-1] < mn2[-1]:\n                 mn2.append(st[-1])\n             else:\n                 mn2.append(mn2[-1])\n             st2.append(st.pop())\n         st =[]\n         mn = []\n     if not st2 and not st:\n         print(-1)\n     elif mn:\n         st2.pop()\n         print(min(mn[-1], mn2.pop()))\n     else:\n         st2.pop()\n         print(mn2.pop())\n  \n  \n for k in range(int(input())):\n     a = int(input())\n     if a != 0:\n         push(a)\n     else:\n         get_min()\n "~1
"from collections import deque\n n = int(input())\n q = deque()\n qt = deque()\n k1 = 0\n k2 = 0\n for i in range(n):\n     t1 = input().split()\n     if  "-" in t1:\n         print(q.popleft())\n         k1 -= 1\n     elif  '+' in t1:\n         qt.append(t1[-1])\n         k2 += 1\n     else :\n         qt.appendleft(t1[-1])\n         k2 += 1\n     if k1 < k2:\n         q.append(qt.popleft())\n         k2 -= 1\n         k1 += 1\n "~1
"def clean(N):\n   if N <= 2:\n       return list(range(-N, 0))\n   return clean(N - 2) + [-N] + fill(N - 2) + clean(N - 1)\n  \n  \n def fill(N):\n   if N <= 2:\n       return list(range(1, N + 1))\n   return fill(N - 1) + clean(N - 2) + [N] + fill(N - 2)\n  \n print(*fill(int(input())))\n "~1
"import sys\n sys.setrecursionlimit(3000)\n  \n memo = {}\n  \n def akk(m, n):\n     if not (m, n) in memo:\n         if m == 0:\n             res = n + 1\n         if m>0 and n==0:\n             res = akk(m-1,1)\n         if m>0 and n>0:\n             res = akk(m-1,akk(m,n-1))\n         memo[(m, n)] = res\n     return memo[(m, n)]\n  \n a, b = map(int,input().split())\n print(akk(a,b))\n "~1
"def f(k,n):\n     ans=0\n     if n==0:\n         return ans+1\n     elif k<n:\n         for i in range(k+1,n+1):\n             ans+=f(i, n-i)\n         return ans\n     else:\n         return ans\n n=int(input())\n print(f(0,n))\n "~0
"def pow(a, n):\n     if n == 0:\n         return 1\n     elif n == 1:\n         return a\n     elif n % 2 != 0:\n         return a * pow(a, n - 1)\n     elif n % 2 == 0:\n         return pow(a * a, n / 2)\n a = float(input())\n n = int(input())\n x = pow(a, n)\n if x == int(x):\n     x = int(x)\n print(x)\n "~0
"n, m = map(int, input().split())\n p =[list(map(int, input().split())) for i in range(n)]\n a = [[0] * m for i in range(n)]\n b = [[''] * m for i in range(n)]\n a[0][0] = p[0][0]\n for j in range(1, m):\n     a[0][j] = a[0][j - 1] + p[0][j]\n     b[0][j] = b[0][j-1] + 'R'\n for i in range(1, n):\n     a[i][0] = a[i - 1][0] + p[i][0]\n     b[i][0] = b[i - 1][0] + 'D'\n for i in range(1, n):\n     for j in range(1, m):\n         if a[i][j -1] > a[i - 1][j] :\n             a[i][j] = a[i][j -1] + p[i][j]\n             b[i][j] = b[i][j -1] + 'R'\n         else :\n             a[i][j] = a[i-1][j] + p[i][j]\n             b[i][j] = b[i-1][j] + 'D'\n print(a[-1][-1])\n print(b[-1][-1])\n "~0
"def cik(x, y):\n      if x < 1 or x > 8:\n           return 0\n      if y == 8:\n           return 1\n      return cik(x - 1, y + 1) + cik(x + 1, y + 1)\n x, y = map(int, input().split())\n print(cik(x, y))\n "~0
"n, m = map(int, input().split())\n a = [[str(1 + j + i * m) for j in range(m)] for i in range(n)]\n for i in range(1, n, 2):\n   a[i] = a[i][::-1]\n for row in a:\n   print(' '.join(row))\n "~0
"a = input().split()\n ans = 0\n for i in range(len(a)):\n   for j in range(i+1, len(a)):\n     if a[i] == a[j]:\n       ans += 1\n print(ans)\n "~0
"l = input().split()\n print(max(l, key=l.count))\n "~1
"a = [int(q) for q in input().split()]\n for i in range(len(a)):\n      for j in range(len(a)):\n           if i != j and a[i] == a[j]:\n                break\n      else:\n           print(a[i], end=' ')\n "~0
"a = input().split()\n a[1::2] = a[len(a) - len(a) % 2 - 1 ::-2]\n a[1::2] = a[-(len(a) % 2) - 1 ::-2]\n a[1::2] = a[1::2][::-1]\n print(' '.join(a))\n "~1
"s = input()\n f = input()\n x1 = ord(s[0]) - ord('a') + 1\n y1 = int(s[1])\n x2 = ord(f[0]) - ord('a') + 1\n y2 = int(f[1])\n if abs(x2 - x1) <= 1 and abs(y2 - y1) <= 1:\n   print("YES")\n else:\n   print("NO")\n "~0
"def CaesarCipherChar(c, k):\n   if 'A' <= c <= 'Z':\n         if ord(c) + 3 > 90:\n             return chr(ord(c) + k - 26)\n         else:\n             return chr(ord(c) + k)\n   elif 'a' <= c <= 'z':\n         if ord(c) + 3 > 122:\n             return chr(ord(c) + k - 26)\n         else:\n             return chr(ord(c) + k)        \n   else: \n         return c\n def CaesarCipher(s, k):\n     ans = ''\n     #цикл для чтения каждого символа\n     for i in range(len(s)):\n         c = s[i]\n         #вызываем функцию, возвращающую зашифрованную букву\n         ans += CaesarCipherChar(c, k) \n     return ans\n \n "~1
"n = int(input())\n a = [input().split() for j in range(n)]\n ans = "YES"\n for i in range(n):\n   for j in range(i + 1, n):\n     if a[i][j] != a [j][i]:\n       ans = "NO"\n print(ans)\n "~0
"n, m = map(int, input().split())\n a = [input().split() for i in range(n)]\n i, j = map(int, input().split())\n for k in range(n):\n   a[k][i], a[k][j] = a[k][j], a[k][i]\n for row in a: \n   print(' '.join(row))\n "~1
"ki, kj = map(int, input().split())\n b = [['.'] * 12 for i in range(12)]\n moves = [[1, 2], [1, -2], [-1, 2], [-1, -2], [2, 1], [2, -1], [-2, 1], [-2, -1]]\n ki += 1\n kj += 1\n for di, dj in moves:\n   i = ki + di\n   j = kj + dj\n   b[i][j] = '*'\n b[ki][kj] = 'K'\n for row in b[2: -2]:\n   print(' '.join(row[2:-2]))\n "~1
"def gather():\n     x,y = [int(i) - 1 for i in input().split()]\n     gold = lst[x][y]\n     lst[x][y] = 0\n     return gold\n     \n lst =[list(map(int,input().split())) for _ in range(list(map(int,input().split()))[0])]\n print(sum([gather() for _  in range(int(input()))]))\n "~1
"n, m = map(int, input().split())\n a = [[1] * m] * n\n for i in range(m):\n      print(a[0][i], end=' ')\n print()\n for i in range(n - 1):\n      i += 1\n      print(a[0][0], end=' ')\n      for j in range(m - 1):\n           j += 1\n           a[i][j] = a[i][j - 1] + a[i - 1][j]\n           print(a[i][j], end=' ')\n      print()\n "~0
"n = int(input())\n matrix =[list(map(int, input().split())) for i in range(n)]\n for i in range(len(matrix)):\n     for j in range(i , len(matrix)):\n         matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n for jjj in range(n):\n     print(*matrix[jjj])\n "~1
"n, m = map(int, input().split())\n masc = 0\n ans = 0\n a = []\n for i in range(n):\n     a.append(list(map(int, input().split())))\n     mask = max(a[i])\n     masc = max(masc, mask)\n for l in range(n):\n     for j in range(m):\n         if a[l][j] == masc:\n             ans = 1\n             break\n     if ans != 0:\n         break\n if n != 0 and m != 0:\n     print(l, j)\n "~0
"def move(n, start, finish):\n   if n > 0:\n     tmp = 6 - start - finish\n     if (finish - start) % 3 == 1:\n       move(n-1, start, tmp)\n       print(n, start, finish)\n       move(n-1, tmp, finish)\n     else:\n       move(n-1, start, finish)\n       print(n, start, tmp)\n       move(n-1, finish, start)\n       print(n, tmp, finish)\n       move(n-1, start, finish)\n move(int(input()), 1, 3)\n "~1
"def num (n, k):\n   if n == 0:\n     return 1\n   ans = 0\n   for d in range(1, min(n, k) + 1):\n     ans += num(n-d, d)\n   return ans\n n = int(input())\n print(num(n, n))\n "~0
"n = int(input())\n points = [tuple(map(int, input().split())) for _ in range(n)]\n \n unique_x = sorted({x for x, y in points})\n unique_y = sorted({y for x, y in points})\n \n lines = []\n \n for i in range(len(unique_x) - 1):\n     lines.append(f"x {unique_x[i] + 1}")\n \n for i in range(len(unique_y) - 1):\n     lines.append(f"y {unique_y[i] + 1}")\n \n print(len(lines))\n print('\n '.join(lines))\n "~1
"import sys\n \n N = int(sys.stdin.readline())\n dictionary = {}\n for _ in range(N):\n     word = sys.stdin.readline().strip()\n     lower_word = word.lower()\n     if lower_word not in dictionary:\n         dictionary[lower_word] = set()\n     dictionary[lower_word].add(word)\n \n text = sys.stdin.readline().strip().split()\n errors = 0\n \n for word in text:\n     lower_word = word.lower()\n     if lower_word in dictionary:\n         if word not in dictionary[lower_word]:\n             errors += 1\n     else:\n         uppercase_count = sum(1 for c in word if c.isupper())\n         if uppercase_count != 1:\n             errors += 1\n \n print(errors)\n "~1
"import sys\n \n input = sys.stdin.read().split()\n ptr = 0\n N = int(input[ptr])\n ptr += 1\n M = int(input[ptr])\n ptr += 1\n \n last_attempt = {}  # слово -> номер последней команды\n attempts_count = {}  # слово -> количество попыток\n \n for _ in range(M):\n     team = int(input[ptr])\n     ptr += 1\n     word = input[ptr]\n     ptr += 1\n     last_attempt[word] = team\n     attempts_count[word] = attempts_count.get(word, 0) + 1\n \n team_scores = [0] * (N + 1)  # индексы от 1 до N\n for word in last_attempt:\n     team = last_attempt[word]\n     team_scores[team] += 1\n \n print(' '.join(map(str, team_scores[1:])))\n "~1
"import sys\n from collections import defaultdict\n \n def main():\n     input = sys.stdin.read().split('\n ')\n     ptr = 0\n     N = int(input[ptr])\n     ptr += 1\n \n     state_electors = {}\n     for _ in range(N):\n         parts = input[ptr].split()\n         state_name = parts[0]\n         electors = int(parts[1])\n         state_electors[state_name] = electors\n         ptr += 1\n \n     M = int(input[ptr])\n     ptr += 1\n \n     state_votes = defaultdict(lambda: defaultdict(int))\n     for _ in range(M):\n         if ptr >= len(input):\n             break\n         line = input[ptr].strip()\n         if not line:\n             ptr += 1\n             continue\n         parts = line.split()\n         state = parts[0]\n         candidate = parts[1]\n         state_votes[state][candidate] += 1\n         ptr += 1\n \n     candidate_electors = defaultdict(int)\n     for state in state_electors:\n         votes = state_votes[state]\n         if not votes:\n             continue\n         max_votes = max(votes.values())\n         candidates = [c for c, v in votes.items() if v == max_votes]\n         winner = min(candidates)\n         candidate_electors[winner] += state_electors[state]\n \n     all_candidates = set()\n     for state in state_votes:\n         for candidate in state_votes[state]:\n             all_candidates.add(candidate)\n \n     sorted_candidates = sorted(all_candidates, key=lambda x: (-candidate_electors.get(x, 0), x))\n     for candidate in sorted_candidates:\n         print(f"{candidate} {candidate_electors.get(candidate, 0)}")\n \n if __name__ == "__main__":\n     main()\n "~1
"n = int(input())\n accounts = {}\n \n for _ in range(n):\n     parts = input().split()\n     cmd = parts[0]\n     \n     if cmd == 'DEPOSIT':\n         name = parts[1]\n         sum_ = int(parts[2])\n         accounts[name] = accounts.get(name, 0) + sum_\n     elif cmd == 'WITHDRAW':\n         name = parts[1]\n         sum_ = int(parts[2])\n         accounts[name] = accounts.get(name, 0) - sum_\n     elif cmd == 'BALANCE':\n         name = parts[1]\n         if name in accounts:\n             print(accounts[name])\n         else:\n             print("ERROR")\n     elif cmd == 'TRANSFER':\n         name1, name2 = parts[1], parts[2]\n         sum_ = int(parts[3])\n         if name1 not in accounts:\n             accounts[name1] = 0\n         if name2 not in accounts:\n             accounts[name2] = 0\n         accounts[name1] -= sum_\n         accounts[name2] += sum_\n     elif cmd == 'INCOME':\n         p = int\n "~1
"S = input().strip()\n seen = set()\n result = []\n for char in S:\n     if char not in seen:\n         seen.add(char)\n         result.append(char)\n print(''.join(result))\n "~1
"import sys\n input = sys.stdin.read\n data = input().split()\n \n index = 0\n \n # Чтение множества T\n n = int(data[index])\n index += 1\n T = set()\n if n > 0:\n     T.update(map(int, data[index:index + n]))\n     index += n\n \n # Чтение множества R\n n = int(data[index])\n index += 1\n R = set()\n if n > 0:\n     R.update(map(int, data[index:index + n]))\n     index += n\n \n # Чтение множества T1\n n = int(data[index])\n index += 1\n T1 = set(map(int, data[index:index + n]))\n index += n\n \n # Чтение множества R1\n n = int(data[index])\n index += 1\n R1 = set(map(int, data[index:index + n]))\n index += n\n \n # Проверка учителей\n if not T1.isdisjoint(T):\n     print(-1)\n     return\n \n # Поиск минимального свободного кабинета\n available_rooms = R1 - R\n if not available_rooms:\n     print(-1)\n     return\n min_room = min(available_rooms)\n \n # Обновление множеств\n T.update(T1)\n R.add(min_room)\n \n # Вывод результатов\n print(len(T))\n print(' '.join(map(str, sorted(T))))\n print(len(R))\n print(' '.join(map(str, sorted(R))))\n "~1
"n=int(input())\n dp=[0]*(n+1)\n dp[1]=0\n pr=[-1]*(n+1)\n for i in range(2,n+1):\n     dp[i]=dp[i-1]+1\n     pr[i]=i-1\n     if i%2==0:\n         if dp[i]>dp[i//2]+1:\n             dp[i]=dp[i//2]+1\n             pr[i]=i//2\n     if i%3==0:\n         if dp[i]>dp[i//3]+1:\n             dp[i]=dp[i//3]+1\n             pr[i]=i//3\n cur=n\n ans=[]\n while cur!=1:\n     q=pr[cur]\n     if cur==q+1:\n         ans.append('1')\n     elif cur==q*2:\n         ans.append('2')\n     elif cur==q*3:\n         ans.append('3')\n     cur=q\n ans.reverse()\n print(''.join(ans))\n "~0
"n=int(input())\n dp=list([0]*10 for _ in range(n+1))\n for i in range(10):\n     dp[1][i]=1\n for i in range(2,n+1):\n     dp[i][0]=dp[i-1][6]+dp[i-1][4]\n     dp[i][1]=dp[i-1][8]+dp[i-1][6]\n     dp[i][2]=dp[i-1][7]+dp[i-1][9]\n     dp[i][3]=dp[i-1][4]+dp[i-1][8]\n     dp[i][4]=dp[i-1][3]+dp[i-1][9]+dp[i-1][0]\n     dp[i][6]=dp[i-1][1]+dp[i-1][7]+dp[i-1][0]\n     dp[i][7]=dp[i-1][6]+dp[i-1][2]\n     dp[i][8]=dp[i-1][1]+dp[i-1][3]\n     dp[i][9]=dp[i-1][2]+dp[i-1][4]\n print((dp[-1][1]+dp[-1][2]+dp[-1][3]+dp[-1][4]+dp[-1][5]+dp[-1][6]+dp[-1][7]+dp[-1][9])%1000000000)\n "~0
"n=int(input())\n dp=list([0]*10 for _ in range(n+1))\n dp[1][0]=0\n for i in range(1,10):\n     dp[1][i]=1\n for i in range(2,n+1):\n     for j in range(10):\n         dp[i][j]=dp[i-1][j]\n         if j!=0:\n             dp[i][j]+=dp[i-1][j-1]\n         if j!=9:\n             dp[i][j]+=dp[i-1][j+1]\n s=0\n for i in range(10):\n     s+=dp[n][i]\n print(s)\n \n "~0
"a=input()\n n=int(input())\n s=[]\n for i in range (n):\n     a1=input()\n     s.append(a1)\n s=sorted(s)\n dp=[(-1,-1)]*(len(a)+2)\n dp[0]=(0,-1)\n s1=""\n for i in range (len(a)+1):\n     for j in range (i+1):\n         if dp[i-j][0]>=0:\n             for r in range (n):\n                 if s[r]==a[i-j:i]:\n                     dp[i]=(i-j,r)\n                     s1=s[r]\n                     break\n cnt=len(a)\n q=[]\n while cnt>0:\n     q.append(s[dp[cnt][1]])\n     cnt=dp[cnt][0]\n for i in range (len(q)-1,-1,-1):\n     print(q[i],end=" ")\n "~0
"n=int(input())\n a=list(map(int,input().split()))\n a=sorted(a)\n dp=[0]*n\n if n==2:\n     print(a[1]-a[0])\n     exit()\n if n==3:\n     print(a[2]-a[0])\n     exit()\n dp[0]=0\n dp[1]=a[1]-a[0]\n dp[2]=a[2]-a[0]\n for i in range (3,n):\n     dp[i]=min(dp[i-2]+a[i]-a[i-1],dp[i-1]+a[i]-a[i-1])\n print(dp[-1])\n \n "~0
"n=int(input())\n s=list(map(int,input().split()))\n a=set(s)\n m=int(input())\n s=list(map(int,input().split()))\n b=set(s)\n c=set(a^b)\n print(len(c))\n print(*sorted(c))\n "~0
"class student:\n     surname=""\n     name=""\n     clas1=0\n     clas2=""\n     dr=""\n     def __init__(self,surname,name,clas1,clas2,dr):\n         self.surname=surname\n         self.name=name\n         self.clas1=clas1\n         self.clas2=clas2\n         self.dr=dr\n     def __str__ (self):\n         return str(self.clas1)+self.clas2+" " + self.surname+" "+self.name+" "+self.dr\n a=int(input())\n b=[]\n for i in range (a):\n     sur=input()\n     n=input()\n     cl=input()\n     if len(cl)==2:\n         cl1=int(cl[0])\n         cl2=cl[1]\n     else:\n         cl1=int(cl[0])*10+int(cl[1])\n         cl2=cl[2]\n     dr=input()\n     s=student(sur,n,cl1,cl2,dr)\n     b.append(s)\n sortb=sorted(b,key=lambda x:(x.clas1,x.clas2, x.surname))\n for i in range (a):\n     print(sortb[i])\n "~1
"import heapq\n n,k=map(int,input().split())\n a=[]\n heapq.heapify(a)\n for i in range (n):\n     s,m=map(int,input().split())\n     if len(a)==k:\n         mins=a[0]\n         print(heapq.heappop(a))\n         if mins<s:\n             heapq.heappush(a,m+s)\n         else:\n             heapq.heappush(a,m+mins)\n     else:\n         heapq.heappush(a,s+m)\n for i in range (len(a)):\n     print(a[i])\n "~1
"def check(m,a,b,c):\n     return (m//a)*(m//b)<c\n a,b,c=map(int,input().split())\n l=0\n r=10**18\n while r-l>1:\n     m=(l+r)//2\n     #print(m,l,r)\n     if check(m,a,b,c):\n         l=m\n     else:\n         r=m\n print(r)\n "~0
"def check(m,a,k):\n     kol=0\n     for i in range (len(a)):\n         kol+=a[i]//m\n     if kol>=k:\n         return True\n     else:\n         return False\n n,k=map(int,input().split())\n a=[]\n for i in range (n):\n     x=int(input())\n     a.append(x)\n l=0\n r=1000000000000\n while r-l>1:\n     m=(r+l)//2\n     if check(m,a,k):\n         l=m\n     else:\n         r=m\n print(l)\n "~0





"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n     int n;\n     cin >> n;\n     vector <int> s(n);\n     vector <pair <int, int>> b;\n     for (int i = 0; i < n; i++) {\n         cin >> s[i];\n         if (b.empty()) {\n             b.push_back({s[i], 1});\n         } else {\n             if (b.back().first == s[i]) {\n                 b.back().second++;\n             } else {\n                 b.push_back({s[i], 1});\n             }\n         }\n     }\n     int mn = LLONG_MAX;\n     for (auto i: b) {\n         mn = min(mn, i.first * (n - i.second));\n     }\n     cout << mn << "\n ";\n }\n \n signed main() {\n     int t = 1;\n     cin >> t;\n     while (t--) {\n         solve();\n     }\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n     int n;\n     cin >> n;\n     int a[3];\n     a[0] = 0, a[1] = 0, a[2] = 0;\n     int k = 0;\n     while (a[0] < n || a[1] < n || a[2] < n) {\n         k++;\n         int mn = min({a[0], a[1], a[2]});\n         if (a[0] == mn) {\n             a[0] = min(a[1], a[2]) * 2 + 1;\n         } else if (a[1] == mn) {\n             a[1] = min(a[0], a[2]) * 2 + 1;\n         } else {\n             a[2] = min(a[0], a[1]) * 2 + 1;\n         }\n     }\n     cout << k << "\n ";\n }\n \n signed main() {\n     int t = 1;\n     cin >> t;\n     while (t--) {\n         solve();\n     }\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n void solve() {\n 	int a, b, c, d;\n 	cin >> a >> b >> c >> d; // flower - b, d; gellyfish - a, c\n 	if (min(a, c) < min(b, d)) {\n 		cout << "Flower" << "\n ";\n 	} else {\n 		cout << "Gellyfish" << "\n ";\n 	}\n }\n \n signed main() {\n 	int t = 1;\n 	cin >> t;\n 	while (t--) {\n 		solve();\n 	}\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n 	string s1, s2;\n 	cin >> s1 >> s2;\n 	vector <pair <char, int>> t1, t2;\n 	for (int i = 0; i < s1.size(); i++) {\n 		if (!t1.empty()) {\n 			if (s1[i] == t1.back().first) {\n 				t1.back().second++;\n 			} else {\n 				t1.push_back({s1[i], 1});\n 			}\n 		} else {\n 			t1.push_back({s1[i], 1});\n 		}\n 	}\n 	for (int i = 0; i < s2.size(); i++) {\n 		if (!t2.empty()) {\n 			if (s2[i] == t2.back().first) {\n 				t2.back().second++;\n 			} else {\n 				t2.push_back({s2[i], 1});\n 			}\n 		} else {\n 			t2.push_back({s2[i], 1});\n 		}\n 	}\n 	bool f = true;\n 	if (t1.size() == t2.size()) {\n 		for (int i = 0; i < t1.size(); i++) {\n 			if (t2[i].second > t1[i].second * 2 || t2[i].second < t1[i].second || t2[i].first != t1[i].first) {\n 				f = false;\n 				break;\n 			}\n 		}\n 	} else {\n 		f = false;\n 	}\n 	if (f) cout << "YES" << "\n ";\n 	else cout << "NO" << "\n ";\n 	return ;\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n 	int n;\n 	cin >> n;\n 	vector <int> ans(2 * n);\n 	for (int i = 0; i < n; i++) {\n 		for (int j = 0; j < n; j++) {\n 			cin >> ans[i + j];\n 		}\n 	}\n 	vector <int> t = ans;\n 	sort(t.begin(), t.end());\n 	int x = 1, y = 0;\n 	for (auto i: t) {\n 		if (i == 0) continue;\n 		if (i != x) {\n 			cout << x << " ";\n 			y = 1;\n 			break;\n 		}\n 		x++;\n 	}\n 	if (y == 0) cout << x << " ";\n 	for (auto i: ans) if (i != 0) cout << i << " ";\n 	cout << "\n ";\n 	return ;\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n 	int a, b, c, d;\n 	cin >> a >> b >> c >> d;\n 	b = a - b;\n 	while (c < 0 && b) {\n 		b--;\n 		c++;\n 	}\n 	while (d > 0 && b) {\n 		b--;\n 		d--;\n 	}\n 	cout << c << " " << d << "\n ";\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n 	string s1, s2, s3;\n 	cin >> s1 >> s2 >> s3;\n 	cout << s1[0] << s2[0] << s3[0] << "\n ";\n 	return ;\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n \n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n #define int long long\n \n signed main() {\n 	int n;\n 	cin >> n;\n 	for (int i = 0; i < n; i++) {\n 		int a;\n 		cin >> a;\n 		if (a == 1 || a == 3) {\n 			cout << -1 << endl;\n 			continue;\n 		}\n 		vector <int> s(a, 0);\n 		s[0] = 6;\n 		s[1] = 6;\n 		if (a % 2 == 0) {\n 			for (int j = 2; j < a; j++) {\n 				s[j] = 3;\n 			}\n 		} else {\n 			s[3] = 6;\n 			for (int j = 2; j < a; j++) {\n 				if (!s[j]) {\n 					s[j] = 3;\n 				}\n 			}\n 		}\n 		reverse(s.begin(), s.end());\n 		for (auto j: s) {\n 			cout << j;\n 		}\n 		cout << endl;\n 	}\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n #define int long long\n \n signed main() {\n 	int n;\n 	cin >> n;\n 	for (int i = 0; i < n; i++) {\n 		int a, b, c, d;\n 		cin >> a >> b >> c >> d;\n 		int ans = (a - c) * b;\n 		ans += (a - c) * (b - 1);\n 		ans += b - d;\n 		cout << ans << endl;\n 	}\n 	return 0;\n }\n \n \n "~0
"#include <bits/stdc++.h>\n  \n using namespace std;\n \n int main() {\n     int n;\n     cin >> n;\n     for (int i = 0; i < n; i++) {\n     	int x;\n     	cin >> x;\n     	cout << x % 10 + x / 10 << endl;\n     }\n     return 0;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <math.h>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n #define all(a) a.begin(), a.end()\n #ifdef LOCAL\n #define debug(x) cerr << __LINE__ << ": " << (#x) << " = " << x << endl;\n #endif\n \n using namespace std;\n \n ll bin_pow(ll a, ll b, ll m) {\n 	if (b == 0) {\n 		return 1;\n 	}\n 	else if (b % 2 == 1) {\n 		return (bin_pow(a, b - 1, m) * a) % m;\n 	}\n 	else {\n 		return bin_pow((a * a) % m, b / 2, m);\n 	}\n }\n \n ll gcd(ll a, ll b) {\n 	while (a != 0 and b != 0) {\n 		if (a < b) {\n 			swap(a, b);\n 		}\n 		a %= b;\n 	}\n 	if (a == 0)\n 		return b;\n 	else\n 		return a;\n }\n \n \n int main() {\n 	int l = 2, r;\n 	cin >> r;\n 	vector <int> a;\n 	vector <bool> vis(r + 1, false);\n 	vector <int> vs(r + 1, 0);\n 	vector <int> prime;\n 	for (int i = 2; i * i <= r; i++) {\n 		if (!vis[i]) {\n 			int c = i * i;\n 			while (c <= r) {\n 				vis[c] = true;\n 				c += i;\n 			}\n 		}\n 	}\n 	for (int i = l; i <= r; i++) {\n 		if (!vis[i] and i != 1) {\n 			prime.push_back(i);\n 		}\n 	}\n 	for (auto i : prime) {\n 		int c = i;\n 		while (c <= r) {\n 			vs[c]++;\n 			c += i;\n 		}\n 	}\n 	for (int i = 2; i <= r; i++) {\n 		if (vs[i] >= 3) {\n 			cout << i << " ";\n 		}\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <math.h>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n #define all(a) a.begin(), a.end()\n #ifdef LOCAL\n #define debug(x) cerr << __LINE__ << ": " << (#x) << " = " << x << endl;\n #endif\n \n using namespace std;\n \n ll bin_pow(ll a, ll b, ll m) {\n 	if (b == 0) {\n 		return 1;\n 	}\n 	else if (b % 2 == 1) {\n 		return (bin_pow(a, b - 1, m) * a) % m;\n 	}\n 	else {\n 		return bin_pow((a * a) % m, b / 2, m);\n 	}\n }\n \n ll gcd(ll a, ll b) {\n 	while (a != 0 and b != 0) {\n 		if (a < b) {\n 			swap(a, b);\n 		}\n 		a %= b;\n 	}\n 	if (a == 0)\n 		return b;\n 	else\n 		return a;\n }\n \n \n int main() {\n 	int n, l = INT_MAX, r = INT_MIN;\n 	cin >> n;\n 	vector <int> b(n);\n 	for (int i = 0; i < n; i++) {\n 		cin >> b[i];\n 		if (b[i] < l) {\n 			l = b[i];\n 		}\n 		if (b[i] > r) {\n 			r = b[i];\n 		}\n 	}\n 	vector <int> a;\n 	vector <bool> vis(r + 1, false);\n 	vector <int> prime;\n 	for (int i = 2; i * i <= r; i++) {\n 		if (!vis[i]) {\n 			int c = i * i;\n 			while (c <= r) {\n 				vis[c] = true;\n 				c += i;\n 			}\n 		}\n 	}\n 	for (auto i : b) {\n 		if (i == 1) {\n 			cout << 0;\n 			continue;\n 		}\n 		if (!vis[i]) {\n 			cout << 1;\n 		}\n 		else {\n 			cout << 0;\n 		}\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <math.h>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n #define all(a) a.begin(), a.end()\n #ifdef LOCAL\n 	#define debug(x) cerr << __LINE__ << ": " << (#x) << " = " << x << endl;\n #endif\n \n using namespace std;\n \n int mod = 1e9 + 9;\n \n ll bin_pow(ll a, ll b, ll m) {\n 	if (b == 0) {\n 		return 1;\n 	}\n 	else if (b % 2 == 1) {\n 		return (bin_pow(a, b - 1, m) * a) % m;\n 	}\n 	else {\n 		return bin_pow((a * a) % m, b / 2, m);\n 	}\n }\n \n ll gcd(ll a, ll b) {\n 	while (a != 0 and b != 0) {\n 		if (a < b) {\n 			swap(a, b);\n 		}\n 		a %= b;\n 	}\n 	if (a == 0)\n 		return b;\n 	else\n 		return a;\n }\n \n vector <ll> gcd_ext(ll a, ll b) {\n 	if (b == 0) {\n 		return { a, 1, 0 };\n 	}\n 	vector <ll> p = gcd_ext(b, a % b);\n 	ll d = p[0];\n 	ll x = p[1];\n 	ll y = p[2];\n 	return { d, y, x - (a / b) * y };\n }\n \n \n int main() {\n 	ll a, b, c;\n 	cin >> a >> b >> c;\n 	vector <ll> p = gcd_ext(a, b);\n 	ll d = p[0];\n 	ll x = p[1];\n 	ll y = p[2];\n 	if (c % d != 0) {\n 		cout << "Impossible";\n 		return 0;\n 	}\n 	a /= d;\n 	b /= d;\n 	c /= d;\n 	x = x * c;\n 	y = y * c;\n 	if (x < 0) {\n 		while (x < 0) {\n 			x += b;\n 			y -= a;\n 		}\n 	}\n 	else {\n 		y += a * (x / b);\n 		x %= b;\n 	}\n 	cout << x << " " << y;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n \n using namespace std;\n \n unsigned ll f(unsigned ll m, vector <unsigned ll>& d) {\n 	unsigned ll sm = 0;\n 	for (int i = 0; i < d.size(); i++) {\n 		sm += min(m, d[i]);\n 	}\n 	return sm;\n }\n \n int main() {\n 	map <string, vector <string>> a;\n 	bool f = false;\n 	string namef;\n 	while (true) {\n 		string t;\n 		cin >> t;\n 		if (t == "endprg") {\n 			break;\n 		}\n \n 		if (t == "function") {\n 			f = true;\n 			cin >> namef;\n 			continue;\n 		}\n \n 		if (t == "end") {\n 			f = false;\n 		}\n \n 		if (f) {\n 			if (t == "print") {\n 				string h;\n 				cin >> h;\n 				a[namef].push_back(h);\n 			}\n 			else if (t == "call") {\n 				string h;\n 				cin >> h;\n 				for (auto i : a[h]) {\n 					a[namef].push_back(i);\n 				}\n 			}\n 		}\n 		else {\n 			if (t == "print") {\n 				string h;\n 				cin >> h;\n 				cout << h << endl;\n 			}\n 			else if (t == "call") {\n 				string h;\n 				cin >> h;\n 				for (auto i : a[h]) {\n 					cout << i << endl;\n 				}\n 			}\n 		}\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n \n using namespace std;\n \n int main() {\n 	int n;\n 	cin >> n;\n 	vector <int> a(n);\n 	vector <int> ans(n, n);\n 	stack <pair<int, int>> st;\n 	for (int i = 0; i < n; i++) {\n 		int t;\n 		cin >> t;\n 		a[i] = t;\n 		while (!st.empty() && st.top().first < t) {\n 			ans[st.top().second] = i;\n 			st.pop();\n 		}\n 		st.push({ t, i });\n 	}\n \n 	vector <int> ans2(n, -1);\n 	stack <pair<int, int>> st2;\n 	for (int i = n - 1; i >= 0; i--) {\n 		while (!st2.empty() && st2.top().first < a[i]) {\n 			ans2[st2.top().second] = i;\n 			st2.pop();\n 		}\n 		st2.push({ a[i], i });\n 	}\n \n 	for (int i = 0; i < n; i++) {\n 		int sm = 0;\n 		if (abs(ans[i] - i) >= 1) {\n 			sm += abs(ans[i] - i) - 1;\n 		}\n \n 		if (abs(ans2[i] - i) >= 1) {\n 			sm += abs(ans2[i] - i) - 1;\n 		}\n 		cout << sm + 1 << " ";\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n \n using namespace std;\n \n ll f(ll n, ll m, ll d) {\n 	return n * d * 2 + m * d * 2 - d * d * 4;\n }\n \n int main() {\n 	ll n, m, t;\n 	cin >> n >> m >> t;\n 	ll l = -1, r = max(n, m) / 2 + 1;\n 	while (l + 1 < r) {\n 		ll d = (l + r) / 2;\n 		if (f(n, m, d) <= t) {\n 			l = d;\n 		}\n 		else {\n 			r = d;\n 		}\n 	}\n 	cout << l;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n using namespace std;\n #define ll long long\n \n unsigned ll n, k;\n \n void f(int t, vector <int>& a) {\n 	int l = 0, r = a.size();\n 	while (l + 1 < r) {\n 		int m = (l + r) / 2;\n 		if (a[m] > t) {\n 			r = m;\n 		}\n 		else {\n 			l = m;\n 		}\n 	}\n 	if (a[l] == t) {\n 		cout << l + 1 << " ";\n 	}\n 	else {\n 		cout << "-1 ";\n 	}\n }\n \n int main() {\n 	int n;\n 	cin >> n;\n 	vector <int> a(n);\n 	for (int i = 0; i < n; i++) {\n 		cin >> a[i];\n 	}\n \n 	int m;\n 	cin >> m;\n 	for (int i = 0; i < m; i++) {\n 		int t;\n 		cin >> t;\n 		f(t, a);\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n using namespace std;\n #define ll long long\n \n int main() {\n 	double c;\n 	cin >> c;\n 	double l = 0.0, r = c;\n 	for (int i = 0; i < 100; i++) {\n 		double m = (r + l) / 2;\n 		if (m * m + sqrt(m) >= c) {\n 			r = m;\n 		}\n 		else {\n 			l = m;\n 		}\n 	}\n 	cout << setprecision(6) << fixed << r;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <deque>\n using namespace std;\n #define ll long long\n \n int main() {\n 	int n, p = 0, q = 0;\n 	bool al = true;\n 	cin >> n;\n 	deque <int> a;\n 	for (int i = 0; i < n; i++) {\n 		int t;\n 		cin >> t;\n 		a.push_back(t);\n 	}\n 	while (!a.empty()) {\n \n 		if (a.size() == 1) {\n 			if (al) {\n 				p++;\n 			}\n 			else {\n 				q++;\n 			}\n 			a.pop_front();\n 			continue;\n 		}\n \n 		if (a.front() < a.back()) {\n 			p++;\n 			int k = a.back();\n 			a.pop_back();\n 			a.push_back(k - a.front());\n 			a.pop_front();\n 			al = false;\n 		}\n 		else if (a.front() == a.back()) {\n 			a.pop_back();\n 			a.pop_front();\n 			p++;\n 			q++;\n 			al = true;\n 		}\n 		else {\n 			q++;\n 			int k = a.front();\n 			a.pop_front();\n 			a.push_front(k - a.back());\n 			a.pop_back();\n 			al = true;\n 		}\n 	}\n 	cout << p << " " << q;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n using namespace std;\n #define ll long long\n \n int main() {\n 	int n, k;\n 	cin >> n >> k;\n 	vector <int> a(n);\n 	vector <int> suff(n + 1);\n 	vector <int> suffi(n + 1);\n 	suff[n] = INT_MIN;\n 	suffi[n] = -1;\n 	for (int i = 0; i < n; i++) {\n 		cin >> a[i];\n 	}\n 	for (int i = n - 1; i >= 0; i--) {\n 		if (a[i] > suff[i + 1]) {\n 			suff[i] = a[i];\n 			suffi[i] = i;\n 		}\n 		else {\n 			suff[i] = suff[i + 1];\n 			suffi[i] = suffi[i + 1];\n 		}\n 	}\n 	int mx = INT_MIN;\n 	int mxi = INT_MIN;\n 	int mxj = INT_MIN;\n 	for (int i = 1; i < n - k; i++) {\n 		int j = i + k + 1;\n 		if (suff[j - 1] - a[i - 1] > mx) {\n 			mx = suff[j - 1] - a[i - 1];\n 			mxi = i;\n 			mxj = suffi[j - 1] + 1;\n 		}\n 	}\n 	cout << mxi << " " << mxj << endl;\n 	cout << mx;\n }\n "~0
"#include <iostream>\n #include <vector>\n using namespace std;\n typedef long long ll;\n \n ll gcd(ll a, ll b) {\n   while (a && b) {\n     if (a > b)\n       a %= b;\n     else\n       b %= a;\n   }\n   return a + b;\n }\n \n ll lcm(ll a, ll b) {\n   return a / gcd(a, b) * b;\n }\n \n int main() {\n   int n;\n   cin >> n;\n   vector<pair<ll, ll>> drobi(n);\n   char hlam;\n   for (int i = 0; i < n; i++)\n     cin >> drobi[i].first >> hlam >> drobi[i].second;\n   for (auto &[a, b] : drobi) {\n     ll x = gcd(a, b);\n     a /= x;\n     b /= x;\n     cout << a << "/" << b << "\n ";\n   }\n }\n "~0
"#include <iostream>\n using namespace std;\n \n int gcd(int a, int b, int &x, int &y) {\n   if (a == 0) {\n     x = 0;\n     y = 1;\n     return b;\n   }\n   int x1, y1;\n   int d = gcd(b % a, a, x1, y1);\n   x = y1 - (b / a) * x1;\n   y = x1;\n   return d;\n }\n \n int main() {\n   int x, y;\n   int a, b, c;\n   cin >> a >> b >> c;\n   int d = gcd(a, b, x, y);\n   if (c % d == 0) {\n     x *= (c / d);\n     y *= (c / d);\n     cout << d << " " << x << " " << y << "\n ";\n   } else\n     cout << "Impossible\n ";\n }\n "~0
"#include <algorithm>\n #include <deque>\n #include <iostream>\n #include <map>\n #include <queue>\n #include <set>\n #include <stack>\n #include <vector>\n using namespace std;\n typedef long long ll;\n \n void solve() {\n   int n, k;\n   cin >> k >> n;\n   vector<int> a(n + 1);\n   cin >> a[0];\n   for (int i = 1; i <= n; i++) {\n     cin >> a[i];\n     a[i] += a[i - 1];\n   }\n   map<char, string> seats;\n   for (char ch = 'A'; ch < 'A' + k; ch++)\n     seats[ch] = "Boring";\n   seats['A'] = "Window";\n   seats['A' + k - 1] = "Window";\n \n   for (int i = 0; i < n; i++) {\n     if (seats[a[i] + 'A' - 1] == "Window")\n       seats[a[i] + 'A' - 1] = "Both";\n     else\n       seats[a[i] + 'A' - 1] = "Aisle";\n     if (seats[a[i] + 'A'] == "Window")\n       seats[a[i] + 'A'] = "Both";\n     else\n       seats[a[i] + 'A'] = "Aisle";\n   }\n   string s;\n   cin >> s;\n   for (char &ch : s)\n     cout << seats[ch] << "\n ";\n }\n \n int main() {\n   ios::sync_with_stdio(false);\n   cin.tie(NULL);\n \n   solve();\n }\n "~0
"#include <algorithm>\n #include <deque>\n #include <iostream>\n #include <map>\n #include <queue>\n #include <set>\n #include <stack>\n #include <vector>\n using namespace std;\n typedef long long ll;\n \n void solve() {\n   string a, b;\n   cin >> a >> b;\n   size_t sz = a.size();\n   a += b;\n   sort(a.begin(), a.end());\n   cout << a.substr(0, sz) << "\n ";\n }\n \n int main() {\n   ios::sync_with_stdio(false);\n   cin.tie(NULL);\n \n   solve();\n }\n "~0
"#include <iostream>\n #include <map>\n #include <set>\n #include <vector>\n using namespace std;\n \n map<int, int> divs(int n) {\n   map<int, int> res;\n   for (int i = 2; i * i <= n; i++)\n     while (n % i == 0) {\n       res[i]++;\n       n /= i;\n     }\n   if (n > 1)\n     res[n]++;\n   return res;\n }\n \n int main() {\n   int a, b;\n   cin >> a >> b;\n   if (a == b) {\n     cout << "0\n ";\n     return 0;\n   }\n   map<int, int> d1 = divs(a), d2 = divs(b);\n   set<int> keys;\n   for (auto [d, k] : d1)\n     keys.emplace(d);\n   for (auto [d, k] : d2) {\n     keys.emplace(d);\n   }\n   int count = 0;\n   for (int key : keys)\n     if (key == 2 || key == 3 || key == 5) {\n       count += abs(d1[key] - d2[key]);\n     } else if (d1[key] != d2[key]) {\n       cout << "-1\n ";\n       return 0;\n     }\n   cout << count << "\n ";\n }\n "~0
"#include <bits\stdc++.h>\n using namespace std;\n long long a, b, ans;\n void fact(int x) {\n     int z = 0, y = 0;\n     while (a % x == 0) {\n         a /= x;\n         z++;\n     }\n     while (b % x == 0) {\n         b /= x;\n         y++;\n     }\n     ans += abs(z - y);\n }\n int main() {\n     cin >> a >> b;\n     fact(2);\n     fact(3);\n     fact(5);\n     if(a != b) {\n         cout << -1;\n     } else {\n         cout << ans;\n     }\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n const long long N = 2e6 + 1;\n long long t[4 * N][3];\n long long ky[300001];\n map<long long, long long> ky_;\n \n void build(long long v, long long tl, long long tr) {\n     if (tl == tr) {\n         t[v][2] = ky[tl + 1] - ky[tl];\n         return;\n     }\n     long long tm = (tl + tr) / 2;\n     build(v * 2, tl, tm);\n     build(v * 2 + 1, tm + 1, tr);\n     if (t[v * 2][0] == t[v * 2 + 1][0]) {\n         t[v][2] = t[v * 2][2] + t[v * 2 + 1][2];\n         t[v][0] = t[v * 2][0];\n         return;\n     }\n     if (t[v * 2][0] < t[v * 2 + 1][0]) {\n         t[v][2] = t[v * 2][2];\n         t[v][0] = t[v * 2][0];\n         return;\n     }\n     t[v][2] = t[v * 2 + 1][2];\n     t[v][0] = t[v * 2 + 1][0];\n }\n \n pair<long long, long long> get(long long v, long long tl, long long tr, long long l, long long r) {\n     if (l > r) {\n         return {1e18, 0};\n     }\n     if (l == tl && r == tr) {\n         if (l != r) {\n             t[v * 2][0] += t[v][1];\n             t[v * 2][1] += t[v][1];\n             t[v * 2 + 1][0] += t[v][1];\n             t[v * 2 + 1][1] += t[v][1];\n             t[v][1] = 0;\n         } else {\n             t[v][1] = 0;\n         }\n         return {t[v][0], t[v][2]};\n     }\n     t[v * 2][0] += t[v][1];\n     t[v * 2][1] += t[v][1];\n     t[v * 2 + 1][0] += t[v][1];\n     t[v * 2 + 1][1] += t[v][1];\n     t[v][1] = 0;\n     long long tm = (tl + tr) / 2;\n     pair<long long, long long> gt1 = get(v * 2, tl, tm, l, min(r, tm));\n     pair<long long, long long> gt2 = get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n     if (gt1.first == gt2.first) {\n         return {gt1.first, gt1.second + gt2.second};\n     }\n     if (gt1.first < gt2.first) {\n         return gt1;\n     }\n     return gt2;\n }\n \n void upd(long long v, long long tl, long long tr, long long l, long long r, long long x) {\n     if (l > r) {\n         return;\n     }\n     if (l == tl && r == tr) {\n         if (l != r) {\n             t[v * 2][0] += t[v][1];\n             t[v * 2][1] += t[v][1];\n             t[v * 2 + 1][0] += t[v][1];\n             t[v * 2 + 1][1] += t[v][1];\n             t[v][1] = 0;\n         } else {\n             t[v][1] = 0;\n         }\n         t[v][0] += x;\n         t[v][1] += x;\n         return;\n     }\n     t[v * 2][0] += t[v][1];\n     t[v * 2][1] += t[v][1];\n     t[v * 2 + 1][0] += t[v][1];\n     t[v * 2 + 1][1] += t[v][1];\n     t[v][1] = 0;\n     long long tm = (tl + tr) / 2;\n     upd(v * 2, tl, tm, l, min(r, tm), x);\n     upd(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, x);\n     if (t[v * 2][0] == t[v * 2 + 1][0]) {\n         t[v][2] = t[v * 2][2] + t[v * 2 + 1][2];\n         t[v][0] = t[v * 2][0];\n         return;\n     }\n     if (t[v * 2][0] < t[v * 2 + 1][0]) {\n         t[v][2] = t[v * 2][2];\n         t[v][0] = t[v * 2][0];\n         return;\n     }\n     t[v][2] = t[v * 2 + 1][2];\n     t[v][0] = t[v * 2 + 1][0];\n }\n \n struct point {\n     long long x, y, idx, type;\n \n     point() {\n         x = y = idx = type = 0;\n     }\n \n     point(long long x, long long y, long long idx, long long type) {\n         this->x = x;\n         this->y = y;\n         this->idx = idx;\n         this->type = type;\n     }\n };\n \n struct rect {\n     long long x1, y1, x2, y2;\n \n     rect() {\n         x1 = y1 = x2 = y2 = 0;\n     }\n \n     rect(point s, point e) {\n         this->x1 = s.x;\n         this->y1 = s.y;\n         this->x2 = e.x;\n         this->y2 = e.y;\n     }\n \n     rect(long long x1, long long y1, long long x2, long long y2) {\n         this->x1 = x1;\n         this->y1 = y1;\n         this->x2 = x2;\n         this->y2 = y2;\n     }\n };\n \n istream &operator>>(istream &is, point &p) {\n     is >> p.x >> p.y;\n     return is;\n }\n \n istream &operator>>(istream &is, rect &p) {\n     point s, e;\n     is >> s >> e;\n     p = {s, e};\n     return is;\n }\n \n point events[300000];\n rect arr[200000];\n set<long long> sy;\n long long mx = -1e9;\n long long mn = 1e9;\n \n signed main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n     long long n;\n     cin >> n;\n     for (int i = 0; i < n; ++i) {\n         long long x1, x2, y1, y2;\n         cin >> x1 >> y1 >> x2 >> y2;\n         arr[i] = {x1, y1, x2, y2};\n         sy.insert(y1);\n         sy.insert(y2);\n     }\n     {\n         long long j = 0;\n         for (const long long &i : sy) {\n             mx = max(mx, i);\n             mn = min(mn, i);\n             ky_[i] = j;\n             ky[j] = i;\n             ++j;\n         }\n     }\n     long long n_ = (long long) sy.size();\n     if (n_) {\n         ky[n_] = ky[n_ - 1];\n         build(1, 0, n_ - 1);\n     }\n     for (long long i = 0; i < n; ++i) {\n         events[i * 2] = {arr[i].x1, ky_[arr[i].y1], i, 0};\n         events[i * 2 + 1] = {arr[i].x2, ky_[arr[i].y2], i, 1};\n     }\n     sort(events, events + 2 * n, [](point a, point b) {\n         if (a.x == b.x) {\n             return a.type < b.type;\n         }\n         return a.x < b.x;\n     });\n     long long ans = 0;\n     for (long long i = 0; i < 2 * n; ++i) {\n         if (!events[i].type) {\n             upd(1, 0, n_ - 1, ky_[arr[events[i].idx].y1], ky_[arr[events[i].idx].y2] - 1, 1);\n         } else {\n             upd(1, 0, n_ - 1, ky_[arr[events[i].idx].y1], ky_[arr[events[i].idx].y2] - 1, -1);\n         }\n         auto gt = get(1, 0, n_ - 1, 0, n_ - 1);\n         if (gt.first == 0) {\n             if (i != n * 2 - 1) {\n                 ans += (mx - mn - gt.second) * (events[i + 1].x - events[i].x);\n             }\n         }\n     }\n     cout << ans;\n     return 0;\n }\n \n "~0
"#include <bits/stdc++.h>\n using namespace std;\n struct segtr {\n     vector<pair<int, int>> tree;\n \n     int size;\n \n     void init(int n) {\n         size = 1;\n         while (size < n) size *= 2;\n         tree.assign(2 * size - 1, {-1e9, -1e9});\n     }\n \n     void set(int nom, int i, int v, int x, int lx, int rx) {\n         if (lx == rx - 1) {\n             tree[x] = {v, nom};\n             return;\n         }\n         int mid = (lx + rx) / 2;\n         if (i < mid)\n             set(nom, i, v, 2 * x + 1, lx, mid);\n         else\n             set(nom, i, v, 2 * x + 2, mid, rx);\n         tree[x] = max(tree[2 * x + 1], tree[2 * x + 2]);\n     }\n \n     void set(int i, int v, int nom) {\n         set(nom, i, v, 0, 0, size);\n     }\n \n     pair<int, int> sum(int l, int r, int x, int lx, int rx) {\n         if (l >= rx || lx >= r) {\n             return {-1e9, -1e9};\n         }\n         if (lx >= l && rx <= r) {\n             return tree[x];\n         }\n         int mid = (lx + rx) / 2;\n         return max(sum(l, r, 2 * x + 1, lx, mid), sum(l, r, 2 * x + 2, mid, rx));\n     }\n \n     pair<int, int> sum(int l, int r) {\n         return sum(l, r, 0, 0, size);\n     }\n };\n int main() {\n     ios::sync_with_stdio(false);\n     cin.tie(0);\n     cout.tie(0);\n     int n;\n     cin >> n;\n     vector<int> a;\n     for (int i = 0; i < n; i++) {\n         int cc;\n         cin >> cc;\n         a.push_back(cc);\n     }\n     map<int, int> mapa;\n     int nom = 0;\n     vector<int> srta = a;\n     sort(srta.begin(), srta.end());\n     for (int i = 0; i < n; i++) {\n         if (i == 0 || srta[i] != srta[i - 1]) {\n             nom++;\n             mapa[srta[i]] = nom;\n         } else {\n             mapa[srta[i]] = nom;\n         }\n     }\n     for (auto &x : a) {\n         x = mapa[x];\n     }\n     segtr st;\n     st.init(1000000);\n     vector<int> dp(n + 1), p(n + 1, -1);\n     dp[0] = 1;\n     st.set(a[0], 1, 0);\n     for (int i = 1; i < n; i++) {\n         auto cur = st.sum(a[i], 1000000);\n         if (cur.first == -1e9) {\n             dp[i] = 1;\n             st.set(a[i], 1, i);\n         } else {\n             dp[i] = cur.first + 1;\n             st.set(a[i], dp[i], i);\n             p[i] = cur.second;\n         }\n     }\n     int nomm = 0;\n     for (int i = 0; i < n; i++) {\n         if (dp[i] > dp[nomm]) nomm = i;\n     }\n     vector<int> ans;\n     while (nomm != -1) {\n         ans.push_back((nomm + 1));\n         nomm = p[nomm];\n     }\n     cout << ans.size() << '\n ';\n     reverse(ans.begin(), ans.end());\n     for (auto x : ans) cout << x << ' ';\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n int main() {\n     long long x, y, l, r;\n     cin >> x >> y >> l >> r;\n     set<long long> s;\n     for (long long i = 1; i; i *= i > r / x ? 0 : x) {\n         for (long long j = 1; j; j *= j > r / y ? 0 : y) {\n             s.insert(i + j);\n         }\n     }\n     y = l - 1;\n     long long a = 0;\n     for (auto e : s) {\n         if (l <= e && e <= r) {\n             a = max(a, e - y - 1);\n             y = e;\n         }\n     }\n     cout << max(a, r - y);\n }\n "~0
"#include <bits/stdc++.h>\n using namespace std;\n \n int main() {\n     int n;\n     cin >> n;\n     map<long long, long long> mapa;\n     vector<int> a;\n     for (int i = 0; i < n; i++) {\n         int cc;\n         cin >> cc;\n         a.push_back(cc);\n         mapa[cc]++;\n     }\n     long long ans = 0;\n     for (long long i = 1; i <= 2000000000; i *= 2) {\n         if (i > *max_element(a.begin(), a.end()) * 2) {\n             break;\n         }\n         for (auto x : mapa) {\n             if (i - x.first <= 0) {\n                 continue;\n             }\n             if (i - x.first != x.first && i - x.first > x.first && mapa.count(i - x.first)) {\n                 ans += mapa[x.first] * mapa[i - x.first];\n             } else if (i - x.first == x.first) {\n                 ans += mapa[x.first] * (mapa[x.first] - 1) / 2;\n             }\n         }\n     }\n     cout << ans;\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n int main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int n;\n 	cin >> n;\n 	vector <int> s(n), dp(n);\n 	for (int i = 0; i < n; i++) {\n 		cin >> s[i];\n 	}\n 	for (int i = 1; i < n; i++) {\n 		if (i == 1) {\n 			dp[i] = abs(s[i] - s[i - 1]);\n 			continue;\n 		}\n 		dp[i] = min(3 * abs(s[i] - s[i - 2]) + dp[i - 2], abs(s[i] - s[i - 1]) + dp[i - 1]);\n 	}\n 	cout << dp[n - 1] << "\n ";\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n struct vrm {\n     int a, b, c;\n };\n \n signed main() {\n     int n;\n     cin >> n;\n     vector <vrm> s;\n     for (int i = 0; i < n; i++) {\n         int x, y, z;\n         cin >> x >> y >> z;\n         s.push_back({x, y, z});\n     }\n     vector <int> dp(n + 1);\n     dp[0] = 0;\n     dp[1] = s[0].a;\n     if (n >= 2) {\n         dp[2] = min(s[0].a + s[1].a, s[0].b);\n         for (int i = 3; i <= n; i++) {\n             dp[i] = min(dp[i - 1] + s[i - 1].a, min(dp[i - 2] + s[i - 2].b, dp[i - 3] + s[i - 3].c));\n         }\n     }\n     cout << dp.back() << "\n ";\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n using namespace std;\n  \n bool ok(vector<int> a, int k, int s) {\n     int prev = 0;\n     for (int i = 0; i < k - 1; i++) {\n         int cur = lower_bound(a.begin(), a.end(), a[prev] + s) - a.begin();\n         prev = cur;\n         if (cur == a.size()) {\n             return false;\n         }\n     }\n     return true;\n }\n  \n int cow(vector<int> a, int k) {\n     int l = 0;\n     int r = a[a.size() - 1] - a[0] + 1;\n     while (r - l > 1) {\n         int c = (l + r) / 2;\n         if (ok(a, k, c)) {\n             l = c;\n         } else {\n             r = c;\n         }\n     }\n     return l;\n }\n  \n int main() {\n     int n, k;\n     cin >> n >> k;\n     vector<int> a(n);\n     for (int i = 0; i < n; i++) {\n         cin >> a[i];\n     }\n     cout << cow(a, k) << endl;\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n signed main() {\n 	int a, b, c;\n 	cin >> a >> b >> c;\n 	int l = 0, r = (a - 1) * max(b, c);\n 	while (r > l + 1) {\n 		int m = (l + r) / 2;\n 		if (m / b + m / c < a - 1) {\n 			l = m;\n 		} else {\n 			r = m;\n 		}\n 	}\n 	cout << r + min(b, c) << "\n ";\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n vector <int> p;\n \n int leader(int v) {\n     if (p[v] == v)\n         return v;\n     else\n         return leader(p[v]);\n }\n \n int leaderv(int v, int k = 0) {\n 	if (p[v] == v) {\n 		return k;\n 	} else {\n 		return leaderv(p[v], k + 1);\n 	}\n }\n \n void unite(int a, int b) {\n     a = leader(a);\n     p[a] = b;\n }\n \n signed main() {\n 	int n;\n 	cin >> n;\n 	p = vector <int> (n);\n 	for (int i = 0; i < n; i++) p[i] = i;\n 	map <int, string> m1;\n 	map <string, int> m2;\n 	vector <pair <string, string>> s;\n 	set <string> h1, h2;\n 	for (int i = 0; i < n - 1; i++) {\n 		string a, b;\n 		cin >> a >> b;\n 		s.push_back({a, b});\n 		h1.insert(a);\n 		h2.insert(b);\n 		m2[a] = i;\n 		m1[i] = a;\n 	}\n 	set <string> anss;\n 	set_difference(h2.begin(), h2.end(), h1.begin(), h1.end(), inserter(anss, anss.end()));\n        	string st;\n 	for (auto i: anss) st = i;\n 	m1[n - 1] = st;\n 	m2[st] = n - 1;\n 	for (int i = 0; i < n - 1; i++) {\n 		string a, b;\n 		a = s[i].first;\n 		b = s[i].second;\n 		unite(m2[a], m2[b]);\n 	}\n 	// cout << "Корень дерева: " << st << "\n ";\n 	vector <pair <string, int>> ans;\n 	for (int i = 0; i < p.size(); i++) {\n 		if (p[i] == i) {\n 			ans.push_back({m1[i], 0});\n 		} else {\n 			ans.push_back({m1[i], leaderv(p[i]) + 1});\n 		}\n 	}\n 	sort(ans.begin(), ans.end());\n 	for (auto i: ans) cout << i.first << " " << i.second << "\n ";\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n #define int long long\n \n bool komp(pair <string, int> a, pair <string, int> b) {\n 	if (a.second == b.second) {\n 		return a.first < b.first;\n 	} \n 	return a.second > b.second;\n }\n \n void solve() {\n 	int n;\n 	cin >> n;\n 	map <string, int> m;\n 	for (int i = 0; i < n; i++) {\n 		string a;\n 		int x;\n 		cin >> a >> x;\n 		m[a] = x;\n 	}\n 	int r;\n 	cin >> r;\n 	map <string, map <string, int>> k;\n 	map <string, int> h;\n 	for (int i = 0; i < r; i++) {\n 		string a, b;\n 		cin >> a >> b;\n 		k[a][b]++;\n 		h[b] = 0;\n 	}\n 	for (auto i: k) {\n 		int x = INT_MIN;\n 		string s;\n 		for (auto j: i.second) {\n 			if (j.second > x) {\n 				x = j.second;\n 				s = j.first;\n 			}\n 		}\n 		h[s] += m[i.first];\n 	}\n 	vector <pair <string, int>> q;\n 	for (auto i: h) {\n 		q.push_back({i.first, i.second});\n 	}\n 	sort(q.begin(), q.end(), komp);\n 	for (auto i: q) {\n 		cout << i.first << " " << i.second << "\n ";\n 	}\n 	return ;\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	// cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n int32_t main() {\n   int n;\n   cin >> n;\n   vector <int> a(15485865);\n   for (int i = 0; i < 15485865; i++)\n     a[i] = i;\n   for (int p = 2; p < 15485865; p++)\n   {\n     if (a[p] != 0)\n     {\n       for (int j = p * p; j < 15485865; j += p)\n         a[j] = 0;\n     }\n   }\n   int x = 0;\n   while (n) {\n   	if (a[x] > 1) {\n 		n--;\n 	}\n 	x++;\n   }\n   cout << a[x - 1] << "\n ";\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n int gcd(int a, int b) {\n 	if (a < b) {\n 		swap(a, b);\n 	}\n 	while (b != 0) {\n 		a = a % b;\n 		swap(a, b);\n 	}\n 	return a;\n }\n \n int rs_gcd(int a, int b, int &x, int &y) {\n 	if (a == 0) {\n 		x = 0, y = 1;\n 		return b;\n 	}\n 	int x1, y1;\n 	int ans = rs_gcd(b % a, a, x1, y1);\n 	x = y1 - (b / a) * x1;\n 	y = x1;\n 	return ans;\n }\n \n int euler(int n) {\n 	int ans = n;\n 	int tek = 2;\n 	while (tek * tek <= n) {\n 		if (n % tek == 0) {\n 			while (n % tek == 0) {\n 				n /= tek;\n 			}\n 			ans -= ans / tek;\n 		}\n 		tek++;\n 	}\n 	if (n > 1) {\n 		ans -= ans / n;\n 	}\n 	return ans;\n }\n \n string sol(int a, int b, int c, int &x, int &y, int &u) {\n 	u = rs_gcd(a, b, x, y);\n 	if (c % u != 0) {\n 		return "Impossible";\n 	}\n 	x *= c / u;\n 	y *= c / u;\n 	return "Has solution";\n }\n \n signed main() {\n 	/*\n 	int n;\n 	cin >> n;\n 	int sm = 0;\n 	for (int i = 1; i <= n; i++) {\n 		int x = euler(i);\n 		sm += x;\n 		if (i % 100 == 0) {\n 			cout << sm << " ";\n 			sm = 0;\n 		}\n 		if (n % 100 != 0 && i == n) {\n 			cout << sm << "\n ";\n 			return 0;\n 		}\n 	}\n 	cout << "\n ";\n 	*/\n 	int a, b, c, x, y, t;\n 	cin >> a >> b >> c;\n 	string ans = sol(a, b, c, x, y, t);\n 	if (ans == "Impossible") {\n 		cout << -1 << "\n ";\n 		return 0;\n 	}\n 	int g = gcd(a, b);\n 	// cout << x << " " << y << "\n ";\n 	while (x >= 0) {\n 		if (x - b / g < 0) {\n 			break;\n 		}\n 		x -= b / g;\n 		y += a / g;\n 	}\n 	// cout << x << " " << y << "\n ";\n 	while (x < 0) {\n 		x += b / g;\n 		y -= a / g;\n 	}\n 	cout << x << " " << y << "\n ";\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std; \n \n signed main() { \n 	int a, b, c, d, x, y, x1, y1, dd, k, xq, yq; \n   	cin >> a >> b >> c >> d; \n 	x = abs(a - c); \n 	y = abs(b - d); \n 	xq = x; \n 	yq = y; \n   	while (x != 0 and y != 0) {\n 		if (x > y) {\n 			x = x % y;\n 		} else {\n 			y = y % x;\n 		}\n 	} \n     	dd = x + y; \n   	cout << xq + yq - dd; \n }\n "~0
"#include <iostream>\n \n using namespace std;\n \n long long gcd(long long a, long long b) {\n     while (a != 0 && b != 0) {\n         if (b > a) {\n             b %= a;\n         } else {\n             a %= b;\n         }\n     }\n     return a + b;\n }\n \n int main() {\n     long long s1, s2;\n     cin >> s1 >> s2;\n     bool f = false;\n     if (s1 < 0) {\n         f = true;\n     }\n     s1 = abs(s1);\n     long long p = gcd(s1, s2);\n     if (f) {\n         cout << -s1 / p << " " << s2 / p << endl;\n     } else {\n         cout << s1 / p << " " << s2 / p << endl;\n     }\n     return 0;\n }\n "~0
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n int main()\n {\n     int n;\n     cin >> n;\n     vector <vector<int>> dp(n + 1, vector<int> (n + 1, 0));\n     dp[0][0] = 1;\n     for (int i = 1; i < n + 1; i++) {\n         for (int j = 1; j < n + 1; j++) {\n             if (i - j >= 0) {\n                 int s = 0;\n                 for (int k = 0; k < j; k++) {\n                     s += dp[i - j][k];\n                 }\n                 dp[i][j] = s;\n             }\n         }\n     }\n     int s = 0;\n     for (int k = 0; k < n + 1; k++) {\n         s += dp[n][k];\n     }\n     cout << s;\n }\n "~0
"#include <iostream>\n using namespace std;\n \n void f(int n, int a, int b, int c) {\n     if (n == 1) {\n         cout << n << " " << a << " " << b << endl;\n         return;\n     }\n     f(n - 1, a, c, b);\n     cout << n << " " << a << " " << b << endl;\n     f(n - 1, c, b, a);\n }\n \n int main() {\n     int n;\n     cin >> n;\n     f(n, 1, 3, 2);\n     return 0;\n }\n "~0
"#include <iostream>\n #include <string>\n #include <vector>\n #include <cctype>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s);\n \n     vector<int> a(26, 0);\n \n     for (char i : s) {\n         if (isalpha(i)) { \n             char c = toupper(i);\n             a[c - 'A']++;\n         }\n     }\n \n     int mx = 0;\n     for (int i : a) {\n         if (i > mx) {\n             mx = i;\n         }\n     }\n \n \n     for (int i = 0; i < 26; ++i) {\n         if (a[i] == mx) {\n             cout << char('A' + i);\n         }\n     }\n     cout << endl;\n \n     cout << mx << endl;\n \n     return 0;\n }\n "~0
"#include <iostream>\n #include <string>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s);\n \n     int c = 0;\n     bool flag = false;\n \n     for (char i : s) {\n         if (i != ' ') {\n             if (!flag) {\n                 c++;\n                 flag = true;\n             }\n         }\n         else {\n             flag = false;\n         }\n     }\n \n     cout << c << endl; \n     return 0;\n }\n "~0
"#include <iostream>\n #include <string>\n #include <vector>\n #include <algorithm>\n #include <climits>\n #include <set>\n \n using namespace std;\n \n set <string> zebra(set <string> a, set <string> b) {\n     set <string> c;\n     for (auto i : a) {\n         if (b.count(i) != 0)\n             c.insert(i);\n     }\n     return c;\n }\n \n int min(int a, int b) {\n     if (a > b) {\n         return a;\n     }\n     else {\n         return b;\n     }\n }\n \n int main() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     long long n, m;\n     cin >> n >> m;\n     vector <vector<int>> dp(n, vector<int>(m, 0));\n     vector <vector<int>> a(n, vector<int>(m));\n     for (int i = 0; i < n; i++) {\n         for (int j = 0; j < m; j++) {\n             cin >> a[i][j];\n         }\n     }\n     dp[0][0] = a[0][0];\n     for (int i = 0; i < n; i++) {\n         for (int j = 0; j < m; j++) {\n             if (i == 0 and j != 0) {\n                 dp[0][j] = dp[0][j - 1] + a[0][j];\n             }\n             else if (j == 0 and i != 0) {\n                 dp[i][0] = dp[i - 1][0] + a[i][0];\n             }\n             else if (j != 0 and i != 0) {\n                 dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + a[i][j];\n             }\n         }\n     }\n     int i = n - 1, j = m - 1;\n     vector <char> res;\n     while (!(i == 0 and j == 0)) {\n         if (i == 0) {\n             res.push_back('R');\n             j--;\n         }\n         else if (j == 0) {\n             res.push_back('D');\n             i--;\n         }\n         else if (dp[i - 1][j] > dp[i][j - 1]) {\n             res.push_back('D');\n             i--;\n         }\n         else {\n             res.push_back('R');\n             j--;\n         }\n     }\n     reverse(res.begin(), res.end());\n     cout << dp[n - 1][m - 1] << endl;\n     for (auto i : res) {\n         cout << i << " ";\n     }\n }\n "~0
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n int main() {\n     int n, m;\n     cin >> n >> m;\n \n     vector<vector<int>> dp(n, vector<int>(m, 0));\n \n     for (int i = 0; i < n; ++i) {\n         dp[i][0] = 1; \n     }\n     for (int j = 0; j < m; ++j) {\n         dp[0][j] = 1; \n     }\n \n     for (int i = 1; i < n; ++i) {\n         for (int j = 1; j < m; ++j) {\n             dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n         }\n     }\n \n     cout << dp[n - 1][m - 1] << endl;\n \n     return 0;\n }\n "~0
"#include <iostream>\n #include <vector>\n #include <cmath>\n #include <climits>\n using namespace std;\n int main() {\n     long long a, b, c, d;\n     cin >> a >> b >> c >> d;\n     a -= c;\n     b -= c;\n     for (int i = (a + d - 1) / d * d + c ; i <= b + c; i += d) {\n         cout << i << " ";\n     }\n }\n "~0
"#include <iostream>\n #include <vector>\n #include <cmath>\n #include <climits>\n using namespace std;\n int main() {\n     int a, b;\n     cin >> a >> b;\n     for (int i = a + (a % 2 != 0); i <= b; i += 2) {\n         cout << i << " ";\n     }\n }\n "~0
"#include <iostream>\n using namespace std;\n \n int main() {\n     int a, b, n;\n     cin >> a >> b;\n     cout << (a * b + 1 ) / 2;\n }\n "~0
"#include <iostream>\n using namespace std;\n \n int main() {\n     int a, b, n;\n     cin >> a >> b;\n     cout << (b - 1) / a + 1 << " " << (b - 1) % a + 1;\n }\n "~0
"#include <iostream>\n #include <string>\n #include <cctype>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s);\n \n     bool start = true; \n \n     for (size_t i = 0; i < s.length(); ++i) {\n         if (isalpha(s[i])) {\n             if (start) {\n                 s[i] = toupper(s[i]);\n                 start = false;\n             }\n             else {\n                 s[i] = tolower(s[i]); \n             }\n         }\n         else {\n             start = true;\n         }\n     }\n \n     cout << s << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <string>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s);\n \n     string res;\n     bool space = false; \n \n     int start = s.find_first_not_of(' ');\n     if (start == string::npos) {\n         cout << "" << endl;\n         return 0;\n     }\n \n     int end = s.find_last_not_of(' ');\n     s = s.substr(start, end - start + 1);\n \n     for (char i : s) {\n         if (i != ' ') {\n             res += i;\n             space = false;\n         }\n         else if (!space) {\n             res += ' '; \n             space = true;\n         }\n     }\n \n     cout << res << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <string>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s); // Считываем строку целиком\n \n     int pos = 0;\n     while ((pos = s.find('1', pos)) != string::npos) {\n         s.replace(pos, 1, "one");\n         pos += 3; \n     }\n \n     cout << s << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <algorithm>\n \n using namespace std;\n \n int main() {\n     int A, B, C, D, E;\n     cin >> A >> B >> C >> D >> E;\n \n     int brick1 = min(A, min(B, C));\n     int brick2 = max(min(A, B), min(max(A, B), C));\n     int brick3 = max(A, max(B, C));\n \n     int hole1 = min(D, E);\n     int hole2 = max(D, E);\n \n     if ((min(A, min(B, C)) <= min(D, E) && max(min(A, B), min(max(A, B), C)) <= max(D, E)) || (min(A, min(B, C)) <= max(D, E) && max(min(A, B), min(max(A, B), C)) <= min(D, E))) {\n         cout << "YES" << endl;\n     }\n     else {\n         cout << "NO" << endl;\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <cmath>\n #include <cstdlib>\n \n int main() {\n     double c;\n     std::cin >> c;\n     double xo = sqrt(c);\n     double eps = 1e-5;\n     double x = sqrt(c - xo);\n     \n     while (fabs(x - xo) > eps) {\n         xo = x;\n         x = sqrt(c - sqrt(xo));\n     }\n     \n     std::cout << x << std::endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <cmath>\n \n int main() {\n     int n;\n     std::cin >> n;\n     std::vector<int> h(n);\n     for (int i = 0; i < n; ++i) {\n         std::cin >> h[i];\n     }\n     int m;\n     std::cin >> m;\n     int l = 0;\n     int r = *std::max_element(h.begin(), h.end());\n \n     while (r - l > 1) {\n         int x = (r + l) / 2;\n         int sum = 0;\n         for (int a : h) {\n             sum += std::ceil(static_cast<double>(a) / x);\n         }\n         if (sum <= m) {\n             r = x;\n         } else {\n             l = x;\n         }\n     }\n     if (m < n) {\n         std::cout << -1 << std::endl;\n     } else {\n         std::cout << r << std::endl;\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_map>\n #include <string>\n #include <sstream>\n \n int main() {\n     int n, m;\n     std::cin >> n >> m;\n     std::unordered_map<std::string, int> w;\n     for (int i = 0; i < m; ++i) {\n         std::string s1, s2;\n         std::cin >> s1 >> s2;\n         w[s2] = std::stoi(s1);\n     }\n     std::vector<int> res(n, 0);\n     for (const auto& pair : w) {\n         res[pair.second - 1] += 1;\n     }\n     for (int i = 0; i < n; ++i) {\n         std::cout << res[i];\n         if (i < n - 1) {\n             std::cout << " ";\n         }\n     }\n     std::cout << std::endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <tuple>\n \n std::tuple<int, int, int> gcdExtended(int a, int b) {\n     if (a == 0) {\n         return std::make_tuple(b, 0, 1);\n     }\n     int gcd, x1, y1;\n     std::tie(gcd, x1, y1) = gcdExtended(b % a, a);\n     int x = y1 - (b / a) * x1;\n     int y = x1;\n     return std::make_tuple(gcd, x, y);\n }\n \n int main() {\n     int m, a;\n     std::cin >> m >> a;\n     int gcd, x, y;\n     std::tie(gcd, x, y) = gcdExtended(a, m);\n     if (gcd == 1) {\n         std::cout << (x % m + m) % m << std::endl;\n     } else {\n         std::cout << -1 << std::endl;\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <cmath>\n #include <string>\n #include <sstream>\n \n void solve(int n) {\n     int d = 0;\n     while (!(n & 1)) {\n         d++;\n         n /= 2;\n     }\n \n     std::vector<int> a(d, 2);\n     a.back() *= n;\n \n     if (d == 1) {\n         std::cout << "prime" << std::endl;\n         return;\n     }\n \n     for (int x = 3; x <= static_cast<int>(std::sqrt(n)); x += 2) {\n         if (n % x == 0) {\n             std::vector<int> b = a;\n             b.back() /= x;\n             b[d - 2] *= x;\n             std::cout << "many" << std::endl;\n             for (int i : a) {\n                 std::cout << i << " ";\n             }\n             std::cout << std::endl;\n             for (int i : b) {\n                 std::cout << i << " ";\n             }\n             std::cout << std::endl;\n             return;\n         }\n     }\n \n     std::cout << "single" << std::endl;\n     for (int i : a) {\n         std::cout << i << " ";\n     }\n     std::cout << std::endl;\n }\n \n int main() {\n     std::string line;\n     while (std::getline(std::cin, line)) {\n         std::istringstream iss(line);\n         int n;\n         if (iss >> n) {\n             solve(n);\n         }\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <numeric>\n \n int gcd(int a, int b) {\n     return b == 0 ? a : gcd(b, a % b);\n }\n \n int main() {\n     int n;\n     std::cin >> n;\n     std::vector<int> a(n);\n     \n     for (int i = 0; i < n; ++i) {\n         std::cin >> a[i];\n     }\n     \n     int mx = 0;\n     \n     for (int i = 0; i < n; ++i) {\n         int cur_g = a[i];\n         int p = 0;\n         \n         if (n - i < mx) {\n             break;\n         }\n         \n         for (int j = i; j < n; ++j) {\n             p++;\n             cur_g = gcd(cur_g, a[j]);\n             if (cur_g == 1) {\n                 break;\n             }\n             a[j] /= cur_g;\n             if (mx < p) {\n                 mx = p;\n             }\n         }\n     }\n     \n     std::cout << mx << std::endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <set>\n #include <cmath>\n using namespace std;\n \n vector<int> decomp(int n) { // функция разложения числа на простые множители\n     vector<int> ans;\n     int d = 2;\n     while (d * d <= n) {\n         if (n % d == 0) {\n             ans.push_back(d);\n             n /= d;\n         } else {\n             d += 1;\n         }\n     }\n     if (n > 1) {\n         ans.push_back(n);\n     }\n     return ans;\n }\n \n // Function to calculate (base^exp) % mod efficiently\n long long modPow(long long base, long long exp, long long mod) {\n     if (mod == 1) return 0;\n     long long result = 1;\n     base = base % mod;\n     while (exp > 0) {\n         if (exp % 2 == 1) {\n             result = (result * base) % mod;\n         }\n         exp = exp >> 1;\n         base = (base * base) % mod;\n     }\n     return result;\n }\n \n int main() {\n     int x;\n     cin >> x;\n     \n     vector<int> b = decomp(x); // разложение числа x на простые множители\n     set<int> temp_set(b.begin(), b.end());\n     vector<int> a(temp_set.begin(), temp_set.end()); // разложение числа x на простые множители в единственном экземпляре\n     \n     long long y = 1;\n     for (int i = 0; i < a.size(); i++) { // перемножение простых множителей\n         y *= a[i];\n     }\n     int k = 1;\n     long long n = k * y;\n     \n     if (x == 1) { // если x = 1, то и n = 1\n         cout << 1 << endl;\n     } else if (b.size() >= 30) { // 29 - потому что хотя бы 2**30 уже будет более 10**9, что противоречит условию задачи\n         cout << y << endl; // тогда y**y уже будет делится на n\n     } else {\n         while (modPow(n, n, x) != 0) {\n             n = k * y;\n             k += 1;\n         }\n         cout << n << endl;\n     }\n     \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n const size_t sz = 5e4;\n int dep[sz], up[sz];\n bool used[sz];\n \n vector<pair<int, int>> g[sz];\n bool points[sz];\n \n void dfs(int v, int depth, int edge_id)\n {\n     used[v] = true;\n     dep[v] = depth;\n     up[v] = depth;\n     bool isPoint = false;\n     int child = 0;\n     for (auto [u, idx] : g[v])\n     {\n         if (idx == edge_id)\n             continue;\n         if (!used[u])\n         {\n             child++;\n             dfs(u, depth + 1, idx);\n             up[v] = min(up[u], up[v]);\n             if (up[u] >= dep[v])\n                 isPoint = true;\n         }\n         else\n             up[v] = min(dep[u], up[v]);\n     }\n     if (isPoint && child && depth != 0)\n         points[v] = true;\n     if (depth == 0 && child > 1)\n         points[v] = true;\n }\n \n void solve()\n {\n     int n, m;\n     cin >> n >> m;\n     for (int i = 0; i < min(int(5e5), 3 * n); i++)\n         used[i] = false, points[i] = false;\n     for (int i = 0; i < m; i++)\n     {\n         int s, f;\n         cin >> s >> f;\n         g[s].push_back({f, i});\n         g[f].push_back({s, i});\n     }\n     for (int i = 1; i <= n; i++)\n         if (!used[i])\n             dfs(i, 0, -1);\n     vector<int> ans;\n     for (int i = 1; i <= n; i++)\n         if (points[i])\n             ans.push_back(i);\n     cout << ans.size() << "\n ";\n     for (int v : ans)\n         cout << v << " ";\n     cout << "\n ";\n }\n \n int main()\n {\n     ios::sync_with_stdio(false);\n     cin.tie(NULL);\n \n     solve();\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n const size_t sz = 2e4 + 1;\n int dep[sz], up[sz];\n bool used[sz];\n \n vector<pair<int, int>> g[sz];\n vector<int> points;\n \n void dfs(int v, int depth, int edge_id)\n {\n     used[v] = true;\n     dep[v] = depth;\n     up[v] = depth;\n     for (auto [u, idx] : g[v])\n     {\n         if (idx == edge_id)\n             continue;\n         if (!used[u])\n         {\n             dfs(u, depth + 1, idx);\n             up[v] = min(up[u], up[v]);\n             if (up[u] > dep[v])\n                 points.push_back(idx);\n         }\n         else\n             up[v] = min(dep[u], up[v]);\n     }\n }\n \n void solve()\n {\n     int n, m;\n     cin >> n >> m;\n     for (int i = 0; i < n; i++)\n         used[i] = false;\n     for (int i = 0; i < m; i++)\n     {\n         int s, f;\n         cin >> s >> f;\n         g[s].push_back({f, i});\n         g[f].push_back({s, i});\n     }\n     for (int i = 0; i < n; i++)\n         if (!used[i])\n             dfs(i, 0, -1);\n     cout << points.size() << "\n ";\n     sort(points.begin(), points.end());\n     for (int e : points)\n         cout << e + 1 << "\n ";\n }\n \n int main()\n {\n     ios::sync_with_stdio(false);\n     cin.tie(NULL);\n \n     solve();\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <set>\n #include <map>\n #include <deque>\n #include <string>\n #include <string.h>\n #include <sstream>\n #include <algorithm>\n #include <queue>\n #include <stack>\n #include <cmath>\n #define ll long long\n  \n using namespace std;\n  \n int main() {\n  \n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n  \n     int a, b, c, d, e;\n     cin >> a >> b >> c >> d >> e;\n  \n     int count = 0;\n  \n     int comp = min(a, b);\n  \n     int d_used = min(comp, d);\n     int e_used = min(comp, e);\n     int overall = min(d_used, e_used);\n  \n     d -= overall;\n     e -= overall;\n  \n     count += overall;\n  \n  \n     d_used = min(c, d);\n     e_used = min(c, e);\n     overall = min(d_used, e_used);\n  \n     count += overall;\n  \n     cout << count;\n  \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <set>\n #include <map>\n #include <deque>\n #include <string>\n #include <string.h>\n #include <sstream>\n #include <algorithm>\n #include <queue>\n #include <stack>\n #include <cmath>\n #define ll long long\n  \n using namespace std;\n  \n int main() {\n  \n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n  \n     int n; cin >> n;\n  \n     //ll min;\n     queue<ll> a;\n     ll currmin = LLONG_MAX;\n  \n     for (int i = 0; i < n; i++) {\n         string c;\n         cin >> c;\n         if (c == "push") {\n             ll x; cin >> x;\n             a.push(x);\n             if (x < currmin) {\n                 currmin = x;\n             }\n         }\n         else if (c == "pop") {\n             if (!a.empty()) {\n                 int front = a.front();\n                 a.pop();\n                 if (front == currmin) {\n                     currmin = INT_MAX;\n                     queue<ll> temp = a;\n                     while (!temp.empty()) {\n                         int val = temp.front();\n                         temp.pop();\n                         if (val < currmin) {\n                             currmin = val;\n                         }\n                     }\n                 }\n             }\n         }\n         else if (c == "min?") {\n             cout << (a.empty() ? -1 : currmin) << '\n ';\n         }\n     }\n  \n     return 0;\n }\n "~1
"#include <iostream>\n #include <iomanip>\n #include <algorithm>\n #include <cstdlib>\n #include <cstdio>\n #include <cstring>\n #include <cctype>\n #include <cmath>\n #include <numeric>\n #include <vector>\n #include <string>\n #include <array>\n #include <functional>\n #include <ctime>\n #include <chrono>\n #include <random>\n #include <queue>\n #include <deque>\n #include <set>\n #include <map>\n #include <unordered_set>\n #include <unordered_map>\n #include <bitset>\n #include <cstdint>\n #include <list>\n #include <optional>\n  \n using namespace std;\n  \n #define int long long\n #ifndef ONLINE_JUDGE\n #else\n #define endl '\n '\n #endif\n using ll = long long;\n using ull = unsigned long long;\n using db = double;\n using i32 = int32_t;\n  \n #define all(x) (x).begin(), (x).end()\n #define rall(x) (x).rbegin(), (x).rend()\n #define rep(n) for (int rep_iter = 0; rep_iter < n; rep_iter++)\n #define cin(v) for (auto& el : v) cin >> el;\n  \n void fastW() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n     cout.precision(8);\n }\n  \n int gcd(int a, int b) {\n     if (!b) {\n             return a;\n     }\n     return gcd(b, a % b);\n }\n  \n int lcm(int a, int b) {\n     return a / gcd(a, b) * b;\n }\n  \n int get(int x) {\n     int res = 0;\n     while (x != 0) {\n         res += x % 10;\n         x /= 10;\n     }\n     return res;\n }\n  \n using i128 = __int128_t;\n  \n std::ostream& operator<<(std::ostream& dest, __int128_t value) {\n     std::ostream::sentry s(dest);\n     if (s) {\n         __uint128_t tmp = value < 0 ? -value : value;\n         char buffer[128];\n         char* d = std::end(buffer);\n         do {\n             --d;\n             *d = "0123456789"[tmp % 10];\n             tmp /= 10;\n         } while (tmp != 0);\n         if (value < 0) {\n             --d;\n             *d = '-';\n         }\n         int len = std::end(buffer) - d;\n         if (dest.rdbuf()->sputn(d, len) != len) {\n             dest.setstate(std::ios_base::badbit);\n         }\n     }\n     return dest;\n }\n  \n void solve() {\n     string st;\n     string end = "endprg";\n     map <string, vector <string>> mp;\n     string cur_f = "";\n     while (true) {\n         getline(cin, st);\n         if (st == end) break;\n  \n         string fir, sec;\n         string tmp;\n         for (auto el : st) {\n             if (el == ' ') {\n                 fir = tmp;\n                 tmp = "";\n             } else {\n                 tmp += el;\n             }\n         }\n         if (fir.size() == 0) {\n             fir = tmp;\n         } else {\n             sec = tmp;\n         }\n  \n         if (fir == "function") {\n             cur_f = sec;\n         }\n         else if (fir == "print" && cur_f != "") {\n             mp[cur_f].push_back(sec);\n         }\n         else if (fir == "print" && cur_f == "") {\n             cout << sec << endl;\n         }\n         else if (fir == "end") {\n             cur_f = "";\n         }\n         else if (fir == "call" && cur_f == "") {\n             for (auto el : mp[sec]) {\n                 cout << el << endl;\n             }\n         }\n         else if (fir == "call" && cur_f != "") {\n             for (auto el : mp[sec]) {\n                 mp[cur_f].push_back(el);\n             }\n         } else {\n             abort();\n         }\n     }\n }\n  \n  \n signed main() {\n     fastW();\n     solve();\n }\n "~1
"#include <iostream>\n #include <iomanip>\n #include <algorithm>\n #include <cstdlib>\n #include <cstdio>\n #include <cstring>\n #include <cctype>\n #include <cmath>\n #include <numeric>\n #include <vector>\n #include <string>\n #include <array>\n #include <functional>\n #include <ctime>\n #include <chrono>\n #include <random>\n #include <queue>\n #include <deque>\n #include <set>\n #include <map>\n #include <unordered_set>\n #include <unordered_map>\n #include <bitset>\n #include <cstdint>\n #include <list>\n #include <optional>\n \n using namespace std;\n \n #define int long long\n #ifndef ONLINE_JUDGE\n #else\n #define endl '\n '\n #endif\n using ll = long long;\n using ull = unsigned long long;\n using db = double;\n using i32 = int32_t;\n \n #define all(x) (x).begin(), (x).end()\n #define rall(x) (x).rbegin(), (x).rend()\n #define rep(n) for (int rep_iter = 0; rep_iter < n; rep_iter++)\n #define cin(v) for (auto& el : v) cin >> el;\n \n void fastW() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n     cout.precision(8);\n }\n \n int gcd(int a, int b) {\n     if (!b) {\n             return a;\n     }\n     return gcd(b, a % b);\n }\n \n int lcm(int a, int b) {\n     return a / gcd(a, b) * b;\n }\n \n int get(int x) {\n     int res = 0;\n     while (x != 0) {\n         res += x % 10;\n         x /= 10;\n     }\n     return res;\n }\n \n using i128 = __int128_t;\n \n std::ostream& operator<<(std::ostream& dest, __int128_t value) {\n     std::ostream::sentry s(dest);\n     if (s) {\n         __uint128_t tmp = value < 0 ? -value : value;\n         char buffer[128];\n         char* d = std::end(buffer);\n         do {\n             --d;\n             *d = "0123456789"[tmp % 10];\n             tmp /= 10;\n         } while (tmp != 0);\n         if (value < 0) {\n             --d;\n             *d = '-';\n         }\n         int len = std::end(buffer) - d;\n         if (dest.rdbuf()->sputn(d, len) != len) {\n             dest.setstate(std::ios_base::badbit);\n         }\n     }\n     return dest;\n }\n \n void solve() {\n     int n;\n     cin >> n;\n     vector<int> s(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> s[i];\n     }\n     sort(s.begin(), s.end());\n \n     long long res = 0;\n     for (int j = 1; j < n; ++j) {\n         double target = 0.9 * s[j];\n         int left = 0, right = j;\n         while (left < right) {\n             int mid = left + (right - left) / 2;\n             if (s[mid] < target) {\n                 left = mid + 1;\n             } else {\n                 right = mid;\n             }\n         }\n         res += j - left;\n     }\n \n     cout << res << endl;\n }\n \n \n signed main() {\n     fastW();\n     solve();\n }\n "~1
"#include <iostream>\n #include <iomanip>\n #include <algorithm>\n #include <cstdlib>\n #include <cstdio>\n #include <cstring>\n #include <cctype>\n #include <cmath>\n #include <numeric>\n #include <vector>\n #include <string>\n #include <array>\n #include <functional>\n #include <ctime>\n #include <chrono>\n #include <random>\n #include <queue>\n #include <deque>\n #include <set>\n #include <map>\n #include <unordered_set>\n #include <unordered_map>\n #include <bitset>\n #include <cstdint>\n #include <list>\n #include <optional>\n  \n using namespace std;\n  \n #define int long long\n #ifndef ONLINE_JUDGE\n #else\n #define endl '\n '\n #endif\n using ll = long long;\n using ull = unsigned long long;\n using db = double;\n using i32 = int32_t;\n  \n #define all(x) (x).begin(), (x).end()\n #define rall(x) (x).rbegin(), (x).rend()\n #define rep(n) for (int rep_iter = 0; rep_iter < n; rep_iter++)\n #define cin(v) for (auto& el : v) cin >> el;\n  \n void fastW() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n     cout.precision(8);\n }\n  \n int gcd(int a, int b) {\n     if (!b) {\n             return a;\n     }\n     return gcd(b, a % b);\n }\n  \n int lcm(int a, int b) {\n     return a / gcd(a, b) * b;\n }\n  \n  \n void solve() {\n     int n; cin >> n;\n     string st; cin >> st;\n  \n     map <char, int> mp;\n     for (auto el : st) {\n         mp[el]++;\n     }\n     int ans = 1LL << 61;\n     for (auto [key, val] : mp) {\n         ans = min(ans, abs(n - val));\n     }\n     cout << ans << endl;\n }\n  \n  \n signed main() {\n     fastW();\n     solve();\n }\n "~1
"#include <iostream>\n #include <iomanip>\n #include <algorithm>\n #include <cstdlib>\n #include <cstdio>\n #include <cstring>\n #include <cctype>\n #include <cmath>\n #include <numeric>\n #include <vector>\n #include <string>\n #include <array>\n #include <functional>\n #include <ctime>\n #include <chrono>\n #include <random>\n #include <queue>\n #include <deque>\n #include <set>\n #include <map>\n #include <unordered_set>\n #include <unordered_map>\n #include <bitset>\n #include <cstdint>\n #include <list>\n #include <optional>\n  \n using namespace std;\n  \n #define int long long\n #ifndef ONLINE_JUDGE\n #else\n #define endl '\n '\n #endif\n using ll = long long;\n using ull = unsigned long long;\n using db = double;\n using i32 = int32_t;\n  \n #define all(x) (x).begin(), (x).end()\n #define rall(x) (x).rbegin(), (x).rend()\n #define rep(n) for (int rep_iter = 0; rep_iter < n; rep_iter++)\n #define cin(v) for (auto& el : v) cin >> el;\n  \n void fastW() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n     cout.precision(8);\n }\n  \n int gcd(int a, int b) {\n     if (!b) {\n             return a;\n     }\n     return gcd(b, a % b);\n }\n  \n int lcm(int a, int b) {\n     return a / gcd(a, b) * b;\n }\n  \n  \n void solve() {\n     int a, b, c, d, e;\n     cin >> a >> b >> c >> d >> e;\n  \n     int fir = min(a, b);\n     int sec = c;\n     int thir = min(e, d);\n  \n     int ans = min(max(fir, sec), thir);\n     // cout << max(fir, sec) << endl;\n     thir -= max(fir, sec);\n     if (thir > 0) {\n         ans += min(min(sec, fir), thir);\n     }\n     cout << ans << endl;\n }\n  \n  \n signed main() {\n     fastW();\n     solve();\n }\n "~1
"#include <bits/stdc++.h>\n using namespace std;\n using ll = long long;\n using ld = long double;\n \n void solve() {\n     static const ld EPS = 1e-7L;\n \n     ld L; ll N;\n     cin >> L >> N;\n \n     vector<ld> T(N), V(N);\n     for (ll i = 0; i < N; ++i) cin >> T[i] >> V[i];\n \n     vector<ld> P(N + 1, 0.0L), D(N + 1, 0.0L);\n     for (ll i = 0; i < N; ++i) P[i + 1] = P[i] + T[i], D[i + 1] = D[i] + V[i] * T[i];\n \n     ld stt = P[N];\n     ld dtt = D[N];\n \n     auto s = [&](ld t) {\n         if (t >= stt) return dtt;\n \n         auto it = upper_bound(P.begin(), P.end(), t);\n         ll djj = it - P.begin(), k = djj - 1;\n         ld dt = t - P[k];\n         return D[k] + V[k] * dt;\n     };\n \n     auto mng = [&](ld d) {\n         ld lmt = stt - d;\n         if (lmt < 0) return dtt;\n \n         vector<ld> cc;\n         cc.reserve(2 * (N + 1) + 2);\n         cc.push_back(0.0L), cc.push_back(lmt);\n \n         for (ll i = 0; i <= N; ++i) {\n             ld t = P[i];\n             if (t >= 0.0L && t <= lmt) cc.push_back(t);\n         }\n \n         for (ll j = 0; j <= N; ++j) {\n             ld t = P[j] - d;\n             if (t >= 0.0L && t <= lmt) cc.push_back(t);\n         }\n \n         sort(cc.begin(), cc.end());\n         auto lst = unique(cc.begin(), cc.end());\n         cc.erase(lst, cc.end());\n \n         ld ang = numeric_limits<ld>::infinity();\n         for (auto tau : cc) {\n             ld g = s(tau + d) - s(tau);\n             if (g < ang) ang = g;\n         }\n \n         return ang;\n     };\n \n     if (mng(stt) < L - EPS) {\n         cout << fixed << setprecision(3) << stt << '\n ';\n         return;\n     }\n \n     ld lp = 0.0L, rp = stt;\n     for (ll it = 0; it < 80; it++) {\n         ld mp = (lp + rp) / 2.0L;\n         if (mng(mp) >= L) rp = mp;\n         else lp = mp;\n     }\n \n     cout << fixed << setprecision(3) << rp << '\n ';\n }\n \n int main() {\n     cin.tie(nullptr)->sync_with_stdio(false);\n \n     ll t = 1; // cin >> t;\n     while (t--) solve();\n }\n "~1
"#include <bits/stdc++.h>\n using namespace std;\n using ll = long long;\n \n void solve() {\n     freopen("input.txt", "r", stdin);\n     freopen("output.txt", "w", stdout);\n \n     ll n; cin >> n;\n \n     vector<array<ll, 4>> a(n);\n     for (ll i = 0; i < n; ++i) {\n         ll t, s, p; cin >> t >> s >> p;\n         a[i] = {t, s, p, i};\n     }\n \n     sort(a.begin(), a.end());\n \n     vector<ll> t(n), s(n), p(n), ind(n);\n     for (ll i = 0; i < n; ++i) {\n         t[i] = a[i][0], s[i] = a[i][1], p[i] = a[i][2];\n         ind[a[i][3]] = i;\n     }\n \n     ll T; cin >> T;\n \n     vector<ll> P = p;\n     sort(P.rbegin(), P.rend()), P.pop_back(), reverse(P.begin(), P.end());\n \n     vector<ll> v;\n     if (P.empty() || P[0] != 1) v.push_back(1);\n \n     for (ll i = 0; i < P.size(); ++i) {\n         if (i == P.size() - 1 || P[i + 1] > P[i] + 1) v.push_back(P[i] + 1);\n     }\n \n     ll L = 0, R = v.size();\n     while (R - L > 1) {\n         ll M = (L + R) / 2, now = v[M];\n \n         vector<ll> rm = s;\n         priority_queue<pair<ll, ll>> q;\n \n         ll j = 0, nwt = 0, ex = 0;\n         while (j < n || !q.empty()) {\n             if (q.empty()) {\n                 nwt = t[j];\n                 while (j < n && t[j] == nwt) {\n                     q.push({(p[j] == -1 ? now : p[j]), j});\n                     ++j;\n                 }\n             }\n \n             ll jj = q.top().second; q.pop();\n \n             ll ntt = (j < n ? t[j] : LLONG_MAX), ww = min(rm[jj], ntt - nwt);\n \n             nwt += ww, rm[jj] -= ww;\n \n             if (rm[jj] > 0) q.push({(p[jj] == -1 ? now : p[jj]), jj});\n             else if (p[jj] == -1) ex = nwt;\n \n             while (j < n && t[j] == nwt) {\n                 q.push({(p[j] == -1 ? now : p[j]), j});\n                 ++j;\n             }\n         }\n \n         if (ex < T) R = M;\n         else L = M;\n     }\n \n     ll ch = v[L];\n     cout << ch << '\n ';\n \n     vector<ll> rm = s, ans(n);\n     priority_queue<pair<ll, ll>> q;\n \n     ll j = 0, nwt = 0;\n     while (j < n || !q.empty()) {\n         if (q.empty()) {\n             nwt = t[j];\n             while (j < n && t[j] == nwt) {\n                 q.push({(p[j] == -1 ? ch : p[j]), j});\n                 ++j;\n             }\n         }\n \n         ll jj = q.top().second; q.pop();\n \n         ll ntt = (j < n ? t[j] : LLONG_MAX), ww = min(rm[jj], ntt - nwt);\n \n         nwt += ww, rm[jj] -= ww;\n \n         if (rm[jj] > 0) q.push({(p[jj] == -1 ? ch : p[jj]), jj});\n         else ans[jj] = nwt;\n \n         while (j < n && t[j] == nwt) {\n             q.push({(p[j] == -1 ? ch : p[j]), j});\n             ++j;\n         }\n     }\n \n     for (ll i = 0; i < n; ++i) cout << ans[ind[i]] << ' ';\n     cout << '\n ';\n }\n \n int main() {\n     cin.tie(nullptr)->sync_with_stdio(false);\n     solve();\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n \n long long gcd(long long a, long long b) {\n     while (b != 0) {\n         long long temp = b;\n         b = a % b;\n         a = temp;\n     }\n     return a;\n }\n \n long long lcm(long long a, long long b) {\n     return (a / gcd(a, b)) * b;\n }\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n;\n     cin >> n;\n     vector<long long> t(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> t[i];\n         t[i] += 1; // Преобразуем t_i в t_i + 1\n     }\n \n     long long current_lcm = 1;\n     for (long long num : t) {\n         current_lcm = lcm(current_lcm, num);\n     }\n \n     cout << current_lcm << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n using namespace std;\n \n const int MOD = 1e9 + 7;\n \n vector<int> sieve(int n) {\n     vector<int> primes;\n     vector<bool> is_prime(n + 1, true);\n     is_prime[0] = is_prime[1] = false;\n     for (int p = 2; p <= n; ++p) {\n         if (is_prime[p]) {\n             primes.push_back(p);\n             for (int multiple = p * 2; multiple <= n; multiple += p) {\n                 is_prime[multiple] = false;\n             }\n         }\n     }\n     return primes;\n }\n \n int count_exponents(int n, int p) {\n     int exponent = 0;\n     while (n > 0) {\n         n /= p;\n         exponent += n;\n     }\n     return exponent;\n }\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int N;\n     cin >> N;\n \n     if (N == 0 || N == 1) {\n         cout << 1 << endl;\n         return 0;\n     }\n \n     vector<int> primes = sieve(N);\n \n     long long result = 1;\n     for (int p : primes) {\n         int exponent = count_exponents(N, p);\n         result = (result * (exponent + 1)) % MOD;\n     }\n \n     cout << result << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <cmath>\n using namespace std;\n \n int gcd(int a, int b) {\n     while (b != 0) {\n         int temp = b;\n         b = a % b;\n         a = temp;\n     }\n     return a;\n }\n \n int main() {\n     int x1, y1, x2, y2;\n     cin >> x1 >> y1 >> x2 >> y2;\n \n     int dx = abs(x2 - x1);\n     int dy = abs(y2 - y1);\n \n     int g = gcd(dx, dy);\n     int points = g + 1;\n \n     cout << points << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n;\n     long long k;\n     cin >> n >> k;\n \n     vector<long long> a(n);\n     long long total = 0;\n     long long max_a = 0;\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n         total += a[i];\n         max_a = max(max_a, a[i]);\n     }\n \n     if (total < k) {\n         cout << -1 << endl;\n         return 0;\n     }\n \n     long long left = 0;\n     long long right = max_a;\n     long long answer = max_a;\n \n     while (left <= right) {\n         long long mid = (left + right) / 2;\n         long long sum = 0;\n         for (int i = 0; i < n; ++i) {\n             sum += min(a[i], mid);\n         }\n \n         if (sum >= k) {\n             answer = mid;\n             right = mid - 1;\n         } else {\n             left = mid + 1;\n         }\n     }\n \n     cout << answer << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n using namespace std;\n \n int sumOfDigits(int k) {\n     int sum = 0;\n     while (k > 0) {\n         sum += k % 10;\n         k /= 10;\n     }\n     return sum;\n }\n \n int main() {\n     int n;\n     cin >> n;\n \n     int k = n;\n     while (true) {\n         int sum = sumOfDigits(k);\n         if (k % sum == 0) {\n             cout << k << endl;\n             break;\n         }\n         k++;\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <climits>\n using namespace std;\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n;\n     cin >> n;\n     vector<int> t(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> t[i];\n     }\n     string s;\n     cin >> s;\n \n     int min_tmax = INT_MAX;\n     int max_tmin = INT_MIN;\n \n     for (int i = 5; i < n; ++i) {\n         if (s[i-1] == '0' && s[i] == '1') {\n             // Переход с 0 на 1: tmin > max(t[i-4..i])\n             int max_temp = t[i-4];\n             for (int j = i-3; j <= i; ++j) {\n                 if (t[j] > max_temp) {\n                     max_temp = t[j];\n                 }\n             }\n             if (max_temp > max_tmin) {\n                 max_tmin = max_temp;\n             }\n         } else if (s[i-1] == '1' && s[i] == '0') {\n             // Переход с 1 на 0: tmax < min(t[i-4..i])\n             int min_temp = t[i-4];\n             for (int j = i-3; j <= i; ++j) {\n                 if (t[j] < min_temp) {\n                     min_temp = t[j];\n                 }\n             }\n             if (min_temp < min_tmax) {\n                 min_tmax = min_temp;\n             }\n         }\n     }\n \n     // Учитываем, что tmin <= tmax\n     if (max_tmin == INT_MIN) {\n         // Нет переходов 0 -> 1, tmin может быть любым <= tmax\n         max_tmin = -1e9;\n     }\n     if (min_tmax == INT_MAX) {\n         // Нет переходов 1 -> 0, tmax может быть любым >= tmin\n         min_tmax = 1e9;\n     }\n \n     // tmin должно быть > max_tmin, tmax должно быть < min_tmax\n     int tmin = max_tmin + 1;\n     int tmax = min_tmax - 1;\n \n     // Если tmin > tmax, корректируем\n     if (tmin > tmax) {\n         // Находим середину\n         int mid = (max_tmin + min_tmax) / 2;\n         tmin = mid;\n         tmax = mid;\n     }\n \n     cout << tmin << " " << tmax << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_map>\n #include <algorithm>\n using namespace std;\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n, k;\n     cin >> n >> k;\n     vector<int> a(n);\n     unordered_map<int, int> freq;\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n         freq[a[i]]++;\n     }\n \n     int result = 0;\n     vector<bool> disabled(n, false);\n \n     for (int i = 0; i < n; ++i) {\n         if (disabled[i]) continue;\n         int complement = k - a[i];\n         if (freq.find(complement) != freq.end()) {\n             if (complement == a[i]) {\n                 result += freq[complement] / 2;\n                 freq[complement] = 0;\n             } else {\n                 if (freq[a[i]] > freq[complement]) {\n                     result += freq[complement];\n                     freq[a[i]] -= freq[complement];\n                     freq[complement] = 0;\n                 } else {\n                     result += freq[a[i]];\n                     freq[complement] -= freq[a[i]];\n                     freq[a[i]] = 0;\n                 }\n             }\n         }\n     }\n \n     cout << result << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <string>\n #include <unordered_map>\n using namespace std;\n \n unordered_map<string, vector<string>> functions;\n vector<string> output;\n \n void execute(const vector<string>& commands) {\n     for (const string& cmd : commands) {\n         if (cmd.rfind("print ", 0) == 0) {\n             output.push_back(cmd.substr(6));\n         }\n         else if (cmd.rfind("call ", 0) == 0) {\n             string func_name = cmd.substr(5);\n             execute(functions[func_name]);\n         }\n     }\n }\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     vector<string> lines;\n     string line;\n     while (getline(cin, line)) {\n         if (line == "endprg") break;\n         if (!line.empty()) lines.push_back(line);\n     }\n \n     size_t i = 0;\n     while (i < lines.size() && lines[i].rfind("function ", 0) == 0) {\n         string func_name = lines[i].substr(9);\n         i++;\n         vector<string> func_body;\n         while (i < lines.size() && lines[i] != "end") {\n             func_body.push_back(lines[i]);\n             i++;\n         }\n         functions[func_name] = func_body;\n         i++; // skip "end"\n     }\n \n     vector<string> main_commands(lines.begin() + i, lines.end());\n     execute(main_commands);\n \n     for (const string& s : output) {\n         cout << s << '\n ';\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n using namespace std;\n \n int main() {\n     int n, x;\n     cin >> n >> x;\n     n %= 6;\n \n     for (int i = n; i >= 1; --i) {\n         if (i % 2 == 1) {\n             if (x == 0) x = 1;\n             else if (x == 1) x = 0;\n         } else {\n             if (x == 1) x = 2;\n             else if (x == 2) x = 1;\n         }\n     }\n \n     cout << x << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n using namespace std;\n \n struct SegmentTree {\n     int size;\n     vector<long long> tree;\n \n     SegmentTree(int n) {\n         size = 1;\n         while (size < n) size *= 2;\n         tree.assign(2 * size, 0LL);\n     }\n \n     void update(int i, int v, int x, int lx, int rx) {\n         if (rx - lx == 1) {\n             tree[x] = v;\n             return;\n         }\n         int m = (lx + rx) / 2;\n         if (i < m) {\n             update(i, v, 2 * x + 1, lx, m);\n         } else {\n             update(i, v, 2 * x + 2, m, rx);\n         }\n         tree[x] = tree[2 * x + 1] + tree[2 * x + 2];\n     }\n \n     void update(int i, int v) {\n         update(i, v, 0, 0, size);\n     }\n \n     long long query(int l, int r, int x, int lx, int rx) {\n         if (l >= rx || r <= lx) return 0;\n         if (l <= lx && rx <= r) return tree[x];\n         int m = (lx + rx) / 2;\n         return query(l, r, 2 * x + 1, lx, m) + query(l, r, 2 * x + 2, m, rx);\n     }\n \n     long long query(int l, int r) {\n         return query(l, r + 1, 0, 0, size);\n     }\n };\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int N, K;\n     cin >> N >> K;\n \n     SegmentTree st(N);\n \n     while (K--) {\n         char type;\n         cin >> type;\n         if (type == 'A') {\n             int i, x;\n             cin >> i >> x;\n             st.update(i - 1, x); // Переход к 0-индексации\n         } else if (type == 'Q') {\n             int l, r;\n             cin >> l >> r;\n             cout << st.query(l - 1, r - 1) << '\n '; // Переход к 0-индексации\n         }\n     }\n \n     return 0;\n }\n "~1
"#include <bits/stdc++.h>\n \n using namespace std;\n \n struct Node{\n     long long sum = 0;\n };\n \n vector<Node> tree;\n vector<long long> a;\n vector<long long> add;\n const long long INF = 1e18;\n \n void update(long long x, long long l, long long r){\n     tree[x].sum = tree[x*2+1].sum + tree[x*2+2].sum;\n }\n \n void push(long long x, long long l, long long r){\n     if (add[x] == INF){\n         return;\n     }\n     tree[x].sum = add[x]*(r-l);\n     if (r - l > 1) {\n         add[x*2+1] = add[x];\n         add[x*2+2] = add[x];\n     }\n     add[x] = INF;\n }\n \n void build(long long x, long long l, long long r){\n     add[x] = INF;\n     if (r - l == 1){\n         if (l < a.size()) {\n             tree[x].sum = a[l];\n         } else {\n             tree[x].sum = 0;\n         }\n         return;\n     }\n     long long m = (l + r) / 2;\n     build(x*2+1, l, m);\n     build(x*2+2, m, r);\n     update(x, l, r);\n }\n \n void add_range(long long x, long long l, long long r, long long value, long long lq, long long rq){\n     push(x, l, r);\n     if (l >= rq  r <= lq){\n         return;\n     }\n     if (l >= lq && r <= rq){\n         add[x] = value;\n         push(x, l, r);\n         return;\n     }\n     long long m = (l + r) / 2;\n     add_range(x*2+1, l, m, value, lq, rq);\n     add_range(x*2+2, m, r, value, lq, rq);\n     update(x, l, r);\n }\n \n long long get_ans(long long x, long long l, long long r, long long lq, long long rq){\n     push(x, l, r);\n     if (l >= rq  r <= lq){\n         return 0;\n     }\n     if (l >= lq && r <= rq){\n         return tree[x].sum;\n     }\n     long long m = (l + r) / 2;\n     long long child1Value = get_ans(x*2+1, l, m, lq, rq);\n     long long child2Value = get_ans(x*2+2, m, r, lq, rq);\n     return child1Value + child2Value;\n }\n \n int main(){\n     int n, m; cin >> n >> m;\n     long long size = 1;\n     while (size < n){\n         size *= 2;\n     }\n     tree.resize(2 * size - 1);\n     add.resize(2 * size - 1, INF);\n     build(0, 0, size);\n     int l, r; char ch; long long val;\n     for (int i = 0; i < m; i++){\n         cin >> ch;\n         if (ch == 'Q'){\n             cin >> l >> r;\n             cout << get_ans(0, 0, size, l - 1, r) << "\n ";\n         } else {\n             cin >> l >> r >> val;\n             add_range(0, 0, size, val, l - 1, r);\n         }\n     }\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n \n using namespace std;\n \n vector<int> longestCommonSubsequence(const vector<int>& seq1, const vector<int>& seq2) {\n     int n = seq1.size();\n     int m = seq2.size();\n     \n     // Создаем DP-таблицу (n+1) x (m+1), инициализированную нулями\n     vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n     \n     // Заполняем DP-таблицу\n     for (int i = 1; i <= n; ++i) {\n         for (int j = 1; j <= m; ++j) {\n             if (seq1[i - 1] == seq2[j - 1]) {\n                 dp[i][j] = dp[i - 1][j - 1] + 1;\n             } else {\n                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n             }\n         }\n     }\n     \n     // Восстанавливаем НОП\n     vector<int> lcs;\n     int i = n, j = m;\n     while (i > 0 && j > 0) {\n         if (seq1[i - 1] == seq2[j - 1]) {\n             lcs.push_back(seq1[i - 1]);\n             --i;\n             --j;\n         } else if (dp[i - 1][j] > dp[i][j - 1]) {\n             --i;\n         } else {\n             --j;\n         }\n     }\n     \n     // Разворачиваем результат, так как собирали с конца\n     reverse(lcs.begin(), lcs.end());\n     return lcs;\n }\n \n int main() {\n     vector<int> seq1 = {1, 2, 3, 4, 5};\n     vector<int> seq2 = {2, 4, 5, 8, 10};\n     \n     vector<int> result = longestCommonSubsequence(seq1, seq2);\n     \n     cout << 'Наибольшая общая подпоследовательность: ';\n     for (int num : result) {\n         cout << num << " ";\n     }\n     cout << endl;\n     \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_set>\n #include <algorithm>\n \n using namespace std;\n \n vector<string> splitText(const string& text, const unordered_set<string>& dictionary) {\n     int n = text.size();\n     vector<bool> dp(n + 1, false);\n     dp[0] = true;  // Пустая строка\n \n     // Заполняем dp\n     for (int i = 1; i <= n; ++i) {\n         for (int j = 0; j < i; ++j) {\n             if (dp[j] && dictionary.count(text.substr(j, i - j))) {\n                 dp[i] = true;\n                 break;\n             }\n         }\n     }\n \n     // Если разбиение невозможно\n     if (!dp[n]) {\n         return {};\n     }\n \n     // Восстанавливаем слова\n     vector<string> words;\n     int end = n;\n     while (end > 0) {\n         for (int start = end - 1; start >= 0; --start) {\n             string candidate = text.substr(start, end - start);\n             if (dp[start] && dictionary.count(candidate)) {\n                 words.push_back(candidate);\n                 end = start;\n                 break;\n             }\n         }\n     }\n \n     reverse(words.begin(), words.end());\n     return words;\n }\n \n int main() {\n     string text = 'thisisatest';\n     unordered_set<string> dictionary = {'this', 'is', 'a', 'test', 'his'};\n \n     vector<string> result = splitText(text, dictionary);\n \n     if (result.empty()) {\n         cout << 'Невозможно разбить текст на слова из словаря.' << endl;\n     } else {\n         cout << 'Разбитый текст: ';\n         for (const string& word : result) {\n             cout << word << " ";\n         }\n         cout << endl;\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n int main() {\n     // Вводим последовательность чисел\n     vector<int> sequence;\n     int num;\n     \n     cout << 'Введите последовательность целых чисел (для завершения введите любой нечисловой символ):\n ';\n     while (cin >> num) {\n         sequence.push_back(num);\n     }\n \n     // Выводим последовательность в обратном порядке\n     cout << 'Последовательность в обратном порядке:\n ';\n     for (int i = sequence.size() - 1; i >= 0; --i) {\n         cout << sequence[i] << " ";\n     }\n     cout << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_set>\n #include <algorithm>\n \n using namespace std;\n \n // Функция для вычисления MEX массива\n int computeMex(const vector<int>& v) {\n     unordered_set<int> s(v.begin(), v.end());\n     int mex = 0;\n     while (s.count(mex)) mex++;\n     return mex;\n }\n \n // Функция для проверки, можно ли разбить массив на k подотрезков с MEX >= target\n bool canSplit(const vector<int>& a, int k, int target) {\n     unordered_set<int> required;\n     for (int i = 0; i < target; i++) required.insert(i);\n \n     int segments = 0;\n     unordered_set<int> current;\n \n     for (int num : a) {\n         if (num < target) current.insert(num);\n         if (current == required) {\n             segments++;\n             current.clear();\n             if (segments == k) return true;\n         }\n     }\n     return false;\n }\n \n int main() {\n     int n, k;\n     cin >> n >> k;\n     vector<int> a(n);\n     for (int i = 0; i < n; i++) cin >> a[i];\n \n     int global_mex = computeMex(a);\n \n     // Бинарный поиск по ответу\n     int left = 0, right = global_mex;\n     int answer = 0;\n \n     while (left <= right) {\n         int mid = (left + right) / 2;\n         if (canSplit(a, k, mid)) {\n             answer = mid;\n             left = mid + 1;\n         } else {\n             right = mid - 1;\n         }\n     }\n \n     cout << answer << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n using namespace std;\n \n int minOperations(vector<int>& a) {\n     int operations = 0;\n     bool changed;\n     do {\n         changed = false;\n         for (int i = 0; i < a.size() - 1; ++i) {\n             if (a[i] > a[i + 1]) {\n                 // Оптимальное разбиение: x = min(a[i] // 2, a[i + 1])\n                 int x = min(a[i] / 2, a[i + 1]);\n                 if (x < 1) x = 1;  // x должен быть ≥ 1\n                 a.insert(a.begin() + i + 1, a[i] - x);\n                 a[i] = x;\n                 operations++;\n                 changed = true;\n                 break;  // После разбиения перепроверяем массив с начала\n             }\n         }\n     } while (changed);\n     return operations;\n }\n \n int main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; ++i) cin >> a[i];\n     cout << minOperations(a) << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n \n using namespace std;\n \n // Структура для хранения индекса и частоты запроса цвета\n struct Box {\n     int index;\n     int r;\n };\n \n // Компаратор для сортировки коробок по убыванию r\n bool compareBoxes(const Box &a, const Box &b) {\n     return a.r > b.r;\n }\n \n vector<vector<int>> distributeBoxes(int n, int s1, int s2, const vector<int> &r) {\n     vector<Box> boxes(n);\n     for (int i = 0; i < n; ++i) {\n         boxes[i] = {i + 1, r[i]}; // Нумерация коробок с 1\n     }\n \n     // Сортируем коробки по убыванию r\n     sort(boxes.begin(), boxes.end(), compareBoxes);\n \n     vector<int> a, b;\n \n     for (const Box &box : boxes) {\n         // Вычисляем потенциальные позиции в a и b\n         int posA = a.size() + 1;\n         int posB = b.size() + 1;\n \n         // Сравниваем вклады\n         if (s1 * posA <= s2 * posB) {\n             a.push_back(box.index);\n         } else {\n             b.push_back(box.index);\n         }\n     }\n \n     return {a, b};\n }\n \n int main() {\n     int n, s1, s2;\n     cin >> n >> s1 >> s2;\n \n     vector<int> r(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> r[i];\n     }\n \n     vector<vector<int>> result = distributeBoxes(n, s1, s2, r);\n \n     // Вывод результатов\n     cout << 'Робот A: ';\n     for (int box : result[0]) {\n         cout << box << ' ';\n     }\n     cout << '\n Робот B: ';\n     for (int box : result[1]) {\n         cout << box << ' ';\n     }\n     cout << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <set>\n #include <algorithm>\n \n using namespace std;\n \n vector<pair<int, int>> build_tree(int n) {\n     vector<pair<int, int>> edges;\n     if (n == 1) return edges;\n \n     // Начинаем с вершины 1\n     set<int> known;\n     known.insert(1);\n \n     for (int i = 2; i <= n; ++i) {\n         vector<int> candidates(known.begin(), known.end());\n         int parent = -1;\n \n         // Ищем родителя для вершины i\n         for (int candidate : candidates) {\n             cout << "? " << i << " " << candidate << endl;\n             cout.flush();\n             int x;\n             cin >> x;\n             if (x == candidate) {\n                 parent = candidate;\n                 break;\n             } else if (x != i) {\n                 // Продолжаем искать\n             }\n         }\n \n         if (parent == -1) {\n             // Если не нашли, то i соединена с 1\n             parent = 1;\n         }\n \n         edges.emplace_back(parent, i);\n         known.insert(i);\n     }\n \n     return edges;\n }\n \n int main() {\n     int n;\n     cin >> n;\n \n     vector<pair<int, int>> edges = build_tree(n);\n \n     cout << '!' << endl;\n     for (auto edge : edges) {\n         cout << edge.first << ' ' << edge.second << endl;\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <numeric>\n \n using namespace std;\n \n int gcd(int a, int b) {\n     while (b != 0) {\n         int temp = b;\n         b = a % b;\n         a = temp;\n     }\n     return a;\n }\n \n int main() {\n     int n, a, b;\n     cin >> n >> a >> b;\n     vector<int> c(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> c[i];\n     }\n     if (a == b) {\n         // Все операции одинаковы, диапазон не меняется\n         int min_val = *min_element(c.begin(), c.end());\n         int max_val = *max_element(c.begin(), c.end());\n         cout << max_val - min_val << endl;\n     } else {\n         int d = gcd(a, b);\n         vector<int> remainders(n);\n         for (int i = 0; i < n; ++i) {\n             remainders[i] = c[i] % d;\n         }\n         int min_remainder = *min_element(remainders.begin(), remainders.end());\n         int max_remainder = *max_element(remainders.begin(), remainders.end());\n         cout << max_remainder - min_remainder << endl;\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <queue>\n \n using namespace std;\n \n int main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n     }\n \n     priority_queue<int, vector<int>, greater<int>> min_heap;\n     long long health = 0;\n     int count = 0;\n \n     for (int i = 0; i < n; ++i) {\n         if (a[i] >= 0) {\n             health += a[i];\n             count++;\n         } else {\n             if (health + a[i] >= 0) {\n                 health += a[i];\n                 count++;\n                 min_heap.push(a[i]);\n             } else if (!min_heap.empty() && min_heap.top() < a[i]) {\n                 health -= min_heap.top();\n                 health += a[i];\n                 min_heap.pop();\n                 min_heap.push(a[i]);\n             }\n         }\n     }\n \n     cout << count << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <cmath>\n \n using namespace std;\n \n vector<int> getDivisors(int p) {\n     vector<int> divisors;\n     if (p == 0) {\n         // 0 делится на любое число, но в задаче, скорее всего, p_i ≠ 0\n         return divisors;\n     }\n     int abs_p = abs(p);\n     for (int i = 1; i <= sqrt(abs_p); ++i) {\n         if (abs_p % i == 0) {\n             divisors.push_back(i);\n             if (i != abs_p / i) {\n                 divisors.push_back(abs_p / i);\n             }\n         }\n     }\n     return divisors;\n }\n \n int findMaxX(int p, int q) {\n     if (p == 0) {\n         // Если p = 0, любое x ≠ 0 подходит, но максимального нет\n         return -1;\n     }\n     vector<int> divisors = getDivisors(p);\n     sort(divisors.begin(), divisors.end(), greater<int>());\n     for (int x : divisors) {\n         if (q == 0) {\n             // Если q = 0, условие x % q не определено (деление на 0)\n             // Но по условию x не должен делиться на q, что невозможно, если q = 0\n             // В этом случае возвращаем максимальный делитель\n             return x;\n         }\n         if (x % q != 0) {\n             return x;\n         }\n     }\n     return -1;\n }\n \n int main() {\n     int t;\n     cin >> t;\n     while (t--) {\n         int p, q;\n         cin >> p >> q;\n         int res = findMaxX(p, q);\n         cout << res << endl;\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_map>\n #include <algorithm>\n #include <climits>\n \n using namespace std;\n \n int minDeletionsToBeautifulArray(vector<int>& a) {\n     unordered_map<int, int> freq;\n     for (int num : a) {\n         freq[num]++;\n     }\n \n     vector<int> frequencies;\n     for (auto& [num, cnt] : freq) {\n         frequencies.push_back(cnt);\n     }\n \n     sort(frequencies.begin(), frequencies.end());\n     int min_deletions = INT_MAX;\n \n     // Перебираем все возможные C (все уникальные частоты + 0)\n     for (int C : frequencies) {\n         int deletions = 0;\n         for (int f : frequencies) {\n             if (f < C) {\n                 deletions += f; // Удаляем все вхождения числа\n             } else {\n                 deletions += (f - C); // Удаляем лишние вхождения\n             }\n         }\n         if (deletions < min_deletions) {\n             min_deletions = deletions;\n         }\n     }\n \n     // Проверяем случай, когда C = 0 (удаляем все элементы)\n     int total_elements = a.size();\n     if (total_elements < min_deletions) {\n         min_deletions = total_elements;\n     }\n \n     return min_deletions;\n }\n \n int main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n     }\n \n     cout << minDeletionsToBeautifulArray(a) << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n \n using namespace std;\n \n int main() {\n     int n, x;\n     cin >> n >> x;\n     vector<int> a(n);\n     bool has_x = false;\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n         if (a[i] == x) {\n             has_x = true;\n         }\n     }\n \n     int infected = 0;\n     for (int num : a) {\n         if (num == x) {\n             infected++;\n         }\n     }\n \n     if (has_x) {\n         // Если x уже есть, то заражаем все такие аккаунты\n         int remaining = n - infected;\n         if (remaining == 0) {\n             cout << 0 << endl;\n         } else {\n             // Проверяем, можно ли остальные сделать равными x за 1 контест\n             long long sum = 0;\n             for (int num : a) {\n                 if (num != x) {\n                     sum += (x - num);\n                 }\n             }\n             if (sum == 0) {\n                 cout << 1 << endl;\n             } else {\n                 cout << 2 << endl;\n             }\n         }\n     } else {\n         // Если x нет, то нужно хотя бы один аккаунт сделать равным x\n         // Затем остальные можно заразить за 1 или 2 контеста\n         long long sum = 0;\n         for (int num : a) {\n             sum += (x - num);\n         }\n         if (sum == 0) {\n             // Можно за 2 контеста:\n             // 1. Сделать один аккаунт равным x\n             // 2. Остальные сделать равными x\n             cout << 2 << endl;\n         } else {\n             // Нужно 3 контеста:\n             // 1. Сделать один аккаунт равным x\n             // 2. Скорректировать суммы\n             // 3. Остальные сделать равными x\n             cout << 3 << endl;\n         }\n     }\n \n     return 0;\n }\n "~1
"#include <vector>\n #include <algorithm>\n using namespace std;\n \n struct Square {\n     int x, y; // Левый верхний угол\n     int size; // Длина стороны\n };\n \n Square findMaxSquare(const vector<vector<int>>& matrix) {\n     if (matrix.empty() || matrix[0].empty()) return {-1, -1, 0};\n \n     int rows = matrix.size();\n     int cols = matrix[0].size();\n \n     // Создаём DP-таблицу\n     vector<vector<int>> dp(rows, vector<int>(cols, 0));\n     int max_size = 0;\n     int max_i = 0, max_j = 0;\n \n     // Заполняем DP-таблицу\n     for (int i = 0; i < rows; ++i) {\n         for (int j = 0; j < cols; ++j) {\n             if (matrix[i][j] == 1) {\n                 if (i == 0 || j == 0) {\n                     dp[i][j] = 1;\n                 } else {\n                     dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});\n                 }\n \n                 if (dp[i][j] > max_size) {\n                     max_size = dp[i][j];\n                     max_i = i;\n                     max_j = j;\n                 }\n             }\n         }\n     }\n \n     // Восстанавливаем ответ\n     if (max_size == 0) return {-1, -1, 0}; // Если нет единиц (но по условию гарантируется)\n \n     int start_i = max_i - max_size + 1;\n     int start_j = max_j - max_size + 1;\n \n     return {start_i, start_j, max_size};\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <cmath>\n \n using namespace std;\n \n vector<int> sieve(int n) {\n     vector<bool> is_prime(n + 1, true);\n     is_prime[0] = is_prime[1] = false;\n     for (int i = 2; i * i <= n; ++i) {\n         if (is_prime[i]) {\n             for (int j = i * i; j <= n; j += i) {\n                 is_prime[j] = false;\n             }\n         }\n     }\n     vector<int> primes;\n     for (int i = 2; i <= n; ++i) {\n         if (is_prime[i]) {\n             primes.push_back(i);\n         }\n     }\n     return primes;\n }\n \n int sum_of_divisors(int n, const vector<int>& primes) {\n     if (n == 0) return 0;\n     int sum = 1;\n     int temp = n;\n     for (int p : primes) {\n         if (p * p > temp) break;\n         if (temp % p == 0) {\n             int exponent = 0;\n             while (temp % p == 0) {\n                 temp /= p;\n                 exponent++;\n             }\n             sum *= (pow(p, exponent + 1) - 1) / (p - 1);\n         }\n     }\n     if (temp > 1) {\n         sum *= (temp * temp - 1) / (temp - 1);\n     }\n     return sum;\n }\n \n int main() {\n     int n;\n     cout << "Enter a number: ";\n     cin >> n;\n     \n     int limit = sqrt(n) + 1;\n     vector<int> primes = sieve(limit);\n     \n     cout << "Sum of divisors of " << n << " is: " << sum_of_divisors(n, primes) << endl;\n     \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n using namespace std;\n \n int minOperations(vector<int>& a) {\n     int operations = 0;\n     bool changed;\n     do {\n         changed = false;\n         for (int i = 0; i < a.size() - 1; ++i) {\n             if (a[i] > a[i + 1]) {\n                 // Оптимальное разбиение: x = min(a[i] // 2, a[i + 1])\n                 int x = min(a[i] / 2, a[i + 1]);\n                 if (x < 1) x = 1;  // x должен быть ≥ 1\n                 a.insert(a.begin() + i + 1, a[i] - x);\n                 a[i] = x;\n                 operations++;\n                 changed = true;\n                 break;  // После разбиения перепроверяем массив с начала\n             }\n         }\n     } while (changed);\n     return operations;\n }\n \n int main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; ++i) cin >> a[i];\n     cout << minOperations(a) << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n \n bool isValid(const vector<int>& fence) {\n     for (int i = 0; i < fence.size() - 1; i++) {\n         if (fence[i] == fence[i+1]) {\n             return false;\n         }\n     }\n     return true;\n }\n \n vector<int> buildFence(vector<int> colors) {\n     // Проверим тривиальный случай\n     if (colors.size() == 1) {\n         return colors;\n     }\n     \n     // Проверим, есть ли цвет, который встречается слишком часто\n     unordered_map<int, int> freq;\n     for (int color : colors) {\n         freq[color]++;\n         if (freq[color] > (colors.size() + 1) / 2) {\n             return {-1};\n         }\n     }\n     \n     // Будем перебирать все перестановки, пока не найдем подходящую\n     sort(colors.begin(), colors.end());\n     do {\n         if (isValid(colors)) {\n             return colors;\n         }\n     } while (next_permutation(colors.begin(), colors.end()));\n     \n     return {-1};\n }\n \n int main() {\n     int n;\n     cin >> n;\n     \n     vector<int> colors(n);\n     for (int i = 0; i < n; i++) {\n         cin >> colors[i];\n     }\n     \n     vector<int> fence = buildFence(colors);\n     if (fence[0] == -1) {\n         cout << -1;\n     } else {\n         for (int color : fence) {\n             cout << color << " ";\n         }\n     }\n     \n     return 0;\n }\n "~1
"#include <iostream>\n using namespace std;\n \n // Функция для вычисления суммы цифр числа\n int sumOfDigits(int n) {\n     int sum = 0;\n     while (n > 0) {\n         sum += n % 10;\n         n /= 10;\n     }\n     return sum;\n }\n \n // Функция для поиска минимального x\n int findMinX(int a, int b) {\n     int x = 1;\n     while (true) {\n         if (sumOfDigits(x) == a && sumOfDigits(2 * x) == b) {\n             return x;\n         }\n         x++;\n     }\n }\n \n int main() {\n     int a, b;\n     cin >> a;\n     cin >> b;\n \n     int result = findMinX(a, b);\n     cout << result << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n // Функция для нахождения наибольшего делителя d числа s, где d <= s/n\n int findMaxDivisor(int s, int n) {\n     int max_possible_d = s / n;\n     int best_d = 1; // минимально возможный НОД (если не найдётся лучше)\n     \n     // Перебираем возможные делители s от 1 до max_possible_d\n     for (int d = 1; d * d <= s; d++) {\n         if (s % d == 0) {\n             // Проверяем оба делителя: d и s/d\n             if (d <= max_possible_d && d > best_d) {\n                 best_d = d;\n             }\n             int counterpart = s / d;\n             if (counterpart <= max_possible_d && counterpart > best_d) {\n                 best_d = counterpart;\n             }\n         }\n     }\n     return best_d;\n }\n \n vector<int> distributeCandies(int n, int s) {\n     vector<int> a(n);\n     int d = findMaxDivisor(s, n);\n     \n     // Распределяем конфеты\n     for (int i = 0; i < n - 1; i++) {\n         a[i] = d;\n     }\n     a[n - 1] = s - (n - 1) * d; // Оставшиеся конфеты\n     \n     return a;\n }\n \n int main() {\n     int n, s;\n     cin >> n;\n     cin >> s;\n     \n     if (s < n) {\n         return 0;\n     }\n     \n     vector<int> distribution = distributeCandies(n, s);\n     for (int i = 0; i < n; i++) {\n         cout << i + 1 << ": " << distribution[i] << endl;\n     }\n     \n     // Проверка НОД (для демонстрации)\n     int current_gcd = distribution[0];\n     for (int num : distribution) {\n         current_gcd = __gcd(current_gcd, num);\n     }\n     cout << current_gcd << endl;\n     \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <set>\n #include <map>\n #include <deque>\n #include <string>\n #include <string.h>\n #include <sstream>\n #include <algorithm>\n #include <queue>\n #include <stack>\n #include <cmath>\n #define ll long long\n #define u unsigned\n \n using namespace std;\n \n int main() {\n \n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n \n     int n;\n     cin >> n;\n \n     vector<vector<u ll>> dp(21, vector<u ll>(10, 0));\n     for (u ll d = 1; d <= 9; d++) {\n         dp[1][d] = 1;\n     }\n \n \n     for (u ll i = 2; i <= n; i++) {\n         for (u ll d = 0; d <= 9; d++) {\n             dp[i][d] = dp[i - 1][d];\n             if (d > 0)\n                 dp[i][d] += dp[i - 1][d - 1];\n             if (d < 9)\n                 dp[i][d] += dp[i - 1][d + 1];\n         }\n     }\n \n     u ll count = 0;\n     for (u ll d = 0; d <= 9; d++) {\n         count += dp[n][d];\n     }\n \n     cout << count << '\n ';\n \n     return 0;\n }\n "~0
"#include <iostream>\n #include <vector>\n #include <set>\n #include <map>\n #include <deque>\n #include <string>\n #include <string.h>\n #include <sstream>\n #include <algorithm>\n #include <queue>\n #include <stack>\n #include <cmath>\n #define ll long long\n #define u unsigned\n \n using namespace std;\n \n int main() {\n \n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n \n     int n, m;\n     cin >> n >> m;\n \n     vector<int> k(n);\n     for (int& x : k) cin >> x;\n \n     vector<int> dp(n + 2, 0);\n     for (int i = 1; i <= n; i++) {\n         dp[i] = k[i - 1];\n     }\n \n     for (int i = n; i >= 1; i--) {\n         int sum = dp[i];\n         int next = i + m + 1;\n         if (next <= n) {\n             sum += dp[next];\n         }\n         dp[i] = max(dp[i + 1], sum);\n     }   \n \n     cout << dp[1] << '\n ';\n \n     return 0;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n using namespace std;\n \n int min(int a, int b) {\n     if (a < b) {\n         return a;\n     }\n     else {\n         return b;\n     }\n }\n \n int main()\n {\n     int n, a, b, c;\n     cin >> n;\n     vector <vector <int>> m(n, vector <int>(3));\n     vector <int> dp(n, 0);\n     for (int i = 0; i < n; i++) {\n         cin >> a >> b >> c;\n         m[i][0] = a;\n         m[i][1] = b;\n         m[i][2] = c;\n         if (i == 0) {\n             dp[i] = a;\n         }\n         else if (i == 1) {\n             dp[i] = min(dp[i - 1] + a, m[i - 1][1]);\n         }\n         else if (i == 2) {\n             dp[i] = min(dp[i - 1] + a, min(dp[i - 2] + m[i - 1][1], m[i - 2][2]));\n         }\n         else {\n             dp[i] = min(dp[i - 1] + a, min(dp[i - 2] + m[i - 1][1], dp[i-3] + m[i - 2][2]));\n         }\n     }\n     cout << dp[n - 1];\n     return 0;\n }\n "~0
"#include <iostream>\n #include <string>\n #include <algorithm>\n using namespace std;\n \n int main()\n {\n     int n;\n     string s = "";\n     cin >> n;\n     for (int i = 1; i <= n; i++) {\n         s.push_back(char(i + 48));\n     }\n     do {\n         cout << s << endl;\n     } while (next_permutation(s.begin(), s.end()));\n     return 0;\n }\n "~0
"#include <iostream>\n #include <string>\n #include <vector>\n #include <algorithm>\n \n using namespace std;\n \n int n, t = -10;\n \n void bumble(vector <pair<int, int>>& a) {\n     for (int i = 0; i < n; i++) {\n         bool isSort = true;\n         for (int j = i; j < n - 1; j++) {\n             if (a[j].first > a[j + 1].first) {\n                 swap(a[j], a[j + 1]);\n                 isSort = false;\n             }\n         }\n         if (isSort) {\n             break;\n         }\n     }\n }\n \n int main()\n {\n     cin >> n;\n     vector <pair <int, int> > a;\n     for (int i = 0; i < n; i++) {\n         int l, r;\n         cin >> l >> r;\n         a.push_back(make_pair(l, 1));\n         a.push_back(make_pair(r, -1));\n     }\n     sort(a.begin(), a.end());\n     int count = 0;\n     int c = 0;\n     int l = -t;\n     int x, type;\n \n     for (auto i : a) {\n         // cout << type << " ";\n         x = i.first;\n         if (l != t and count > 0) {\n             c += x - l;\n         }\n         l = x;\n         type = i.second;\n         count += type;\n     }\n     cout << c;\n     return 0;\n }\n "~0
"#include <iostream>\n #include <cmath>\n using namespace std;\n int main()\n {\n     long long a, b, c, x, k;\n     cin >> a >> b >> c >> x >> k;\n     if (x < k) {\n         cout << 0;\n     }\n     else {\n         long long l = x / k;\n         while (l >= 0) {\n             if (a <= l and l <= b) {\n                 if (c == 0) {\n                     cout << l;\n                     return 0;\n                 }\n                 else if (l * k + k * l * (c / 100.0) <= x) {\n                     cout << l;\n                     return 0;\n                 }\n             }\n             else {\n                 cout << l;\n                 return 0;\n             }\n             l--;\n         }\n         cout << 0;\n     }\n     \n }\n "~0
"#include <iostream>\n #include <cmath>\n using namespace std;\n \n int main()\n {\n     long long n, k;\n     cin >> n >> k;\n     if ((float)n / k <= 3.0f) {\n         cout << 0;\n         return 0;\n     }\n     cout << (n - 3 * k + 1) / 2;\n }\n "~0
"#include <iostream>\n #include <string>\n #include <vector>\n #include <climits>\n using namespace std;\n \n int main()\n {\n     int t;\n     cin >> t;\n     for (int i = 0; i < t; i++) {\n         int n;\n         double c;\n         vector <double> a;\n         cin >> n;\n         for (int j = 0; j < n; j++) {\n             cin >> c;\n             a.push_back(c);\n         }\n         bool flag = true;\n         while (!a.empty()) {\n             double mn = 999999999999.0f;\n             int mni = 0;\n             flag = true;\n             for (int j = 0; j < a.size(); j++) {\n                 if (a[j] < mn) {\n                     mn = a[j];\n                     mni = j;\n                 }\n             }\n             for (int j = 0; j < mni; j++) {\n                 if (a[j] < a[j + 1]) {\n                     flag = false;\n                 }\n             }\n             if (!flag) {\n                 break;\n             }\n             for (int j = 0; j <= mni; j++) {\n                 a.erase(a.begin());\n             }\n         }\n \n         if (flag)\n             cout << 1 << endl;\n         else\n             cout << 0 << endl;\n     }\n }\n "~0
"#include <iostream>\n #include <fstream>\n #include <vector>\n #include <numeric>\n #include <algorithm>\n  \n using namespace std;\n  \n int main() {\n   size_t n;\n   vector<int> cards;\n   cin >> n;\n   cards.resize(n);\n   for (size_t i = 0; i < n; ++i)\n     cin >> cards[i];\n    \n   sort(cards.begin(), cards.end(), [](int a, int b) { return a > b; });\n   int player_sum = accumulate(cards.begin(), cards.begin()+n/2, 0);\n   int banker_sum = accumulate(cards.begin()+n/2, cards.end(), 0);\n   cout << player_sum-banker_sum;\n }\n "~1
"#include <string>\n #include <cmath>\n #include <algorithm>\n #include <vector>\n #include <iostream>\n #include <string>\n using namespace std;\n  \n int main()\n {\n     long long n, k, c = 3, s = 0;\n     cin >> n;\n     for (int i = 0; i < n; i++) {\n         cin >> k;\n         if (k == 1) {\n             s += c;\n             c++;\n         }\n         else {\n             c -= 3;\n             if (c < 3) c = 3;\n         }\n     }\n     cout << s;\n }\n "~0
"#include <iostream>\n #include <iomanip>\n #include <set>\n #include <string>\n #include <vector>\n #include <unordered_map>\n using namespace std;\n #define hashmap unordered_map\n  \n int main()\n {\n     int n, m;\n     cin >> n >> m;\n     vector <vector<int>> a(n, vector <int>(m));\n     vector <vector<int>> b(n, vector <int>(m));\n     for (int i = 0; i < n; i++) {\n         for (int j = 0; j < m; j++) {\n             cin >> a[i][j];\n         }\n     }\n     hashmap <int, int> p;\n     for (int i = 0; i < n; i++) {\n         for (int j = 0; j < m; j++) {\n             int c;\n             cin >> c;\n             b[i][j] = c;\n             if (c == a[i][j]) {\n                 cout << "NO";\n                 return 0;\n             }\n         }\n     }\n     for (int i = 0; i < n; i++) {\n         for (int j = 0; j < m; j++) {\n             p[a[i][j]] = a[i][j] - b[i][j];\n         }\n     }\n     for (int i = 0; i < n; i++) {\n         for (int j = 0; j < m; j++) {\n             if (b[i][j] + p[a[i][j]] != a[i][j]) {\n                 cout << "NO";\n                 return 0;\n             }\n         }\n     }\n     cout << "YES";\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <algorithm>\n #include <unordered_map>\n using namespace std;\n #define ll long long\n int main() {\n 	int n, k;\n 	cin >> n >> k;\n 	cout << n + (n - 1) / (k - 1);\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <algorithm>\n #include <unordered_map>\n using namespace std;\n int main() {\n 	string s;\n 	cin >> s;\n 	int i = 0, j = s.size() - 1, c = 0;\n 	while (true) {\n 		if (i >= j) {\n 			break;\n 		}\n \n 		if (s[i] == s[j]) {\n 			c++;\n 		}\n \n 		i++;\n 		j--;\n 	}\n 	cout << s.size() - c * 2;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <algorithm>\n #include <unordered_map>\n using namespace std;\n #define ll long long\n int main() {\n 	int t;\n 	cin >> t;\n 	for (int i = 0; i < t; i++) {\n 		int a, b, c, d;\n 		cin >> a >> b >> c >> d;\n 		if (min(a, c) >= min(b, d)) {\n 			cout << "Gellyfish" << endl;\n 		}\n 		else {\n 			cout << "Flower" << endl;\n 		}\n 	}\n }\n "~0
"#include <bits/stdc++.h> \n using namespace std;\n #define int int64_t\n const int inf = 1e18;\n  \n signed main() {\n     string a, b;\n     cin >> a >> b;\n     int n = int(a.size()), m = int(b.size());\n     vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\n     vector<int> ans;\n     for (int i = 0; i <= n; i++) {\n         dp[i][0] = i;\n     }\n     for (int i = 0; i <= m; i++) {\n         dp[0][i] = i;\n     }\n     for (int i = 1; i < n + 1; i++) {\n         for (int j = 1; j < m + 1; j++) {\n             if (a[i - 1] == b[j - 1]) {\n                 dp[i][j] = dp[i - 1][j - 1];\n                 //cout << i << " " << j << "\n ";\n             }\n             else {\n                 dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));\n             }\n         }\n     }\n     cout << dp[n][m] << "\n ";\n }\n "~0
"#include <bits/stdc++.h>\n  \n using namespace std;\n  \n #define int int64_t\n  \n const int inf = 1e18;\n  \n signed main() {\n     int n, m;\n     cin >> n >> m;\n     vector<int> w(n), c(n);\n     for (int i = 0; i < n; i++) {\n         cin >> w[i];\n     }\n     for (int i = 0; i < n; i++) {\n         cin >> c[i];\n     }\n     vector<vector<int>> dp(n + 1, vector<int> (m + 1, 0));\n     for (int i = 1; i <= n; i++) {\n         for (int j = 1; j <= m; j++) {\n             int x;\n             if (j < w[i - 1] || (dp[i - 1][j - w[i - 1]] == 0 and j - w[i - 1] != 0)) {\n                 x = 0;\n             }\n             else {\n                 x = dp[i - 1][j - w[i - 1]] + c[i - 1];\n             }\n             dp[i][j] = max(dp[i - 1][j], x);\n         }\n     }\n     int i = n, j;\n     int mx = 0;\n     for (int k = 0; k <= m; k++) {\n         if (dp[n][k] > mx) {\n             mx = dp[n][k];\n             j = k;\n         }\n     }\n     vector<int> ans;\n     while (i > 0 && j > 0) {\n         if (dp[i][j] == dp[i - 1][j]) {\n             i--;\n         }\n         else {\n             ans.push_back(i);\n             j -= w[i - 1];\n             i--;\n         }\n     }\n     cout << int(ans.size()) << "\n ";\n     for (int i : ans) {\n         cout << i << " ";\n     }\n }\n "~0
"#include <bits/stdc++.h>\n using namespace std;\n #define int int64_t\n const int inf = 1e18;\n \n signed main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; i++) {\n         cin >> a[i];\n     }\n     reverse(a.begin(), a.end());\n     vector<int> dp(n + 1, inf), ind(n + 1), p(n);\n     dp[0] = -inf;\n     ind[0] = -1;\n     p[0] = -1;\n     for (int i = 0; i < n; i++) {\n         int x = upper_bound(dp.begin(), dp.end(), a[i]) - dp.begin();\n         p[i] = ind[x - 1];\n         dp[x] = a[i];\n         ind[x] = i;\n     }\n     int x = n;\n     while (dp[x] == inf) {\n         x--;\n     }\n     cout << x << "\n ";\n     int cur = ind[x];\n     vector<int> ans;\n     while (p[cur] != -1) {\n         ans.push_back(cur);\n         cur = p[cur];\n     }\n     ans.push_back(cur);\n     //reverse(ans.begin(), ans.end());\n     for (int i : ans) {\n         cout << n - i << " ";\n     }\n }\n \n "~0
"#include <bits/stdc++.h>\n using namespace std;\n #define int int64_t\n const int inf = 1e18;\n \n signed main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     int s = 0;\n     for (int i = 0; i < n; i++) {\n         cin >> a[i];\n         s += a[i];\n     }\n     if (s % 2 != 0) {\n         cout << "NO";\n         return 0;\n     }\n     constexpr int sz = 1e6;\n     bitset<sz> b;\n     b[0] = 1;\n     for (int i = 0; i < n; i++) {\n         b |= (b<<a[i]);\n     }\n     cout << (b[s / 2] ? "YES" : "NO");\n }\n "~0
"#include <bits/stdc++.h>\n using namespace std;\n #define int int64_t\n #define double long double\n const int inf = 1e18;\n \n int op(int a, int b) {\n     return max(a, b);\n }\n  \n struct Segtree {\n     vector<int> t;\n     int c = 1;\n  \n     void build(vector<int> a) {\n         while (c < int(a.size())) {\n             c *= 2;\n         }\n         t.resize(c * 2, -inf);\n         for (int i = c; i < c + int(a.size()); i++) {\n             t[i] = a[i - c];\n         }\n         for (int i = c - 1; i > 0; i--) {\n             t[i] = op(t[i * 2], t[i * 2 + 1]);\n         }\n     }\n  \n     int get(int v, int ql, int qr, int l, int r, int x) {\n         //cout << l << " " << r << "\n ";\n         if (ql > r || l > qr) {\n             return -2;\n         }\n         if (ql <= l && r <= qr) {\n             if (t[v] < x) {\n                 return -2;\n             }\n             while (v < c) {\n                 if (t[2 * v] >= x) {\n                     v *= 2;\n                 }\n                 else {\n                     v = 2 * v + 1;\n                 }\n             }\n             return v - c;\n         }\n         int mid = (l + r) / 2;\n         int ans = get(v * 2, ql, qr, l, mid, x);\n         if (ans != -2) {\n             return ans;\n         }\n         return get(v * 2 + 1, ql, qr, mid + 1, r, x);\n     }\n  \n     void update(int i, int x) {\n         i += c;\n         t[i] = x;\n         while (i > 1) {\n             i /= 2;\n             t[i] = op(t[i * 2], t[i * 2 + 1]);\n         }\n     }\n };\n \n signed main() {\n     int n, m;\n     cin >> n >> m;\n     vector<int> a(n);\n     for (int i = 0; i < n; i++) {\n         cin >> a[i];\n     }\n     Segtree seg;\n     seg.build(a);\n     for (int i = 0; i < m; i++) {\n         int t;\n         cin >> t;\n         if (t) {\n             int j, x;\n             cin >> j >> x;\n             j--;\n             cout << seg.get(1, j, n - 1, 0, seg.c - 1, x) + 1 << "\n ";\n         }\n         else {\n             int j, x;\n             cin >> j >> x;\n             seg.update(j - 1, x);\n         }\n     }\n }\n "~0
"#include <bits/stdc++.h>\n using namespace std;\n #define int int64_t\n const int inf = 1e18;\n  \n int op(int a, int b) {\n     return max(a, b);\n }\n  \n struct Segtree {\n     vector<int> t;\n     int c = 1;\n  \n     void build(vector<int> a) {\n         while (c < int(a.size())) {\n             c *= 2;\n         }\n         t.resize(c * 2, -inf);\n         for (int i = c; i < c + int(a.size()); i++) {\n             t[i] = a[i - c];\n         }\n         for (int i = c - 1; i > 0; i--) {\n             t[i] = op(t[i * 2], t[i * 2 + 1]);\n         }\n     }\n  \n     int find_place(int x) {\n         int v = 1;\n         while (v < c) {\n             if (t[v * 2] < x) {\n                 v = v * 2 + 1;\n             }\n             else {\n                 v *= 2;\n             }\n         }\n         return v - c;\n     }\n  \n     void update(int i, int x) {\n         i += c;\n         t[i] = x;\n         while (i > 1) {\n             i /= 2;\n             t[i] = op(t[i * 2], t[i * 2 + 1]);\n         }\n     }\n };\n  \n signed main() {\n     int h, w, n;\n     cin >> h >> w >> n;\n     vector<int> a(min(n + 2, h), w);\n     Segtree seg;\n     seg.build(a);\n     for (int i = 0; i < n; i++) {\n         int x;\n         cin >> x;\n         int k = seg.find_place(x);\n         if (k < min(n + 2, h)) {\n             cout << k + 1 << "\n ";\n             a[k] -= x;\n             seg.update(k, a[k]);\n         }\n         else {\n             cout << "-1\n ";\n         }\n     }\n }\n \n "~0
"#include <iostream>\n #include <vector>\n #include <map>\n #include <string>\n #include <algorithm>\n #include <cmath>\n #include <iomanip>\n #include <stack>\n #include <set>\n #include <deque>\n using namespace std;\n typedef long long ll;\n typedef long double ld;\n const int INF = 1e9;\n int main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(NULL);\n 	cout.tie(NULL);\n 	int n1, n2, n3, n4, ot = INF, bo = -1, bo1 = -1, bo2 = -1, bo3 = -1;\n 	cin >> n1;\n 	vector <int> a(n1);\n 	for (int i = 0; i < n1; i++) {\n 		cin >> a[i];\n 	}\n 	sort(a.begin(), a.end());\n 	cin >> n2;\n 	vector <int> a1(n2);\n 	for (int i = 0; i < n2; i++) {\n 		cin >> a1[i];\n 	}\n 	sort(a1.begin(), a1.end());\n 	cin >> n3;\n 	vector <int> a2(n3);\n 	for (int i = 0; i < n3; i++) {\n 		cin >> a2[i];\n 	}\n 	sort(a2.begin(), a2.end());\n 	cin >> n4;\n 	vector <int> a3(n4);\n 	for (int i = 0; i < n4; i++) {\n 		cin >> a3[i];\n 	}\n 	sort(a3.begin(), a3.end());\n 	int i1 = 0, i2 = 0, i3 = 0, i4 = 0, maa, mia;\n 	while (i1 < n1 and i2 < n2 and i3 < n3 and i4 < n4) {\n 		maa = max(a[i1], max(a1[i2], max(a2[i3], a3[i4])));\n 		mia = min(a[i1], min(a1[i2], min(a2[i3], a3[i4])));\n 		if (maa - mia < ot) {\n 			ot = maa - mia;\n 			bo = a[i1];\n 			bo1 = a1[i2];\n 			bo2 = a2[i3];\n 			bo3 = a3[i4];\n 		}\n 		if (a[i1] == mia) {\n 			i1++;\n 		}\n 		else if (a1[i2] == mia) {\n 			i2++;\n 		}\n 		else if (a2[i3] == mia) {\n 			i3++;\n 		}\n 		else {\n 			i4++;\n 		}\n 		if (maa - mia < ot) {\n 			ot = maa - mia;\n 			bo = a[i1];\n 			bo1 = a1[i2];\n 			bo2 = a2[i3];\n 			bo3 = a3[i4];\n 		}\n 	}\n 	cout << bo << ' ' << bo1 << ' ' << bo2 << ' ' << bo3;\n }\n "~0
"#include <iostream>\n #include <vector>\n #include <map>\n #include <string>\n #include <algorithm>\n #include <cmath>\n #include <iomanip>\n #include <set>\n #include <deque>\n using namespace std;\n typedef long long ll;\n typedef long double ld;\n const int INF = 2e9;\n int main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(NULL);\n 	cout.tie(NULL);\n 	int n, t, x = 0;\n 	cin >> n >> t;\n 	vector <int> a(n), b;\n 	for (int i = 0; i < n; i++) {\n 		cin >> a[i];\n 		if (i < t) {\n 			x += a[i];\n 		}\n 	}\n 	b.push_back(x);\n 	for (int i = 0; i < n - t; i++) {\n 		x -= a[i];\n 		x += a[i + t];\n 		b.push_back(x);\n 	}\n 	int ot = INF, mn = b[0];\n 	for (int i = t + 1; i < b.size(); i++) {\n 		mn = min(mn, b[i - t - 1]);\n 		ot = min(ot, mn + b[i]);\n 	}\n 	cout << ot;\n }\n "~0
"#include <iostream>\n #include <vector>\n #include <map>\n #include <string>\n #include <algorithm>\n #include <set>\n #include <deque>\n using namespace std;\n typedef long long ll;\n const ll INF = 1e16;\n int main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(NULL);\n 	cout.tie(NULL);\n 	int n;\n 	cin >> n;\n 	set <ll> a, b = {2, 3, 5};\n 	a.insert(2);\n 	a.insert(3);\n 	a.insert(5);\n 	ll mn, el, el1, el2, g;\n 	for (int i = 0; i < n; i++) {\n 		el = *a.begin();\n 		a.insert(el * 2);\n 		a.insert(el * 3);\n 		a.insert(el * 5);\n 		b.insert(el * 2);\n 		b.insert(el * 3);\n 		b.insert(el * 5);\n 		a.erase(el);\n 	}\n 	for (int i = 0; i < n; i++) {\n 		cout << *b.begin() << ' ';\n 		b.erase(b.begin());\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <algorithm>\n #include <vector>\n #include <map>\n #include <string>\n #include <set>\n #include <queue>\n #include <deque>\n #include <unordered_map>\n //#include <bits/stdc++.h>\n #define int long long\n //#define double long double\n using namespace std;\n \n const long long mod = 1e18;\n \n signed main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n     cout.tie(nullptr);\n     int x, y, l, r;\n     cin >> x >> y >> l >> r;\n     int a = 1;\n     vector<int> A;\n     while (a <= r) {\n         int b = 1;\n         while (b <= r) {\n             A.push_back(a + b);\n             if (b > mod / y)\n                 break;\n             b *= y;\n         }\n         if (a > mod / x)\n             break;\n         a *= x;\n     }\n     A.push_back(l - 1);\n     A.push_back(r + 1);\n     sort(A.begin(), A.end());\n     int ans = 0;\n     for (int i = 0; i < A.size() - 1; i++) {\n         if (A[i] + 1 >= l && A[i + 1] - 1 <= r) {\n             ans = max(ans, A[i + 1] - A[i] - 1);\n         }\n     }\n     cout << ans << endl;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <algorithm>\n #include <vector>\n #include <map>\n #include <string>\n #include <set>\n #include <queue>\n #include <deque>\n #define int long long\n //#pragma GCC optimize("O3")\n using namespace std;\n \n const long long mod = 1'000'000'007;\n \n signed main() {\n     //ios_base::sync_with_stdio(false);\n     //cin.tie(nullptr);\n     //cout.tie(nullptr);\n     int n;\n     cin >> n;\n     map<string, set<string>> A;\n     map<string, set<string>> B;\n     for (int i = 0; i < n; i++) {\n         string a;\n         char _;\n         cin >> a >> _;\n         string b;\n         cin >> b;\n         while (true) {\n             if (b[b.size() - 1] == ',') {\n                 b.erase(b.size() - 1);\n                 A[a].insert(b);\n \n                 B[b].insert(a);\n \n                 cin >> b;\n             } else {\n                 A[a].insert(b);\n \n                 B[b].insert(a);\n \n                 break;\n             }\n         }\n     }\n     int res = 0;\n     for (auto i : B)\n         res++;\n     cout << res << endl;\n     for (auto i : B) {\n         cout << i.first << " - ";\n         int cnt = (i.second).size();\n         int num = 1;\n         for (auto g : i.second) {\n             cout << g;\n             if (num != cnt)\n                 cout << ", ";\n             num++;\n         }\n         cout << endl;\n     }\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <algorithm>\n #include <vector>\n #include <map>\n #include <string>\n #include <set>\n #include <queue>\n #include <deque>\n #include <unordered_map>\n #include <stack>\n //#include <bits/stdc++.h>\n #define int long long\n //#define double long double\n //#define __int128 long long\n using namespace std;\n \n const long long mod = 1e9 + 7;\n const long long INF = 1e18;\n /*\n 6\n 1 4 5 6 7 2\n 14\n  */\n signed main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n     cout.tie(nullptr);\n     string s;\n     cin >> s;\n     int n = s.size();\n     int m;\n     cin >> m;\n     vector<string> A(m);\n     for (int i = 0; i < m; i++) {\n         cin >> A[i];\n     }\n     vector<int> dp(n, -1);\n     for (int i = 0; i < n; i++) {\n         for (int g = 0; g < m; g++) {\n             if (A[g].size() < i + 1) {\n                 if (dp[i - A[g].size()] != -1 && s.substr(i - A[g].size() + 1, A[g].size()) == A[g])\n                     dp[i] = g;\n             }\n             else if (A[g].size() == i + 1) {\n                 if (s.substr(i - A[g].size() + 1, A[g].size()) == A[g])\n                     dp[i] = g;\n             }\n         }\n     }\n     vector<int> ANS;\n     int v = n - 1;\n     while (v != -1) {\n         ANS.push_back(dp[v]);\n         v -= A[dp[v]].size();\n     }\n     for (int i = ANS.size() - 1; i >= 0; i--) {\n         cout << A[ANS[i]] << ' ';\n     }\n     cout << endl;\n }\n "~0
"#include <iostream>\n #include <vector>\n #include <string>\n #include <algorithm>\n \n using namespace std;\n \n vector<string> splitText(const string& text, const vector<string>& dict) {\n     int n = text.size();\n     vector<bool> dp(n + 1, false);\n     dp[0] = true;\n \n     vector<string> lw(n + 1);\n \n     for (int i = 1; i <= n; ++i) {\n         for (const string& word : dict) {\n             int word_len = word.size();\n             if (i >= word_len && dp[i - word_len] &&\n                 text.substr(i - word_len, word_len) == word) {\n                 dp[i] = true;\n                 lw[i] = word;\n                 break;\n             }\n         }\n     }\n \n     vector<string> res;\n     int i = n;\n     while (i > 0) {\n         string word = lw[i];\n         res.push_back(word);\n         i -= word.size();\n     }\n \n     reverse(res.begin(), res.end());\n     return res;\n }\n \n int main() {\n     string text;\n     cin >> text;\n \n     int N;\n     cin >> N;\n     vector<string> dict(N);\n     for (int i = 0; i < N; ++i) {\n         cin >> dict[i];\n     }\n \n     vector<string> w = splitText(text, dict);\n     for (size_t i = 0; i < w.size(); ++i) {\n         if (i != 0) cout << " ";\n         cout << w[i];\n     }\n     cout << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <climits>\n \n using namespace std;\n \n vector<int> min_b(const vector<int>& denominations, int S) {\n     vector<int> dp(S + 1, INT_MAX);\n     vector<int> last(S + 1, -1);\n     dp[0] = 0;\n \n     for (int i = 1; i <= S; ++i) {\n         for (int d : denominations) {\n             if (i >= d && dp[i - d] != INT_MAX && dp[i - d] + 1 < dp[i]) {\n                 dp[i] = dp[i - d] + 1;\n                 last[i] = d;\n             }\n         }\n     }\n \n     vector<int> result;\n     if (dp[S] == INT_MAX) {\n         return result;\n     }\n \n     int current = S;\n     while (current > 0) {\n         result.push_back(last[current]);\n         current -= last[current];\n     }\n \n     return result;\n }\n \n int main() {\n     int N;\n     cin >> N;\n \n     vector<int> denomination(N);\n     for (int i = 0; i < N; ++i) {\n         cin >> denomination[i];\n     }\n \n     int S;\n     cin >> S;\n \n     vector<int> result = min_b(denomination, S);\n \n     if (result.empty()) {\n         cout << -1 << endl;\n     } else {\n         cout << result.size() << endl;\n         for (int i = 0; i < result.size(); ++i) {\n             if (i != 0) cout << " ";\n             cout << result[i];\n         }\n         cout << endl;\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <queue>\n #include <climits>\n \n using namespace std;\n \n int main() {\n     int m, n;\n     cin >> m >> n;\n     vector<string> grid(m);\n     pair<int, int> start, end;\n     for (int i = 0; i < m; ++i) {\n         cin >> grid[i];\n         for (int j = 0; j < n; ++j) {\n             if (grid[i][j] == 'S') {\n                 start = { i, j };\n             }\n             else if (grid[i][j] == 'F') {\n                 end = { i, j };\n             }\n         }\n     }\n \n     vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\n     queue<pair<int, int>> q;\n     q.push(start);\n     dist[start.first][start.second] = 0;\n \n     int dx[] = { -1, 1, 0, 0 };\n     int dy[] = { 0, 0, -1, 1 };\n \n     while (!q.empty()) {\n         auto current = q.front();\n         q.pop();\n         int x = current.first;\n         int y = current.second;\n         if (x == end.first && y == end.second) {\n             cout << dist[x][y] << endl;\n             return 0;\n         }\n         for (int i = 0; i < 4; ++i) {\n             int nx = x + dx[i];\n             int ny = y + dy[i];\n             while (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] != 'K') {\n                 if (dist[nx][ny] > dist[x][y] + 1) {\n                     dist[nx][ny] = dist[x][y] + 1;\n                     q.push({ nx, ny });\n                 }\n                 else if (dist[nx][ny] < dist[x][y] + 1) {\n                     break;\n                 }\n                 nx += dx[i];\n                 ny += dy[i];\n             }\n         }\n     }\n \n     cout << -1 << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n \n using namespace std;\n \n int main() {\n     int n, w, p;\n     cin >> n >> w >> p;\n     int total_equipment = n * (w - p);\n     cout << total_equipment << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n \n using namespace std;\n \n struct chip {\n     int x, y, index;\n     int distance;\n };\n \n bool compareChips(const chip& a, const chip& b) {\n     return a.distance < b.distance;\n }\n \n int main() {\n     int n;\n     cin >> n;\n     vector<chip> chips(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> chips[i].x >> chips[i].y;\n         chips[i].index = i + 1;\n         chips[i].distance = max(abs(chips[i].x), abs(chips[i].y));\n     }\n \n     sort(chips.begin(), chips.end(), compareChips);\n \n     for (int i = 0; i < n; ++i) {\n         if (chips[i].distance <= i + 1) {\n             cout << -1 << endl;\n             return 0;\n         }\n     }\n \n     for (int i = 0; i < n; ++i) {\n         cout << chips[i].index << " ";\n     }\n     cout << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <string>\n \n using namespace std;\n \n int main() {\n     string s;\n     cin >> s;\n     long long countT = 0, countTE = 0, countTEN = 0, countTENT = 0;\n \n     for (char c : s) {\n         if (c == 'T') {\n             countT++;\n             countTENT += countTEN;\n         }\n         else if (c == 'E') {\n             countTE += countT;\n         }\n         else if (c == 'N') {\n             countTEN += countTE;\n         }\n     }\n \n     cout << countTENT << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <algorithm>\n \n using namespace std;\n \n long long gcd(long long a, long long b) {\n     while (b != 0) {\n         long long temp = b;\n         b = a % b;\n         a = temp;\n     }\n     return a;\n }\n \n bool isFiniteDecimal(long long denominator) {\n     while (denominator % 2 == 0) {\n         denominator /= 2;\n     }\n     while (denominator % 5 == 0) {\n         denominator /= 5;\n     }\n     return denominator == 1;\n }\n \n int main() {\n     long long a, b, c;\n     cin >> a >> b >> c;\n \n     long long numerator, denominator, integerPart;\n \n     denominator = c;\n \n     if (b < c && gcd(b, c) == 1 && isFiniteDecimal(c / gcd(b, c))) {\n         numerator = b;\n         integerPart = a;\n     }\n     else if (a < c && gcd(a, c) == 1 && isFiniteDecimal(c / gcd(a, c))) {\n         numerator = a;\n         integerPart = b;\n     }\n     else {\n         return 0;\n     }\n \n     cout << integerPart << endl;\n     cout << numerator << endl;\n     cout << denominator << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <algorithm>\n \n using namespace std;\n \n long long calc(long long n, long long a, long long b, long long k) {\n     long long paying = n - k;\n     long long grant = k * (2 * b - k + 1) / 2;\n     return a * paying + grant;\n }\n \n int main() {\n     long long n, a, b;\n     cin >> n >> a >> b;\n \n     long long max_k = min(b, n);\n     long long optimal_k = min(max_k, max(0LL, b - a + 1));\n \n     long long profit1 = calc(n, a, b, optimal_k);\n     long long profit2 = calc(n, a, b, optimal_k + 1);\n     long long profit3 = calc(n, a, b, optimal_k - 1);\n \n     long long max_profit = max({ profit1, profit2, profit3 });\n \n     cout << max_profit << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n void solve() {\n     int n;\n     cin >> n;\n     vector<int> perm(n);\n     int left = 1, right = n;\n     for (int i = 0; i < n; ++i) {\n         if (i % 2 == 0) {\n             perm[i] = left++;\n         } else {\n             perm[i] = right--;\n         }\n     }\n     for (int i = 0; i < n; ++i) {\n         cout << perm[i] << " ";\n     }\n     cout << endl;\n }\n \n int main() {\n     int t;\n     cin >> t;\n     while (t--) {\n         solve();\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n void solve() {\n     int n;\n     cin >> n;\n     vector<long long> a(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n     }\n     \n     if (n == 1) {\n         cout << "YES" << endl;\n         return;\n     }\n     \n     long long x_num = a[0] * 1 - a[n-1] * n;\n     long long y_num = a[n-1] * 1 - a[0] * n;\n     long long denom = 1 - n * n;\n     \n     if (denom == 0) {\n         cout << "NO" << endl;\n         return;\n     }\n     \n     if (x_num % denom != 0 || y_num % denom != 0) {\n         cout << "NO" << endl;\n         return;\n     }\n     \n     long long x = x_num / denom;\n     long long y = y_num / denom;\n     \n     if (x < 0 || y < 0) {\n         cout << "NO" << endl;\n         return;\n     }\n     \n     for (int i = 1; i < n - 1; ++i) {\n         long long total = x * (i + 1) + y * (n - i);\n         if (total != a[i]) {\n             cout << "NO" << endl;\n             return;\n         }\n     }\n     \n     cout << "YES" << endl;\n }\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n     \n     int t;\n     cin >> t;\n     while (t--) {\n         solve();\n     }\n     \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <climits>\n #include <cmath>\n \n using namespace std;\n \n void solve() {\n     int N, K;\n     cin >> N >> K;\n     vector<int> A(N);\n     for (int i = 0; i < N; ++i) {\n         cin >> A[i];\n     }\n \n     // Compute prefix sums\n     vector<long long> prefix_sum(N + 1, 0);\n     for (int i = 0; i < N; ++i) {\n         prefix_sum[i + 1] = prefix_sum[i] + A[i];\n     }\n \n     int logK = log2(K) + 1;\n     vector<vector<int>> st(logK, vector<int>(N));\n     st[0] = A;\n     for (int j = 1; j < logK; ++j) {\n         for (int i = 0; i + (1 << j) <= N; ++i) {\n             st[j][i] = min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);\n         }\n     }\n \n     auto get_min = [&](int l, int r) {\n         int len = r - l + 1;\n         int k = log2(len);\n         return min(st[k][l], st[k][r - (1 << k) + 1]);\n         };\n \n     vector<long long> tower_value(N - K + 1);\n     for (int i = 0; i <= N - K; ++i) {\n         long long sum = prefix_sum[i + K] - prefix_sum[i];\n         int min_val = get_min(i, i + K - 1);\n         tower_value[i] = sum * min_val;\n     }\n \n     vector<long long> dp(N + 1, 0);\n     vector<bool> take(N + 1, false);\n     for (int i = 1; i <= N; ++i) {\n         if (i >= K) {\n             if (dp[i - K] + tower_value[i - K] > dp[i - 1]) {\n                 dp[i] = dp[i - K] + tower_value[i - K];\n                 take[i] = true;\n             }\n             else {\n                 dp[i] = dp[i - 1];\n                 take[i] = false;\n             }\n         }\n         else {\n             dp[i] = dp[i - 1];\n             take[i] = false;\n         }\n     }\n \n     vector<int> towers;\n     int i = N;\n     while (i > 0) {\n         if (take[i]) {\n             towers.push_back(i - K + 1);\n             i -= K;\n         }\n         else {\n             i -= 1;\n         }\n     }\n     reverse(towers.begin(), towers.end());\n \n     cout << towers.size() << endl;\n     for (int pos : towers) {\n         cout << pos << " ";\n     }\n     cout << endl;\n }\n \n int main() {\n     ios::sync_with_stdio(false);\n     cin.tie(nullptr);\n     solve();\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <string>\n #include <unordered_map>\n \n using namespace std;\n \n struct TrieNode {\n     unordered_map<char, TrieNode*> children;\n     int count;\n     TrieNode() : count(0) {}\n };\n \n void insert(TrieNode* root, const string& word) {\n     TrieNode* node = root;\n     for (char c : word) {\n         if (node->children.find(c) == node->children.end()) {\n             node->children[c] = new TrieNode();\n         }\n         node = node->children[c];\n         node->count++;\n     }\n }\n \n int findMinimalUniquePrefix(TrieNode* root, const string& word) {\n     TrieNode* node = root;\n     for (int i = 0; i < word.size(); ++i) {\n         char c = word[i];\n         node = node->children[c];\n         if (node->count == 1) {\n             return i + 1;\n         }\n     }\n     return word.size();\n }\n \n int main() {\n     ios::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n, k;\n     cin >> n >> k;\n     vector<string> words(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> words[i];\n     }\n \n     TrieNode* root = new TrieNode();\n     for (const string& word : words) {\n         insert(root, word);\n     }\n \n     for (const string& word : words) {\n         int len = findMinimalUniquePrefix(root, word);\n         cout << word.substr(0, len) << '\n ';\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <stack>\n #include <set>\n \n using namespace std;\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n;\n     cin >> n;\n     stack<int> levels;\n     set<int> rings;\n     int curr = 0;\n     levels.push(curr);\n     rings.insert(curr);\n \n     for (int i = 0; i < n; ++i) {\n         char op;\n         int x;\n         cin >> op >> x;\n         if (op == '+') {\n             curr += x;\n             levels.push(curr);\n             rings.insert(curr);\n         }\n         else {\n             curr -= x;\n             while (!levels.empty() && levels.top() > curr) {\n                 rings.erase(levels.top());\n                 levels.pop();\n             }\n             if (levels.empty() || levels.top() < curr) {\n                 levels.push(curr);\n                 rings.insert(curr);\n             }\n         }\n     }\n \n     cout << rings.size() << '\n ';\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <climits>\n \n using namespace std;\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n;\n     cin >> n;\n     vector<pair<int, int>> sellers(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> sellers[i].first >> sellers[i].second;\n     }\n \n     long long total = 0;\n     vector<int> mod1;\n     vector<int> mod2;\n \n     for (int i = 0; i < n; ++i) {\n         int a = sellers[i].first;\n         int b = sellers[i].second;\n         if (a > b) {\n             total += a;\n             int diff = a - b;\n             if (diff % 3 == 1) {\n                 mod1.push_back(diff);\n             } else if (diff % 3 == 2) {\n                 mod2.push_back(diff);\n             }\n         } else {\n             total += b;\n             int diff = b - a;\n             if (diff % 3 == 1) {\n                 mod1.push_back(diff);\n             } else if (diff % 3 == 2) {\n                 mod2.push_back(diff);\n             }\n         }\n     }\n \n     if (total % 3 == 0) {\n         sort(mod1.begin(), mod1.end());\n         sort(mod2.begin(), mod2.end());\n \n         int option1 = INT_MAX;\n         int option2 = INT_MAX;\n \n         if (mod1.size() >= 1) {\n             option1 = mod1[0];\n         }\n         if (mod2.size() >= 2) {\n             option2 = mod2[0] + mod2[1];\n         }\n \n         if (option1 != INT_MAX || option2 != INT_MAX) {\n             int min_diff = min(option1, option2);\n             total -= min_diff;\n         }\n     }\n \n     cout << total << '\n ';\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <queue>\n #include <climits>\n \n using namespace std;\n \n int getType(char c) {\n     if (c >= 'a' && c <= 'z') return 0;\n     if (c >= 'A' && c <= 'Z') return 1;\n     if (c >= '0' && c <= '9') return 2;\n     return -1; // Shouldn't happen as per problem statement\n }\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n, k;\n     cin >> n >> k;\n     string S;\n     cin >> S;\n \n     vector<int> type(n);\n     for (int i = 0; i < n; ++i) {\n         type[i] = getType(S[i]);\n     }\n \n     if (type[0] != type[n - 1]) {\n         cout << -1 << '\n ';\n         return 0;\n     }\n \n     vector<int> dist(n, INT_MAX);\n     dist[0] = 0;\n     queue<int> q;\n     q.push(0);\n \n     while (!q.empty()) {\n         int current = q.front();\n         q.pop();\n \n         if (current == n - 1) {\n             break;\n         }\n \n         int start = min(current + 1, n - 1);\n         int end = min(current + k, n - 1);\n \n         for (int next = start; next <= end; ++next) {\n             if (type[next] == type[current] && dist[next] == INT_MAX) {\n                 dist[next] = dist[current] + 1;\n                 q.push(next);\n             }\n         }\n     }\n \n     if (dist[n - 1] == INT_MAX) {\n         cout << -1 << '\n ';\n     } else {\n         cout << dist[n - 1] << '\n ';\n     }\n \n     return 0;\n }\n "~1
"#include <bits/stdc++.h>\n using namespace std;\n \n const int MOD = 1e9 + 7;\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n     }\n \n     vector<int> prefix(n + 1, 1);\n     for (int i = 0; i < n; ++i) {\n         prefix[i + 1] = (1LL * prefix[i] * a[i]) % MOD;\n     }\n \n     vector<int> suffix(n + 1, 1);\n     for (int i = n - 1; i >= 0; --i) {\n         suffix[i] = (1LL * suffix[i + 1] * a[i]) % MOD;\n     }\n \n     map<int, vector<int>> value_positions;\n     for (int i = 0; i < n; ++i) {\n         value_positions[a[i]].push_back(i);\n     }\n \n     long long total = 0;\n \n     for (int i = 0; i < n; ++i) {\n         int x = a[i];\n         const auto& positions = value_positions[x];\n         auto it = lower_bound(positions.begin(), positions.end(), i);\n         int pos_in_list = it - positions.begin();\n \n         int prev_pos = (pos_in_list > 0) ? positions[pos_in_list - 1] : -1;\n         int next_pos = (pos_in_list + 1 < positions.size()) ? positions[pos_in_list + 1] : n;\n \n         int left_start = prev_pos + 1;\n         int left_end = i;\n         int right_start = i;\n         int right_end = next_pos - 1;\n \n         int left_count = i - left_start + 1;\n         int right_count = right_end - i + 1;\n \n         long long subarrays = 1LL * left_count * right_count % MOD;\n         \n         auto mod_inv = [](int a, int mod) {\n             int res = 1;\n             int power = mod - 2;\n             while (power > 0) {\n                 if (power % 2 == 1) {\n                     res = (1LL * res * a) % mod;\n                 }\n                 a = (1LL * a * a) % mod;\n                 power /= 2;\n             }\n             return res;\n         };\n \n         int left_product = prefix[i + 1];\n         if (left_start > 0) {\n             int inv_prefix_left_start = mod_inv(prefix[left_start], MOD);\n             left_product = (1LL * left_product * inv_prefix_left_start) % MOD;\n         }\n \n         int right_product = suffix[i];\n         if (right_end + 1 < n) {\n             int inv_suffix_right_end_plus_1 = mod_inv(suffix[right_end + 1], MOD);\n             right_product = (1LL * right_product * inv_suffix_right_end_plus_1) % MOD;\n         }\n \n         int split = (left_product + right_product) % MOD;\n         total = (total + 1LL * split * subarrays) % MOD;\n     }\n \n     cout << total << '\n ';\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <utility>\n #include <string>\n \n using namespace std;\n \n int main() {\n     string s;\n     cin >> s;\n     int n = s.size();\n \n     vector<int> freq(26, 0);\n     for (char c : s) {\n         freq[c - 'a']++;\n     }\n \n     vector<pair<int, char>> freq_chars;\n     for (int i = 0; i < 26; ++i) {\n         if (freq[i] > 0) {\n             freq_chars.emplace_back(freq[i], 'a' + i);\n         }\n     }\n \n     sort(freq_chars.rbegin(), freq_chars.rend());\n \n     if (freq_chars.size() == 1) {\n         cout << 0 << endl;\n         cout << s << endl;\n         return 0;\n     }\n \n     char a = freq_chars[0].second;\n     char b = freq_chars[1].second;\n \n     string res;\n     for (int i = 0; i < n; ++i) {\n         if (i % 2 == 0) {\n             res += a;\n         }\n         else {\n             res += b;\n         }\n     }\n \n     int rename_count = 0;\n     for (int i = 0; i < n; ++i) {\n         if (s[i] != res[i]) {\n             rename_count++;\n         }\n     }\n \n     string single_char(n, a);\n     int single_rename = 0;\n     for (int i = 0; i < n; ++i) {\n         if (s[i] != a) {\n             single_rename++;\n         }\n     }\n \n     if (single_rename < rename_count) {\n         rename_count = single_rename;\n         res = single_char;\n     }\n \n     cout << rename_count << endl;\n     cout << res << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <cmath>\n \n using namespace std;\n \n long long find_min_k(long long n) {\n     if (n == 1) {\n         return 1;\n     }\n     // Check if n is even\n     if (n % 2 == 0) {\n         return 2;\n     }\n     for (long long i = 3; i <= sqrt(n); i += 2) {\n         if (n % i == 0) {\n             return i;\n         }\n     }\n     // If no divisors found, n is prime\n     return 1;\n }\n \n int main() {\n     long long n;\n     cin >> n;\n     cout << find_min_k(n) << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <string>\n #include <algorithm>\n \n using namespace std;\n \n int custom_add(int a, int b) {\n     string s1 = to_string(a);\n     string s2 = to_string(b);\n     string res = s1 + s2;\n     return stoi(res);\n }\n \n int main() {\n     int A, B;\n     cin >> A >> B;\n \n     int AB = custom_add(A, B);\n     int BA = custom_add(B, A);\n \n     cout << max(AB, BA) << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n int main() {\n     int N;\n     cin >> N;\n \n     vector<vector<int>> dp(N + 1, vector<int>(N + 1, 0));\n     dp[0][0] = 1;\n \n     for (int k = 1; k <= N; ++k) {\n         for (int m = 1; m <= N; ++m) {\n             if (k >= m) {\n                 dp[k][m] = dp[k][m - 1] + dp[k - m][m - 1];\n             } else {\n                 dp[k][m] = dp[k][m - 1];\n             }\n         }\n     }\n \n     cout << dp[N][N] << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n using namespace std;\n \n void reverseSequence() {\n     int num;\n     cin >> num;\n     if (num != 0) {\n         reverseSequence();\n         cout << num << endl;\n     } else {\n         cout << num << endl;\n     }\n }\n \n int main() {\n     reverseSequence();\n     return 0;\n }\n "~1
"#include <iostream>\n #include <cctype>\n #include <string>\n using namespace std;\n \n string capital(const string &s) {\n     string result;\n     bool newWord = true;\n     for (char c : s) {\n         if (isalpha(c)) {\n             if (newWord) {\n                 result += toupper(c);\n                 newWord = false;\n             } else {\n                 result += tolower(c);\n             }\n         } else {\n             result += c;\n             newWord = true;\n         }\n     }\n     return result;\n }\n \n int main() {\n     string line;\n     getline(cin, line);\n     cout << capital(line) << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n \n using namespace std;\n \n int main() {\n     int N, M;\n     cin >> N >> M;\n \n     vector<vector<int>> grid(N, vector<int>(M));\n     for (int i = 0; i < N; ++i) {\n         for (int j = 0; j < M; ++j) {\n             cin >> grid[i][j];\n         }\n     }\n \n     vector<vector<int>> dp(N, vector<int>(M));\n     dp[0][0] = grid[0][0];\n \n     // Заполнение первой строки\n     for (int j = 1; j < M; ++j) {\n         dp[0][j] = dp[0][j-1] + grid[0][j];\n     }\n \n     // Заполнение первого столбца\n     for (int i = 1; i < N; ++i) {\n         dp[i][0] = dp[i-1][0] + grid[i][0];\n     }\n \n     // Заполнение остальной части таблицы\n     for (int i = 1; i < N; ++i) {\n         for (int j = 1; j < M; ++j) {\n             dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n         }\n     }\n \n     cout << dp[N-1][M-1] << endl;\n \n     // Восстановление маршрута\n     vector<char> path;\n     int i = N - 1, j = M - 1;\n     while (i > 0 || j > 0) {\n         if (i > 0 && (j == 0 || dp[i-1][j] >= dp[i][j-1])) {\n             path.push_back('D');\n             --i;\n         } else {\n             path.push_back('R');\n             --j;\n         }\n     }\n \n     // Вывод маршрута в обратном порядке\n     for (int k = path.size() - 1; k >= 0; --k) {\n         cout << path[k] << " ";\n     }\n     cout << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n \n using namespace std;\n \n int main() {\n     int n;\n     cin >> n;\n     int count = 0;\n     for (int i = 0; i < n; ++i) {\n         int num;\n         cin >> num;\n         if (num == 0) {\n             ++count;\n         }\n     }\n     cout << count << endl;\n     return 0;\n }\n "~1
