code~label
"\n n = int(input())\n a = list(map(int, input().split()))\n  \n l = [-1] * n\n st = []\n for i in range(n):\n     while st and a[st[-1]] <= a[i]:\n         st.pop()\n     l[i] = st[-1] if st else -1\n     st.append(i)\n  \n r = [n] * n\n st = []\n for i in range(n - 1, -1, -1):\n     while st and a[st[-1]] <= a[i]:\n         st.pop()\n     r[i] = st[-1] if st else n\n     st.append(i)\n     \n print(" ".join([str(r[i] - l[i] - 1) for i in range(n)]))\n"~0
"def calculate_sum(first_number, second_number):\n    result = first_number + second_number\n    return result"~1
"def compute_total(initial_value, increment):\n    total = initial_value + increment\n    return total"~1
"funcs = {}\n  \n def run_code(code):\n     if code != False:\n         #print('> called func')\n         code.append('endprg')\n     runpointer = 0\n     infunc = 0\n     currentwritingfunc = ""\n     while True:\n         curr_op = ""\n         if code == False:\n             curr_op = input()\n             #print("> running at input")\n         else:\n             curr_op = code[runpointer]\n             runpointer += 1\n         \n         if curr_op == "endprg": break\n  \n         if curr_op[0:8] == "function":\n             infunc += 1\n             currentwritingfunc = curr_op[9:len(curr_op)]\n             funcs[currentwritingfunc] = [1, []]\n             #print("> doing func", currentwritingfunc)\n             continue\n             \n         if curr_op[0:3] == "end":\n             infunc -= 1\n             continue\n             \n         if infunc > 0:\n             funcs[currentwritingfunc][1].append(curr_op)\n             #print('> wrote "'+curr_op+'" to '+currentwritingfunc)\n         else:\n             if curr_op[0:4] == "call":\n                 #print(funcs)\n                 run_code(funcs[curr_op[5:len(curr_op)]][1])\n                 continue\n             if curr_op[0:5] == "print":\n                 print(curr_op[6:len(curr_op)])\n                 continue\n             \n run_code(False)\n "~1
"n = int(input())\n a1 = list(map(int, input().split()))\n a2 = list(map(int, input().split()))\n a3 = list(map(int, input().split()))\n  \n a1p, a2p, a3p = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)\n  \n for i, v in enumerate(a1):\n     a1p[v] = i\n for i, v in enumerate(a2):\n     a2p[v] = i\n for i, v in enumerate(a3):\n     a3p[v] = i\n  \n def check(a, b):\n     count = 0\n     if a1p[a] < a1p[b]:\n         count += 1\n     if a2p[a] < a2p[b]:\n         count += 1\n     if a3p[a] < a3p[b]:\n         count += 1\n     return count >= 2\n     \n cand = 1\n for i in range(2, n + 1):\n     if check(i, cand):\n         cand = i\n  \n for j in range(1, n + 1):\n     if j == cand:\n         continue\n     if not check(cand, j):\n         print(-1)\n         exit(0)\n  \n print(cand)\n "~1
"n = int(input())\n a = list(map(int, input().split()))\n nuts = [i for i, x in enumerate(a) if x == 1]\n  \n     \n if not nuts:\n     print(0)\n else:\n     x = 1\n     for i in range(1, len(nuts)):\n         x *= (nuts[i] - nuts[i - 1])\n     print(x)\n "~1
"n = int(input())\n  \n k = n\n while True:\n     s = sum(int(d) for d in str(k))\n     if s != 0 and k % s == 0:\n         break\n     else:\n         k += 1\n print(k)\n "~0
"n = int(input())\n x = int(input())\n  \n n = n % 6\n  \n for i in range(n, 0, -1):\n     if i % 2 == 1:\n         if x == 0:\n             #print('l -> m')\n             x = 1\n         elif x == 1:\n             #print('m -> l')\n             x = 0\n     else:\n         if x == 1:\n             #print('m -> r')\n             x = 2\n         elif x == 2:\n             #print('r -> m')\n             x = 1\n print(x)\n "~0
"n, p, k = map(int, input().split())\n a, b, c = map(int, input().split())\n  \n pa = a - p\n pb = b - p\n pc = c - p\n  \n f = [\n     (pa, 'a'),\n     (pb, 'b'),\n     (pc, 'c')\n ]\n  \n f.sort(reverse=True, key=lambda x: x[0])\n  \n max_profit = 0\n os = n\n  \n for profit, name in f:\n     if os <= 0:\n         break\n     m = min(k, os)\n     max_profit += m * profit\n     os -= m\n  \n print(max_profit)\n "~1
"n = int(input())\n s = input().strip()\n  \n min_flips = min(\n     n - s.count('N'),\n     n - s.count('S'),\n     n - s.count('W'),\n     n - s.count('E')\n )\n  \n print(min_flips)\n "~1
"n = int(input())\n sm = 0\n a = list(map(int, input().split()))\n a.sort()\n for i in range(n - 1):\n     lf = i - 1\n     r = len(a)\n     while lf + 1 < r:\n         m = (lf + r) // 2\n         if a[i] < a[m] * 0.9:\n             r = m\n         else:\n             lf = m\n     sm += r - i - 1\n print(sm)\n "~0
"n = int(input())\n k = n\n while (k % (sum(map(int, list(str(k))))) != 0):\n     k+=1\n print(k)\n "~0
"n, k = map(int, input().split())\n d = list(map(int, input().split()))\n sm = sum(d)\n  \n def f(m, d):\n     sm = 0\n     for i in d:\n         sm += min(m, i)\n     return sm\n  \n if sm < k:\n     print(-1)\n  \n else:\n     l = -1\n     r = max(d) - 1\n     while (l + 1 < r):\n         m = (l + r) // 2\n         if (f(m, d) >= k):\n             r = m\n         else:\n  \n             l = m\n     print(r)\n "~0
"import bisect\n  \n n = int(input())\n s = list(map(int, input().split()))\n s.sort()\n  \n ans = 0\n for i in range(n):\n     limit = s[i] / 0.9\n     r = bisect.bisect_right(s, limit)\n     ans += r - (i + 1)\n  \n print(ans)\n "~1
"n = int(input())\n arr = [int(i) for i in input().split()]\n l = [-1] * n\n r = [n] * n\n st = []\n for i in range(n):\n     while len(st) != 0 and arr[st[-1]] < arr[i]:\n         r[st[-1]] = i\n         st.pop()\n     st.append(i)\n st = []\n for i in range(n - 1,-1,-1):\n     while len(st) != 0 and arr[st[-1]] < arr[i]:\n         l[st[-1]] = i\n         st.pop()\n     st.append(i)\n for i in range(n):\n     cnt = 1\n     cnt += r[i] - i - 1\n     cnt += i - l[i] - 1\n     print(cnt, end=' ')\n "~0
"n = int(input())\n m = int(input())\n t = int(input())\n l = 0\n r = -(min(n, m) // -2)\n  \n while r - l > 1:\n     mid=(r+l)//2\n     s=n*2*mid+m*2*mid-(4*mid*mid)\n     if s > t:\n         r=mid\n     else:\n         l=mid\n print(l)\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n  \n ind = [i for i in range(n) if a[i] == 1]\n  \n if not ind:\n     print(0)\n else:\n     w = 1\n     for i in range(len(ind) - 1):\n         w *= (ind[i+1] - ind[i])\n     print(w)\n "~0
"n=int(input())\n x=int(input())\n  \n n=n%6\n  \n j=[0,0,0]\n  \n j[x]=1\n  \n for i in range(n,0,-1):\n     if i%2==0:\n         j[1],j[2]=j[2],j[1]\n     else:\n         j[0],j[1]=j[1],j[0]\n print(j.index(1))\n "~0
"n=int(input())\n a=str(input())\n ma=0\n  \n print(len(a)-max(a.count("N"),a.count("S"),a.count("W"),a.count("E")))\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n if sum(a) < 1:\n     print(0)\n elif sum(a) == 1:\n     print(1)\n else:\n     last = 0\n     cnt = 0\n     ans = 1\n     for i in range(n):\n         if a[i] == 1:\n             cnt += 1\n             if cnt != 1:\n                 ans *= i - last\n             last = i\n     print(ans)\n "~0
"n, p, k = map(int, input().split())\n a = list(map(int, input().split()))\n a.sort()\n if p > a[-1]:\n     print(0)\n else:\n     i = 2\n     k1 = k\n     k2 = k\n     k3 = k\n     cnt = 0\n     while p < a[2] and n > 0 and k1 > 0:\n         cnt += a[2] - p\n         k1 -= 1\n         n -= 1\n     while p < a[1] and n > 0 and k2 > 0:\n         cnt += a[1] - p\n         k2 -= 1\n         n -= 1\n     while p < a[0] and n > 0 and k3 > 0:\n         cnt += a[0] - p\n         k3 -= 1\n         n -= 1\n     print(cnt)\n "~0
"a = list(input().split())\n op = []\n f = dict()\n ch = 0\n fun = ""\n while a[0] != "endprg":\n     if a[0] == "function":\n         f[a[1]] = []\n         ch = 1\n         fun = a[1]\n     elif a[0] == "end":\n         ch = 0\n         fun = ""\n     elif ch == 1:\n         if a[0] == "print":\n             f[fun].append(a[1])\n         else:\n             f[fun] += f[a[1]]\n     else:\n         op.append(a)\n     a = list(input().split())\n for z in range(len(op)):\n     if op[z][0] == "print":\n         print(op[z][1])\n     else:\n         i = op[z][1]\n         j = 0\n         while j < len(f[i]):\n             print(f[i][j])\n             j += 1\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n a.insert(0, 10000000000)\n a.append(10000000000)\n st = [0]\n ans = []\n for i in range(1, n + 1):\n     while a[st[-1]] <= a[i]:\n         st.pop()\n     ans.append(st[-1])\n     st.append(i)\n st = [0]\n ans1 = [0] * n\n for i in range(n + 2):\n     while a[i] > a[st[-1]]:\n         ans1[st[-1] - 1] = i\n         st.pop()\n     st.append(i)\n for i in range(1, n + 1):\n     a[i] = ans1[i - 1] - ans[i - 1] - 1\n a = a[:-1]\n a = a[1:]\n print(*a)\n "~0
"n, k = map(int, input().split())\n a = list(map(int, input().split()))\n cnt = [0] * k\n cnt0 = k - 1\n j = 0\n ib = 0\n jb = n\n cnt[a[0] - 1] += 1\n for i in range(n):\n     while cnt0 != 0 and j < n - 1:\n         j += 1\n         cnt[a[j] - 1] += 1\n         if cnt[a[j] - 1] == 1:\n             cnt0 -= 1\n     if cnt0 != 0:\n         break\n     else:\n         if j - i < jb - ib:\n             jb = j\n             ib = i\n     cnt[a[i] - 1] -= 1\n     if cnt[a[i] - 1] == 0:\n         cnt0 += 1\n print(ib + 1, jb + 1)\n "~0
"import sys\n from collections import defaultdict\n \n def solve():\n     n = int(sys.stdin.readline())\n     states = {}\n     for _ in range(n):\n         parts = sys.stdin.readline().split()\n         state_name = ' '.join(parts[:-1])\n         electors = int(parts[-1])\n         states[state_name] = electors\n     \n     # Словарь для подсчета голосов по штатам: {штат: {кандидат: голоса}}\n     state_votes = defaultdict(lambda: defaultdict(int))\n     \n     for line in sys.stdin:\n         line = line.strip()\n         if not line:\n             continue\n         parts = line.split()\n         state_name = ' '.join(parts[:-1])\n         candidate = parts[-1]\n         state_votes[state_name][candidate] += 1\n     \n     # Словарь для итоговых голосов выборщиков: {кандидат: голоса}\n     candidate_electors = defaultdict(int)\n     \n     for state in states:\n         electors = states[state]\n         candidates_votes = state_votes[state]\n         if not candidates_votes:\n             continue  # по условию такого не должно быть\n         \n         max_votes = -1\n         winners = []\n         for candidate, votes in candidates_votes.items():\n             if votes > max_votes:\n                 max_votes = votes\n                 winners = [candidate]\n             elif votes == max_votes:\n                 winners.append(candidate)\n         \n         # Выбираем лексикографически меньшего победителя\n         winners.sort()\n         winner = winners[0]\n         candidate_electors[winner] += electors\n     \n     # Собираем всех кандидатов, которые когда-либо получали голоса (включая тех, у кого 0)\n     all_candidates = set()\n     for state in state_votes:\n         for candidate in state_votes[state]:\n             all_candidates.add(candidate)\n     \n     # Добавляем кандидатов, которые есть в candidate_electors (но возможно, они уже в all_candidates)\n     for candidate in candidate_electors:\n         all_candidates.add(candidate)\n     \n     # Преобразуем в список и сортируем\n     candidates_list = list(all_candidates)\n     # Сортировка: по убыванию голосов, затем по имени в лексикографическом порядке\n     candidates_list.sort(key=lambda x: (-candidate_electors.get(x, 0), x))\n     \n     for candidate in candidates_list:\n         print(candidate, candidate_electors.get(candidate, 0))\n \n if __name__ == '__main__':\n     solve()\n "~1
"def is_valid(s: str) -> bool:\n     stack = []\n     mapping = {')': '(', ']': '[', '}': '{'}\n     for char in s:\n         if char in mapping:\n             top_element = stack.pop() if stack else '#'\n             if mapping[char] != top_element:\n                 return False\n         else:\n             stack.append(char)\n     return not stack\n \n s = input().strip()\n print("yes" if is_valid(s) else "no")\n "~1
"from collections import defaultdict\n \n text = input().split()\n word_counts = defaultdict(int)\n \n for word in text:\n     word_counts[word] += 1\n \n max_count = max(word_counts.values()) if word_counts else 0\n most_common_words = [word for word, count in word_counts.items() if count == max_count]\n most_common_words.sort()\n \n print(most_common_words[0] if most_common_words else "")\n "~1
"import sys\n \n for line in sys.stdin:\n     numbers = list(map(int, line.split()))\n     print(sum(numbers))\n "~1
"import sys\n for i in sys.stdin:\n     l = list(map(int, i.split()))\n     print(sum(l))\n "~1
"w, h, n = map(int, input().split())\n \n # Функция проверки\n def can_fit(s):\n     return (s // w) * (s // h) >= n\n \n left = 0\n right = max(w, h) * n\n \n while right - left > 1:\n     mid = (left + right) // 2\n     if can_fit(mid):\n         right = mid\n     else:\n         left = mid\n \n print(right)\n "~1
"def max_min_distance(N, K, stalls):\n     left = 1\n     right = stalls[-1] - stalls[0]\n     answer = 0\n \n     while left <= right:\n         mid = (left + right) // 2\n         count = 1\n         last_pos = stalls[0]\n \n         for i in range(1, N):\n             if stalls[i] - last_pos >= mid:\n                 count += 1\n                 last_pos = stalls[i]\n                 if count == K:\n                     break\n \n         if count >= K:\n             answer = mid\n             left = mid + 1\n         else:\n             right = mid - 1\n \n     return answer\n \n N, K = map(int, input().split())\n stalls = list(map(int, input().split()))\n print(max_min_distance(N, K, stalls))\n "~1
"import bisect\n \n def find_min_differences(a, b):\n     a_sorted = sorted(a)\n     result = []\n     for num in b:\n         pos = bisect.bisect_left(a_sorted, num)\n         min_diff = float('inf')\n         if pos < len(a_sorted):\n             min_diff = abs(a_sorted[pos] - num)\n         if pos > 0:\n             min_diff = min(min_diff, abs(a_sorted[pos - 1] - num))\n         result.append(min_diff)\n     return result\n \n n = int(input())\n a = list(map(int, input().split()))\n m = int(input())\n b = list(map(int, input().split()))\n \n differences = find_min_differences(a, b)\n print(' '.join(map(str, differences)))\n "~1
"n = int(input())\n a = list(map(int, input().split()))\n \n max_sum = current_sum = a[0]\n start = end = 0\n best_start = best_end = 0\n \n for i in range(1, n):\n     if current_sum + a[i] > a[i]:\n         current_sum += a[i]\n         end = i\n     else:\n         current_sum = a[i]\n         start = end = i\n     \n     if current_sum > max_sum or (current_sum == max_sum and (end < best_end or (end == best_end and start > best_start))):\n         max_sum = current_sum\n         best_start = start\n         best_end = end\n \n print(best_start + 1, best_end + 1)\n "~1
"n = int(input())\n t = list(map(int, input().split()))\n alice_time = 0\n bob_time = 0\n alice_count = 0\n bob_count = 0\n left = 0\n right = n - 1\n \n while left <= right:\n     if alice_time <= bob_time:\n         alice_time += t[left]\n         alice_count += 1\n         left += 1\n     else:\n         bob_time += t[right]\n         bob_count += 1\n         right -= 1\n \n print(alice_count, bob_count)\n "~1
"def F(a):\n     n=len(a)-2\n     ans=[-1]*(n+2)\n     st=[0]\n     for i in range(1,n+2):\n         while a[i]<a[st[-1]]:\n             if i!=n+1:\n                 ans[st[-1]]=i-1\n             else:\n                 ans[st[-1]]=n\n             st.pop()\n         st.append(i)\n     return ans[1:n+1]\n q=list(map(int,input().split()))[1:]\n n=len(q)\n a=[-1]+q+[-1]\n ans1=F(a)\n ans2=F(a[::-1])\n best=0\n for i in range(n):\n     h=q[i]\n     ir=ans1[i]\n     il=n-ans2[n-i-1]\n     w=ir-il\n     if h*w>best:\n         best=h*w\n print(best)\n "~0
"n=int(input())\n a=[-1]+list(map(int,input().split()))+[-1]\n ans=[-1]*(n+2)\n st=[0]\n for i in range(1,n+2):\n     while a[i]<a[st[-1]]:\n         if i!=n+1:\n             ans[st[-1]]=i-1\n         st.pop()\n     st.append(i)\n print(*ans[1:n+1])\n "~0
"n=input()\n st=[]\n for i in n:\n     if st==[]:\n         st.append(i)\n     else:\n         if i==')' or i==']' or i=='}': \n             if (st[-1]=='(' and i==')') or (st[-1]=='{' and i=='}') or (st[-1]=='[' and i==']'):\n                 st.pop()\n             else:\n                 print('no')\n                 exit()\n         else:\n             st.append(i)         \n if st!=[]:\n     print('no')  \n else:\n     print('yes')  \n "~0
"from collections import deque\n n, k =int(input()), int(input())\n a=[int(input()) for _ in range(n)]\n ans=[0 for _ in range(n-k+1)]\n dq=deque()\n for i in range(n):\n     while len(dq)>0 and a[i]<=a[dq[-1]]:\n         dq.pop()\n     dq.append(i)\n     if i >=k-1:\n         if dq[0] <= i-k:\n             dq.popleft()\n         ans[i-k+1]=a[dq[0]]\n \n print("\n ".join(map(str,ans)))\n "~1
"import sys\n from collections import deque\n \n def solve():\n     n, q = map(int, sys.stdin.readline().split())\n     a = list(map(int, sys.stdin.readline().split()))\n     queries = [int(sys.stdin.readline()) for _ in range(q)]\n     \n     dq = deque(a)\n     opers = []\n     max_m = max(queries) if q > 0 else 0\n     max_ops = min(max_m, n - 1) if q > 0 else 0\n     \n     for _ in range(max_ops):\n         A = dq.popleft()\n         B = dq.popleft()\n         opers.append((A, B))\n         if A > B:\n             dq.appendleft(A)\n             dq.append(B)\n         else:\n             dq.appendleft(B)\n             dq.append(A)\n     \n     mx = max(a)\n     d = list(dq)\n     \n     res = []\n     for m in queries:\n         if m <= len(opers):\n             A, B = opers[m - 1]\n         else:\n             index = (m - len(opers) - 1) % (n - 1)\n             A = d[0]\n             B = d[1 + index]\n         res.append(f"{A} {B}")\n     \n     print('\n '.join(res))\n \n solve()\n "~1
"n, k = map(int, input().split())\n d = list(map(int, input().split()))\n sm = sum(d)\n \n def f(m, d):\n     sm = 0\n     for i in d:\n         sm += min(m, i)\n     return sm\n \n if sm < k:\n     print(-1)\n \n else:\n     l = -1\n     r = max(d) - 1\n     while (l + 1 < r):\n         m = (l + r) // 2\n         if (f(m, d) >= k):\n             r = m\n         else:\n \n             l = m\n     print(r)\n "~0
"def gcd(a,b):\n     while b!=0:\n         a,b=b,a%b\n     return a\n x1,y1,x2,y2=map(int,input().split())\n print(gcd(abs(x2-x1),abs(y2-y1))+1)\n "~0
"def F1(a,b):\n     while b!=0:\n         a,b=b,a%b\n     return a\n def F2(a,b):\n     return a*b//F1(a,b)\n q=int(input())\n n=list(map(int,input().split()))\n if q==1:\n     print(n[0]+1)\n else:  \n     a=F2(n[0]+1,n[1]+1)\n     for i in range(2,q):\n         a=F2(a,n[i]+1)\n     print(a)\n "~0
"def fpow(x,y):\n     global m\n     if y==0:\n         return 1\n     if y%2==1:\n         return fpow(x%m,y-1)*x%m\n     else:\n         return fpow(x*x%m,y//2)%m\n x,m=map(int,input().split())\n if fpow(x,x)==0:\n     print('YES')\n else:\n     print('NO')\n "~0
"n=int(input())\n for i in range(n):\n     a,b=map(int,input().split('/'))\n     q,w=a,b\n     while b!=0:\n         a,b=b,a%b\n     print(str(q//a)+'/'+str(w//a))\n "~0
"def prime(x):\n     dict={}\n     q=[]\n     d=2\n     while d*d<=x:\n         if x%d==0:\n             if d in dict:\n                 dict[d]=dict[d]+1\n             else:\n                 dict[d]=1\n                 q.append(d)\n             x//=d\n         else:\n             d+=1\n     if x in dict:\n         dict[x]=dict[x]+1\n     else:\n         q.append(x)\n         dict[x]=1\n     return dict,q\n n=int(input())\n dict,q=prime(n)\n ans=''\n for i in q:\n     if dict[i]==1:\n         ans+=str(i)+'*'\n     else:\n         ans+=str(i)+'^'+str(dict[i])+'*'\n print(ans[:-1])\n "~0
"def ext_gcd(a, b):\n     if b == 0:\n         return a, 1, 0\n     g, x, y = ext_gcd(b, a % b)\n     return g, y, x - a // b * y\n \n \n a, b, c = map(int, input().split())\n res = ext_gcd(a, b)\n x0 = res[1]\n y0 = res[2]\n g = res[0]\n ans = []\n for i in range(-1000, 1001):\n     x = x0 * (c // g) + (b // g) * i\n     y = y0 * (c // g) - (a // g) * i\n     if a * x + b * y == c and x > 0 and y > 0:\n         ans.append((x, y))\n ans.sort(key = lambda x: x[0])\n print(len(ans))\n for i in range(len(ans)):\n     print(*ans[i])\n "~1
"x, k = map(int, input().split())\n x1 = x\n arr = [1] * 1000000\n for i in range(1, len(arr)):\n     if arr[i] == 1:\n         for j in range((i + 1) * (i + 1) - 1, len(arr), i + 1):\n             arr[j] = 0\n sq = []\n for i in range(len(arr)):\n     if arr[i] == 1:\n         sq.append(i + 1)\n cnt = dict()\n d = 2\n while d * d <= x:\n     if x % d == 0:\n         x //= d\n         cnt[d] = cnt.get(d, 0) + 1\n     else:\n         d += 1\n cnt[x] = cnt.get(x, 0) + 1\n summa = 0\n for key in cnt:\n     summa += cnt[key]\n if summa < k:\n     print(-1)\n else:\n     for key in cnt:\n         while k > 1 and cnt[key] > 0:\n             print(key, end = " ")\n             x1 //= key\n             cnt[key] -= 1\n             k -= 1\n     print(x1)\n "~1
"n = int(input())\n a = list(map(int, input().split()))\n arr = [1] * 1000000\n for i in range(1, len(arr)):\n     if arr[i] == 1:\n         for j in range((i + 1) * (i + 1) - 1, len(arr), i + 1):\n             arr[j] = 0\n sq = []\n for i in range(len(arr)):\n     if arr[i] == 1:\n         sq.append((i + 1) * (i + 1))\n for i in range(n):\n     l = -1\n     r = len(sq) - 1\n     while r - l > 1:\n         mid = (r + l) // 2\n         if sq[mid] < a[i]:\n             l = mid\n         else:\n             r = mid\n     if (not sq[r] == a[i]) or a[i] == 1:\n         print("NO")\n     else:\n         print("YES")\n "~0
"l, r = map(int, input().split())\n if l == r:\n     print(l)\n else:\n     print(2)\n "~0
"import sys\n sys.set_int_max_str_digits(1000000)\n n = int(input())\n if n % 4 == 0:\n     print(4)\n else:\n     print(0)\n "~1
"l,r=map(int,input().split())\n if l==r and r%2==1: print(l)\n else: print(2)\n "~0
"n,k=map(int,input().split())\n d=2\n a=[]\n count=0\n while d*d<=n and count<k-1:\n     if n%d==0:\n         a.append(d)\n         n//=d\n         count+=1\n     else: d+=1\n a.append(n)\n if len(a)<k: print(-1)\n else: print(*a)\n "~0
"def prime(n):\n     d=2\n     while d*d<=n:\n         if n%d==0:\n             dict[d]=dict.get(d, 0)+1\n             n//=d\n         else:\n             d+=1\n     dict[n] = dict.get(n, 0) + 1\n n=int(input())\n o=10**9+7\n dict=dict()\n for i in range(2,n+1):\n     prime(i)\n p=1\n for i in dict.keys():\n     p=(p*(dict[i]+1)%o)%o\n print(p)\n "~0
"def fast_pow(a,n,m):\n     if n==0: return 1\n     elif n%2==1: return ((fast_pow(a,n-1,m)%m)*(a%m))%m\n     else:\n         x=a%m\n         return fast_pow(x*x,n//2,m)\n x,k=map(int,input().split())\n if fast_pow(x,x,k): print("NO")\n else: print("YES")\n "~0
"n = int(input())\n l = list(map(int, input().split()))\n count = [0] * 8\n for i in l:\n     count[i] += 1\n if count[5] > 0 or count[7] > 0:\n     print(-1)\n else:\n     e = min(count[4], count[2], count[1])\n     count[4] -= e\n     count[2] -= e\n     count[1] -= e\n     if count[6] == count[1] and count[6] == count[3] + count[2]:\n         for _ in range(e):\n             print(1, 2, 4)\n         for _ in range(count[2]):\n             print(1, 2, 6)\n         for _ in range(count[3]):\n             print(1, 3, 6)\n     else:\n         print(-1)\n "~1
"from string import ascii_uppercase\n  \n  \n a = input()\n _ = False\n Up = False\n for i in a:\n     if i in ascii_uppercase:\n         Up = True\n     if i == "_":\n         _ = True\n if _ == Up:\n     if _ == Up == 0:\n         print(a)\n     else:\n         print("Error!")\n elif "__" in a or a[0] == "_" or a[-1] == "_" or a[0] in ascii_uppercase:\n     print("Error!")\n else:\n     if "_" in a:\n         a = a.title()\n         a = a.replace("_", "")\n         a = a.replace(a[0], a[0].lower(), 1)\n         print(a)\n     else:\n         s = ""\n         for i in a:\n             if i.isupper():\n                 s += f"_{i.lower()}"\n             else:\n                 s += i\n         print(s)\n \n "~1
"a = int(input())\n s = []\n for i in range(a):\n     s.append(list(map(int, input().split())))\n input()\n k = list(map(int, input().split()))\n l = 0\n for i in range(a):\n     for j in range(i + 1, a):\n         if s[i][j] == 1 and k[i] != k[j]:\n             l += 1\n print(l)\n "~0
"def is_prime(s):\n     for i in range(2, int(__import__("math").sqrt(s)) + 1):\n         if s % i == 0:\n             return False\n     return True\n  \n  \n a = int(input())\n if is_prime(int("".join(sorted(str(a))))) and is_prime(int("".join(sorted(str(a), reverse=True)))):\n     print("Yes")\n else:\n     print("No")\n "~1
"n = int(input())\n petya = (n / 3) * 1.625\n vasya = (n / 3) * 0.5\n kolya = (n / 3) * 0.875\n print(int(petya), int(vasya), int(kolya))\n "~1
"a, b, c = input().split()\n a = set(a)\n b = set(b)\n c = set(c)\n a = a.intersection(b)\n a = a.intersection(c)\n print(len(a))\n if len(a) > 0:\n     a = sorted(a)\n     print(*a)\n "~0
"a, b = map(int, input().split())\n s = []\n for i in range(a):\n     s.append(list(map(int, input().split())))\n d = list(zip(*s))\n hori = [min(s[i]) for i in range(a)]\n vert = [max(d[i]) for i in range(b)]\n k = 0\n for i in range(a):\n     for j in range(b):\n         if s[i][j] == hori[i] and s[i][j] == vert[j]:\n             k += 1\n print(k)\n \n "~0
"# Получаем ввод числа\n n = int(input())\n # Внешний цикл для создания строк с числами от 1 до n\n for i in range(1, n + 1):\n     # Внутренний цикл для повторения числа i в строке i раз\n     for j in range(i):\n         print(i, end='')  # Выводим число i\n     print()  # Переходим на новую строку после каждой строки\n "~1
"# Получаем ввод числа\n n = int(input())\n # Находим середину пирамиды\n centr = n // 2 + 1\n # Инициализируем счетчик звездочек в строке\n count = 0\n # Проходим по строкам пирамиды от 1 до n\n for i in range(1, n + 1):\n     if i > centr:\n         count -= 1  # Если перешли за середину, уменьшаем количество звездочек\n     else:\n         count += 1  # В противном случае увеличиваем количество звездочек\n     \n     # Выводим звездочки в строке\n     for _ in range(count):\n         print('*', end='')\n     # Переходим на новую строку для следующей строки пирамиды\n     print()\n "~1
"a , b = int(input()), int(input())\n total_maximum = 0                 \n digit = 0                            \n for i in range(a, b + 1):         \n     maximum = 0                   \n     for j in range(1, i + 1):    \n         if i % j == 0:             \n             maximum += j         \n         if maximum >= total_maximum:  \n             total_maximum = maximum\n             digit = j\n print(digit, total_maximum)\n "~1
"n=int(input())\n while n > 9:       \n     s = 0    \n     while (n > 0):\n         last_digit = n % 10\n         s += last_digit\n         n = n // 10          \n     n = s\n     \n print(n)\n "~1
"num = int(input())\n total = 0\n factorial = 1 \n for i in range(1, num+1):\n     for j in range(1, i+1):\n         factorial *= j\n     total += factorial\n     factorial = 1\n print(total)\n "~1
"s = input()  # Считываем первую строку\n r = input()  # Считываем вторую строку\n # Преобразуем первую строку s в список символов\n # Затем объединяем символы из списка, используя вторую строку r в качестве разделителя\n res = r.join(list(s))\n # Выводим результат\n print(res)\n "~1
"def quick_merge(lst1, lst2):\n     res = []       # Результирующий список\n     p1, p2 = 0, 0  # Индексы текущих элементов для lst1 и lst2\n     # Пока есть элементы в обоих списках, сравниваем их и добавляем минимальный в res\n     while p1 < len(lst1) and p2 < len(lst2):\n         if lst1[p1] < lst2[p2]:\n             res.append(lst1[p1])\n             p1 += 1\n         else:\n             res.append(lst2[p2])\n             p2 += 1\n     # Если все элементы lst1 были добавлены, добавляем оставшиеся элементы lst2 и наоборот\n     if p1 == len(lst1):\n         res += lst2[p2:]\n     else:\n         res += lst1[p1:]\n     return res\n res = []  # Результирующий список\n # Считываем количество списков для сортировки\n for _ in range(int(input())):\n     num = [int(c) for c in input().split()]  # Считываем список чисел\n     res = quick_merge(res, num)  # Вызываем quick_merge() для сортировки и объединения списков\n # Выводим отсортированный результирующий список\n print(*res)\n "~1
"\n def merge(list1, list2):\n     l = list1 + list2\n     \n     l.sort()\n     \n     return l\n \n numbers1 = [int(c) for c in input().split()]\n numbers2 = [int(c) for c in input().split()]\n \n print(merge(numbers1, numbers2))\n "~1
"def get_factors(num):\n     l = []\n     for i in range(1, num // 2 + 1):  \n         if num % i == 0: \n             l.append(i)\n     l.append(num)  \n     return l\n \n n = int(input())\n \n print(get_factors(n))\n "~1
"def convert_to_miles(km):\n     return km * 0.6214\n \n num = int(input())\n \n print(convert_to_miles(num))\n "~1
"def get_middle_point(x1, y1, x2, y2):\n     return (x1 + x2) / 2, (y1 + y2) / 2\n \n x_1, y_1 = int(input()), int(input())\n x_2, y_2 = int(input()), int(input())\n \n x, y = get_middle_point(x_1, y_1, x_2, y_2)\n print(x, y)\n "~1
"import math\n def get_circle(radius):\n     return 2 * math.pi * radius, math.pi * (radius ** 2)\n \n r = float(input())\n \n length, square = get_circle(r)\n print(length, square)\n "~1
"def is_palindrome(num):\n     return str(num) == str(num)[::-1]\n \n def is_prime(num):\n     if num == 1:\n         return False\n     \n     for i in range(2, int(num ** 0.5) + 1):\n         if num % i == 0:\n             return False\n         \n     return True\n \n def is_even(num):\n     return num % 2 == 0\n \n def is_valid_password(password):\n     l = password.split(":")\n     \n     if len(l) == 3:  \n         l = [int(el) for el in l]\n         a, b, c = l[0], l[1], l[2]\n         return is_palindrome(a) and is_prime(b) and is_even(c)\n     \n     return False\n \n psw = input()\n \n print(is_valid_password(psw))\n "~1
"a = int(input())\n b = int(input())\n c = int(input())\n d = int(input())\n spisok=[]\n for i in range(c+ (a-c+d-1)//d*d, b+1, d):\n     spisok.append(i)\n print(*spisok)\n "~1
"n = int(input())\n c3 = n // 60\n c2 = (n % 60) // 10\n c1 = n % 10\n if c1 * 15 > 125:\n   c1 = 0\n   c2 += 1\n if c1 * 15 + c2 * 125 > 440:\n   c1 = 0\n   c2 = 0\n   c3 += 1\n print(c1, c2, c3)\n "~0
"def ToLower(S):\n   return s.lower()\n \n s = input()\n print(ToLower(s))\n "~1
"a = int(input())\n if a == 0:\n     print(0)\n else:\n     fib_prev, fib_next = 0, 1\n     n = 1\n     while fib_next <= a:\n         if fib_next == a:\n             print(n)\n             break\n         fib_prev, fib_next = fib_next, fib_prev + fib_next\n         n += 1\n     else:\n         print(-1)\n "~1
"n = int(input())\n l = []\n while n != 0:\n     l.append(n)\n     n = int(input())\n l.remove(max(l))\n print(max(l))\n "~0
"a, b, c = map(int, input().split())\n print(str(a) + "+" + str(b) + "+" + str(c) + "=" + str(a + b + c))\n print(str(a) + "*" + str(b) + "*" + str(c) + "=" + str(a * b * c))\n print("(" + str(a) + "+" + str(b) + "+" + str(c) + ")" + "/3" + "=" + str(f'{((a + b + c) / 3):.3f}'))\n "~1
"s = input()\n if len(s) % 2 == 0:\n     print(s[-(len(s) // 2):] + s[:-(len(s) // 2)])\n else:\n     print(s[-(len(s) // 2):] + s[:-(len(s) // 2)])\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n m = int(input())\n for i in range(m):\n     s = input().split()\n     x, y = int(s[0]), int(s[1])\n     print(sum(a[x - 1:y]))\n "~0
"n = int(input())\n a = [int(i) for i in input().split()]\n pref = [0] * (n + 1)\n minpref = 10 ** 4 + 1\n imn = 0\n jmx = 1\n maxsumm = -10 ** 8\n for i in range(1, len(pref)):\n     pref[i] = pref[i - 1] + a[i - 1]\n \n for i in range(1, len(pref)):\n     if pref[i] < minpref:\n         minpref = pref[i - 1]\n         imn = i - 1\n     if pref[i] - pref[imn] > maxsumm:\n         maxsumm = pref[i] - pref[imn]\n         jmx = i\n         imnotv = imn + 2\n print(imnotv, jmx, maxsumm + 1)\n "~1
"s = list(map(int, input().split()))\n n, r = s[0], s[1]\n i = 0\n j = 1\n cnt = 0\n a = list(map(int, input().split()))\n \n while j < n:\n     if a[j] - a[i] <= r:\n         j += 1\n     else:\n         i += 1\n         cnt += n - j\n \n print(cnt)\n "~0
"s = input()\n l = []\n c = 0\n for i in s:\n     try:\n         a = int(i)\n         c += 1\n     except:\n         a = 0\n print(c)\n "~0
"s = ''\n stack = []\n while s != "exit":\n     s = input()\n     if "push_front" in s:\n         stack.insert(0, s.split()[1])\n     elif "push_back" in s:\n         stack.append(s.split()[1])\n     elif "pop_front" in s:\n         if len(stack) != 0:\n             print(stack.pop(0))\n         else:\n             print("error")\n     elif "pop_back" in s:\n         if len(stack) != 0:\n             print(stack.pop(-1))\n         else:\n             print("error")\n     elif "size" in s:\n         print(len(stack))\n     elif "clear" in s:\n         stack.clear()\n         print("ok")\n     elif "front" in s:\n         if len(stack) != 0:\n             print(stack[0])\n         else:\n             print("error")\n     elif "back" in s:\n         if len(stack) != 0:\n             print(stack[-1])\n         else:\n             print("error")\n     elif "exit" in s:\n         print("bye")\n "~0
"s = input()\n l = []\n for i in s:\n     l.append(i)\n for i in range(len(s)):\n     if (l[i] == "(" and l[i + 1] == ")") or (l[i] == "[" and l[i + 1] == "]") or (l[i] == "{" and l[i + 1] == "}"):\n         l.pop(i)\n         l.pop(i + 1)\n print(l)\n "~0
"a1, a2, a3 = map(int, input().split())\n b1, b2, b3 = map(int, input().split())\n n = 0\n m = 0\n k = 0\n l = 0\n ans = 0\n if a1 > b1:\n     n = a1 - b1\n     ans += b1\n else:\n     k = b1 - a1\n     ans += a1\n \n if a2 > b2:\n     m = a2 - b2\n     ans += b2\n else:\n     l = b2 - a2\n     ans += a2\n \n if a3 > b3:\n     ans += b3\n     ans += min(k + l, a3 - b3)\n else:\n     ans += a3\n     ans += min(n + m, b3 - a3)\n \n print(ans)\n "~0
"import math\n \n n = int(input())\n for i in range(n):\n     m = int(input())\n     if len(str(m)) < 3 or len(str(m)) > 6:\n         print("NO")\n         continue\n     s = str(m)\n     ln = len(s)\n     flag = False\n     for j in range(math.ceil(ln / 3), ln - 1):\n         a = int(s[:j])\n         for k in range(j + math.ceil((ln - j) / 2), ln):\n             b = int(s[j:k])\n             c = int(s[k:])\n             if c <= b <= a < 19:\n                 flag = True\n                 break\n         if flag:\n             break\n     if flag:\n         print("YES")\n     else:\n         print("NO")\n \n "~0
"n = int(input())\n l = list(map(int, input().split()))\n ans = 0\n for i in range(n):\n     ans += i\n if float(l[0]) >= l[n - 1] * 0.8:\n     print(ans)\n else:\n     for i in range(n):\n         for j in range(i + 1, n):\n             if float(l[i]) < l[j]*0.8:\n                 ans -= n - j\n                 break\n     print(ans)\n \n \n "~0
"cnt = 0\n def f(t):\n     global cnt\n     for i in list(range(1, len(t) + 1))[::-1]:\n         if t[:i] == t[:i][::-1]:\n             cnt += 1\n             f(t[i:])\n             break\n \n s = input()\n f(s)\n print(cnt)\n "~0
"n = int(input())\n l = list(map(int, input().split()))\n x = 0\n y = 0\n k = 1\n while x + y != n - 1:\n     if k == 1:\n         if l[x] > l[n - y - 1]:\n             y+=1\n         else:\n             x += 1\n         k = 2\n     else:\n         if l[x] < l[n - y - 1]:\n             y+=1\n         else:\n             x += 1\n         k = 1\n print(l[x])\n "~0
"import math\n \n def extended_gcd(a, b):\n     if b == 0:\n         return (a, 1, 0)\n     else:\n         g, x, y = extended_gcd(b, a % b)\n         return (g, y, x - (a // b) * y)\n \n a, b, c = map(int, input().split())\n g, x, y = extended_gcd(a, b)\n if c % g != 0:\n     print("Impossible")\n else:\n     k = c // g\n     x0 = x * k\n     y0 = y * k\n     # x0 + (b/g)*t >= 0 => t >= -x0 * g / b\n     b_div_g = b // g\n     a_div_g = a // g\n     t = (-x0) // b_div_g\n     min_x = None\n     best_t = None\n     for possible_t in [t - 1, t, t + 1, t + 2]:\n         current_x = x0 + b_div_g * possible_t\n         if current_x >= 0:\n             if min_x is None or current_x < min_x:\n                 min_x = current_x\n                 best_t = possible_t\n     if min_x is not None:\n         x_ans = x0 + b_div_g * best_t\n         y_ans = y0 - a_div_g * best_t\n         print(x_ans, y_ans)\n     else:\n         print("Impossible")\n "~1
"import math\n \n def sieve(max_num):\n     is_prime = [True] * (max_num + 1)\n     is_prime[0] = is_prime[1] = False\n     for i in range(2, int(math.sqrt(max_num)) + 1):\n         if is_prime[i]:\n             for j in range(i * i, max_num + 1, i):\n                 is_prime[j] = False\n     return is_prime\n \n input = input().split()\n N = int(input[0])\n numbers = list(map(int, input[1:N+1]))\n max_num = max(numbers)\n is_prime = sieve(max_num)\n output = []\n for num in numbers:\n     output.append('1' if is_prime[num] else '0')\n print(''.join(output))\n "~1
"n = int(input())\n \n if n % 2 == 0:\n     k = n // 2\n     print(k)\n     print(' '.join(['2'] * k))\n else:\n     k = (n - 3) // 2 + 1\n     print(k)\n     print(' '.join(['2'] * ((n - 3) // 2) + ['3']))\n "~1
"def factorize(k):\n     factors = {}\n     # Обрабатываем делитель 2 отдельно\n     if k % 2 == 0:\n         count = 0\n         while k % 2 == 0:\n             count += 1\n             k = k // 2\n         factors[2] = count\n     # Проверяем нечетные делители от 3 до sqrt(k)\n     i = 3\n     max_factor = int(k**0.5) + 1\n     while i <= max_factor:\n         if k % i == 0:\n             count = 0\n             while k % i == 0:\n                 count += 1\n                 k = k // i\n             factors[i] = count\n             max_factor = int(k**0.5) + 1\n         i += 2\n     if k > 1:\n         factors[k] = 1\n     return factors\n \n def count_p_in_factorial(n, p):\n     count = 0\n     power = p\n     while power <= n:\n         count += n // power\n         power *= p\n     return count\n \n n, k = map(int, input().split())\n factors = factorize(k)\n min_zeros = float('inf')\n \n for p, m in factors.items():\n     cnt = count_p_in_factorial(n, p)\n     min_zeros = min(min_zeros, cnt // m)\n \n print(min_zeros)\n "~1
"import heapq\n \n n, k = map(int, input().split())\n servers = []\n for _ in range(k):\n     heapq.heappush(servers, (0, _))  # (время освобождения, номер сервера)\n \n output = []\n for _ in range(n):\n     s, m = map(int, input().split())\n     free_time, server_id = heapq.heappop(servers)\n     start_time = max(free_time, s)\n     end_time = start_time + m\n     output.append(end_time)\n     heapq.heappush(servers, (end_time, server_id))\n \n print('\n '.join(map(str, output)))\n "~1
"def getdivs(n):\n     start = []\n     end = []\n     i = 1\n     while i * i < n:\n         if n % i == 0:\n             start.append(i)\n             end.append(n // i)\n         i += 1\n     if i * i == n:\n         start.append(i)\n \n     return start, end\n \n def getelem(k):\n     if len(start) > k:\n         return start[k]\n     elif len(start) + len(end) > k:\n         return end[-k + len(start) -1]\n     \n def gcd(a, b):\n     while b != 0:\n         a, b = b, a % b\n     return a\n     \n n = int(input())\n start, end = getdivs(n)\n result = 0\n for i in range(len(start) + len(end) - 1):\n     for j in range(i + 1, len(start) + len(end)):\n         if gcd(getelem(i), getelem(j)) == 1 and getelem(i) * getelem(j) <= n:\n             result += 1\n print(result)\n "~0
"def gcd(a, b):\n     while b != 0:\n         a, b = b, a % b\n     return a\n \n n = int(input())\n for i in range(n):\n     a, b = map(int, input().split(sep = "/"))\n     g = gcd(a, b)\n     print(str(a // g) + "/" + str(b // g))\n "~0
"def pow(a, n):\n     a %= k\n     if n == 1:\n         return a\n     if n % 2 == 1:\n         return pow(a, n - 1) * a\n     else:\n         return pow(a * a, n // 2)\n     \n x, k = map(int, input().split())\n \n if pow(x, x) % k == 0:\n     print("YES")\n else:\n     print("NO")\n "~0