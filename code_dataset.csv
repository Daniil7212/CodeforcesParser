code~label
"\n n = int(input())\n a = list(map(int, input().split()))\n  \n l = [-1] * n\n st = []\n for i in range(n):\n     while st and a[st[-1]] <= a[i]:\n         st.pop()\n     l[i] = st[-1] if st else -1\n     st.append(i)\n  \n r = [n] * n\n st = []\n for i in range(n - 1, -1, -1):\n     while st and a[st[-1]] <= a[i]:\n         st.pop()\n     r[i] = st[-1] if st else n\n     st.append(i)\n     \n print(" ".join([str(r[i] - l[i] - 1) for i in range(n)]))\n"~0
"def calculate_sum(first_number, second_number):\n    result = first_number + second_number\n    return result"~1
"def compute_total(initial_value, increment):\n    total = initial_value + increment\n    return total"~1
"funcs = {}\n  \n def run_code(code):\n     if code != False:\n         #print('> called func')\n         code.append('endprg')\n     runpointer = 0\n     infunc = 0\n     currentwritingfunc = ""\n     while True:\n         curr_op = ""\n         if code == False:\n             curr_op = input()\n             #print("> running at input")\n         else:\n             curr_op = code[runpointer]\n             runpointer += 1\n         \n         if curr_op == "endprg": break\n  \n         if curr_op[0:8] == "function":\n             infunc += 1\n             currentwritingfunc = curr_op[9:len(curr_op)]\n             funcs[currentwritingfunc] = [1, []]\n             #print("> doing func", currentwritingfunc)\n             continue\n             \n         if curr_op[0:3] == "end":\n             infunc -= 1\n             continue\n             \n         if infunc > 0:\n             funcs[currentwritingfunc][1].append(curr_op)\n             #print('> wrote "'+curr_op+'" to '+currentwritingfunc)\n         else:\n             if curr_op[0:4] == "call":\n                 #print(funcs)\n                 run_code(funcs[curr_op[5:len(curr_op)]][1])\n                 continue\n             if curr_op[0:5] == "print":\n                 print(curr_op[6:len(curr_op)])\n                 continue\n             \n run_code(False)\n "~1
"n = int(input())\n a1 = list(map(int, input().split()))\n a2 = list(map(int, input().split()))\n a3 = list(map(int, input().split()))\n  \n a1p, a2p, a3p = [0] * (n + 1), [0] * (n + 1), [0] * (n + 1)\n  \n for i, v in enumerate(a1):\n     a1p[v] = i\n for i, v in enumerate(a2):\n     a2p[v] = i\n for i, v in enumerate(a3):\n     a3p[v] = i\n  \n def check(a, b):\n     count = 0\n     if a1p[a] < a1p[b]:\n         count += 1\n     if a2p[a] < a2p[b]:\n         count += 1\n     if a3p[a] < a3p[b]:\n         count += 1\n     return count >= 2\n     \n cand = 1\n for i in range(2, n + 1):\n     if check(i, cand):\n         cand = i\n  \n for j in range(1, n + 1):\n     if j == cand:\n         continue\n     if not check(cand, j):\n         print(-1)\n         exit(0)\n  \n print(cand)\n "~1
"n = int(input())\n a = list(map(int, input().split()))\n nuts = [i for i, x in enumerate(a) if x == 1]\n  \n     \n if not nuts:\n     print(0)\n else:\n     x = 1\n     for i in range(1, len(nuts)):\n         x *= (nuts[i] - nuts[i - 1])\n     print(x)\n "~1
"n = int(input())\n  \n k = n\n while True:\n     s = sum(int(d) for d in str(k))\n     if s != 0 and k % s == 0:\n         break\n     else:\n         k += 1\n print(k)\n "~0
"n = int(input())\n x = int(input())\n  \n n = n % 6\n  \n for i in range(n, 0, -1):\n     if i % 2 == 1:\n         if x == 0:\n             #print('l -> m')\n             x = 1\n         elif x == 1:\n             #print('m -> l')\n             x = 0\n     else:\n         if x == 1:\n             #print('m -> r')\n             x = 2\n         elif x == 2:\n             #print('r -> m')\n             x = 1\n print(x)\n "~0
"n, p, k = map(int, input().split())\n a, b, c = map(int, input().split())\n  \n pa = a - p\n pb = b - p\n pc = c - p\n  \n f = [\n     (pa, 'a'),\n     (pb, 'b'),\n     (pc, 'c')\n ]\n  \n f.sort(reverse=True, key=lambda x: x[0])\n  \n max_profit = 0\n os = n\n  \n for profit, name in f:\n     if os <= 0:\n         break\n     m = min(k, os)\n     max_profit += m * profit\n     os -= m\n  \n print(max_profit)\n "~1
"n = int(input())\n s = input().strip()\n  \n min_flips = min(\n     n - s.count('N'),\n     n - s.count('S'),\n     n - s.count('W'),\n     n - s.count('E')\n )\n  \n print(min_flips)\n "~1
"n = int(input())\n sm = 0\n a = list(map(int, input().split()))\n a.sort()\n for i in range(n - 1):\n     lf = i - 1\n     r = len(a)\n     while lf + 1 < r:\n         m = (lf + r) // 2\n         if a[i] < a[m] * 0.9:\n             r = m\n         else:\n             lf = m\n     sm += r - i - 1\n print(sm)\n "~0
"n = int(input())\n k = n\n while (k % (sum(map(int, list(str(k))))) != 0):\n     k+=1\n print(k)\n "~0
"n, k = map(int, input().split())\n d = list(map(int, input().split()))\n sm = sum(d)\n  \n def f(m, d):\n     sm = 0\n     for i in d:\n         sm += min(m, i)\n     return sm\n  \n if sm < k:\n     print(-1)\n  \n else:\n     l = -1\n     r = max(d) - 1\n     while (l + 1 < r):\n         m = (l + r) // 2\n         if (f(m, d) >= k):\n             r = m\n         else:\n  \n             l = m\n     print(r)\n "~0
"import bisect\n  \n n = int(input())\n s = list(map(int, input().split()))\n s.sort()\n  \n ans = 0\n for i in range(n):\n     limit = s[i] / 0.9\n     r = bisect.bisect_right(s, limit)\n     ans += r - (i + 1)\n  \n print(ans)\n "~1
"n = int(input())\n arr = [int(i) for i in input().split()]\n l = [-1] * n\n r = [n] * n\n st = []\n for i in range(n):\n     while len(st) != 0 and arr[st[-1]] < arr[i]:\n         r[st[-1]] = i\n         st.pop()\n     st.append(i)\n st = []\n for i in range(n - 1,-1,-1):\n     while len(st) != 0 and arr[st[-1]] < arr[i]:\n         l[st[-1]] = i\n         st.pop()\n     st.append(i)\n for i in range(n):\n     cnt = 1\n     cnt += r[i] - i - 1\n     cnt += i - l[i] - 1\n     print(cnt, end=' ')\n "~0
"n = int(input())\n m = int(input())\n t = int(input())\n l = 0\n r = -(min(n, m) // -2)\n  \n while r - l > 1:\n     mid=(r+l)//2\n     s=n*2*mid+m*2*mid-(4*mid*mid)\n     if s > t:\n         r=mid\n     else:\n         l=mid\n print(l)\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n  \n ind = [i for i in range(n) if a[i] == 1]\n  \n if not ind:\n     print(0)\n else:\n     w = 1\n     for i in range(len(ind) - 1):\n         w *= (ind[i+1] - ind[i])\n     print(w)\n "~0
"n=int(input())\n x=int(input())\n  \n n=n%6\n  \n j=[0,0,0]\n  \n j[x]=1\n  \n for i in range(n,0,-1):\n     if i%2==0:\n         j[1],j[2]=j[2],j[1]\n     else:\n         j[0],j[1]=j[1],j[0]\n print(j.index(1))\n "~0
"n=int(input())\n a=str(input())\n ma=0\n  \n print(len(a)-max(a.count("N"),a.count("S"),a.count("W"),a.count("E")))\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n if sum(a) < 1:\n     print(0)\n elif sum(a) == 1:\n     print(1)\n else:\n     last = 0\n     cnt = 0\n     ans = 1\n     for i in range(n):\n         if a[i] == 1:\n             cnt += 1\n             if cnt != 1:\n                 ans *= i - last\n             last = i\n     print(ans)\n "~0
"n, p, k = map(int, input().split())\n a = list(map(int, input().split()))\n a.sort()\n if p > a[-1]:\n     print(0)\n else:\n     i = 2\n     k1 = k\n     k2 = k\n     k3 = k\n     cnt = 0\n     while p < a[2] and n > 0 and k1 > 0:\n         cnt += a[2] - p\n         k1 -= 1\n         n -= 1\n     while p < a[1] and n > 0 and k2 > 0:\n         cnt += a[1] - p\n         k2 -= 1\n         n -= 1\n     while p < a[0] and n > 0 and k3 > 0:\n         cnt += a[0] - p\n         k3 -= 1\n         n -= 1\n     print(cnt)\n "~0
"a = list(input().split())\n op = []\n f = dict()\n ch = 0\n fun = ""\n while a[0] != "endprg":\n     if a[0] == "function":\n         f[a[1]] = []\n         ch = 1\n         fun = a[1]\n     elif a[0] == "end":\n         ch = 0\n         fun = ""\n     elif ch == 1:\n         if a[0] == "print":\n             f[fun].append(a[1])\n         else:\n             f[fun] += f[a[1]]\n     else:\n         op.append(a)\n     a = list(input().split())\n for z in range(len(op)):\n     if op[z][0] == "print":\n         print(op[z][1])\n     else:\n         i = op[z][1]\n         j = 0\n         while j < len(f[i]):\n             print(f[i][j])\n             j += 1\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n a.insert(0, 10000000000)\n a.append(10000000000)\n st = [0]\n ans = []\n for i in range(1, n + 1):\n     while a[st[-1]] <= a[i]:\n         st.pop()\n     ans.append(st[-1])\n     st.append(i)\n st = [0]\n ans1 = [0] * n\n for i in range(n + 2):\n     while a[i] > a[st[-1]]:\n         ans1[st[-1] - 1] = i\n         st.pop()\n     st.append(i)\n for i in range(1, n + 1):\n     a[i] = ans1[i - 1] - ans[i - 1] - 1\n a = a[:-1]\n a = a[1:]\n print(*a)\n "~0
"n, k = map(int, input().split())\n a = list(map(int, input().split()))\n cnt = [0] * k\n cnt0 = k - 1\n j = 0\n ib = 0\n jb = n\n cnt[a[0] - 1] += 1\n for i in range(n):\n     while cnt0 != 0 and j < n - 1:\n         j += 1\n         cnt[a[j] - 1] += 1\n         if cnt[a[j] - 1] == 1:\n             cnt0 -= 1\n     if cnt0 != 0:\n         break\n     else:\n         if j - i < jb - ib:\n             jb = j\n             ib = i\n     cnt[a[i] - 1] -= 1\n     if cnt[a[i] - 1] == 0:\n         cnt0 += 1\n print(ib + 1, jb + 1)\n "~0
"import sys\n from collections import defaultdict\n \n def solve():\n     n = int(sys.stdin.readline())\n     states = {}\n     for _ in range(n):\n         parts = sys.stdin.readline().split()\n         state_name = ' '.join(parts[:-1])\n         electors = int(parts[-1])\n         states[state_name] = electors\n     \n     # Словарь для подсчета голосов по штатам: {штат: {кандидат: голоса}}\n     state_votes = defaultdict(lambda: defaultdict(int))\n     \n     for line in sys.stdin:\n         line = line.strip()\n         if not line:\n             continue\n         parts = line.split()\n         state_name = ' '.join(parts[:-1])\n         candidate = parts[-1]\n         state_votes[state_name][candidate] += 1\n     \n     # Словарь для итоговых голосов выборщиков: {кандидат: голоса}\n     candidate_electors = defaultdict(int)\n     \n     for state in states:\n         electors = states[state]\n         candidates_votes = state_votes[state]\n         if not candidates_votes:\n             continue  # по условию такого не должно быть\n         \n         max_votes = -1\n         winners = []\n         for candidate, votes in candidates_votes.items():\n             if votes > max_votes:\n                 max_votes = votes\n                 winners = [candidate]\n             elif votes == max_votes:\n                 winners.append(candidate)\n         \n         # Выбираем лексикографически меньшего победителя\n         winners.sort()\n         winner = winners[0]\n         candidate_electors[winner] += electors\n     \n     # Собираем всех кандидатов, которые когда-либо получали голоса (включая тех, у кого 0)\n     all_candidates = set()\n     for state in state_votes:\n         for candidate in state_votes[state]:\n             all_candidates.add(candidate)\n     \n     # Добавляем кандидатов, которые есть в candidate_electors (но возможно, они уже в all_candidates)\n     for candidate in candidate_electors:\n         all_candidates.add(candidate)\n     \n     # Преобразуем в список и сортируем\n     candidates_list = list(all_candidates)\n     # Сортировка: по убыванию голосов, затем по имени в лексикографическом порядке\n     candidates_list.sort(key=lambda x: (-candidate_electors.get(x, 0), x))\n     \n     for candidate in candidates_list:\n         print(candidate, candidate_electors.get(candidate, 0))\n \n if __name__ == '__main__':\n     solve()\n "~1
"def is_valid(s: str) -> bool:\n     stack = []\n     mapping = {')': '(', ']': '[', '}': '{'}\n     for char in s:\n         if char in mapping:\n             top_element = stack.pop() if stack else '#'\n             if mapping[char] != top_element:\n                 return False\n         else:\n             stack.append(char)\n     return not stack\n \n s = input().strip()\n print("yes" if is_valid(s) else "no")\n "~1
"from collections import defaultdict\n \n text = input().split()\n word_counts = defaultdict(int)\n \n for word in text:\n     word_counts[word] += 1\n \n max_count = max(word_counts.values()) if word_counts else 0\n most_common_words = [word for word, count in word_counts.items() if count == max_count]\n most_common_words.sort()\n \n print(most_common_words[0] if most_common_words else "")\n "~1
"import sys\n \n for line in sys.stdin:\n     numbers = list(map(int, line.split()))\n     print(sum(numbers))\n "~1
"import sys\n for i in sys.stdin:\n     l = list(map(int, i.split()))\n     print(sum(l))\n "~1
"w, h, n = map(int, input().split())\n \n # Функция проверки\n def can_fit(s):\n     return (s // w) * (s // h) >= n\n \n left = 0\n right = max(w, h) * n\n \n while right - left > 1:\n     mid = (left + right) // 2\n     if can_fit(mid):\n         right = mid\n     else:\n         left = mid\n \n print(right)\n "~1
"def max_min_distance(N, K, stalls):\n     left = 1\n     right = stalls[-1] - stalls[0]\n     answer = 0\n \n     while left <= right:\n         mid = (left + right) // 2\n         count = 1\n         last_pos = stalls[0]\n \n         for i in range(1, N):\n             if stalls[i] - last_pos >= mid:\n                 count += 1\n                 last_pos = stalls[i]\n                 if count == K:\n                     break\n \n         if count >= K:\n             answer = mid\n             left = mid + 1\n         else:\n             right = mid - 1\n \n     return answer\n \n N, K = map(int, input().split())\n stalls = list(map(int, input().split()))\n print(max_min_distance(N, K, stalls))\n "~1
"import bisect\n \n def find_min_differences(a, b):\n     a_sorted = sorted(a)\n     result = []\n     for num in b:\n         pos = bisect.bisect_left(a_sorted, num)\n         min_diff = float('inf')\n         if pos < len(a_sorted):\n             min_diff = abs(a_sorted[pos] - num)\n         if pos > 0:\n             min_diff = min(min_diff, abs(a_sorted[pos - 1] - num))\n         result.append(min_diff)\n     return result\n \n n = int(input())\n a = list(map(int, input().split()))\n m = int(input())\n b = list(map(int, input().split()))\n \n differences = find_min_differences(a, b)\n print(' '.join(map(str, differences)))\n "~1
"n = int(input())\n a = list(map(int, input().split()))\n \n max_sum = current_sum = a[0]\n start = end = 0\n best_start = best_end = 0\n \n for i in range(1, n):\n     if current_sum + a[i] > a[i]:\n         current_sum += a[i]\n         end = i\n     else:\n         current_sum = a[i]\n         start = end = i\n     \n     if current_sum > max_sum or (current_sum == max_sum and (end < best_end or (end == best_end and start > best_start))):\n         max_sum = current_sum\n         best_start = start\n         best_end = end\n \n print(best_start + 1, best_end + 1)\n "~1
"n = int(input())\n t = list(map(int, input().split()))\n alice_time = 0\n bob_time = 0\n alice_count = 0\n bob_count = 0\n left = 0\n right = n - 1\n \n while left <= right:\n     if alice_time <= bob_time:\n         alice_time += t[left]\n         alice_count += 1\n         left += 1\n     else:\n         bob_time += t[right]\n         bob_count += 1\n         right -= 1\n \n print(alice_count, bob_count)\n "~1
"def F(a):\n     n=len(a)-2\n     ans=[-1]*(n+2)\n     st=[0]\n     for i in range(1,n+2):\n         while a[i]<a[st[-1]]:\n             if i!=n+1:\n                 ans[st[-1]]=i-1\n             else:\n                 ans[st[-1]]=n\n             st.pop()\n         st.append(i)\n     return ans[1:n+1]\n q=list(map(int,input().split()))[1:]\n n=len(q)\n a=[-1]+q+[-1]\n ans1=F(a)\n ans2=F(a[::-1])\n best=0\n for i in range(n):\n     h=q[i]\n     ir=ans1[i]\n     il=n-ans2[n-i-1]\n     w=ir-il\n     if h*w>best:\n         best=h*w\n print(best)\n "~0
"n=int(input())\n a=[-1]+list(map(int,input().split()))+[-1]\n ans=[-1]*(n+2)\n st=[0]\n for i in range(1,n+2):\n     while a[i]<a[st[-1]]:\n         if i!=n+1:\n             ans[st[-1]]=i-1\n         st.pop()\n     st.append(i)\n print(*ans[1:n+1])\n "~0
"n=input()\n st=[]\n for i in n:\n     if st==[]:\n         st.append(i)\n     else:\n         if i==')' or i==']' or i=='}': \n             if (st[-1]=='(' and i==')') or (st[-1]=='{' and i=='}') or (st[-1]=='[' and i==']'):\n                 st.pop()\n             else:\n                 print('no')\n                 exit()\n         else:\n             st.append(i)         \n if st!=[]:\n     print('no')  \n else:\n     print('yes')  \n "~0
"from collections import deque\n n, k =int(input()), int(input())\n a=[int(input()) for _ in range(n)]\n ans=[0 for _ in range(n-k+1)]\n dq=deque()\n for i in range(n):\n     while len(dq)>0 and a[i]<=a[dq[-1]]:\n         dq.pop()\n     dq.append(i)\n     if i >=k-1:\n         if dq[0] <= i-k:\n             dq.popleft()\n         ans[i-k+1]=a[dq[0]]\n \n print("\n ".join(map(str,ans)))\n "~1
"import sys\n from collections import deque\n \n def solve():\n     n, q = map(int, sys.stdin.readline().split())\n     a = list(map(int, sys.stdin.readline().split()))\n     queries = [int(sys.stdin.readline()) for _ in range(q)]\n     \n     dq = deque(a)\n     opers = []\n     max_m = max(queries) if q > 0 else 0\n     max_ops = min(max_m, n - 1) if q > 0 else 0\n     \n     for _ in range(max_ops):\n         A = dq.popleft()\n         B = dq.popleft()\n         opers.append((A, B))\n         if A > B:\n             dq.appendleft(A)\n             dq.append(B)\n         else:\n             dq.appendleft(B)\n             dq.append(A)\n     \n     mx = max(a)\n     d = list(dq)\n     \n     res = []\n     for m in queries:\n         if m <= len(opers):\n             A, B = opers[m - 1]\n         else:\n             index = (m - len(opers) - 1) % (n - 1)\n             A = d[0]\n             B = d[1 + index]\n         res.append(f"{A} {B}")\n     \n     print('\n '.join(res))\n \n solve()\n "~1
"n, k = map(int, input().split())\n d = list(map(int, input().split()))\n sm = sum(d)\n \n def f(m, d):\n     sm = 0\n     for i in d:\n         sm += min(m, i)\n     return sm\n \n if sm < k:\n     print(-1)\n \n else:\n     l = -1\n     r = max(d) - 1\n     while (l + 1 < r):\n         m = (l + r) // 2\n         if (f(m, d) >= k):\n             r = m\n         else:\n \n             l = m\n     print(r)\n "~0
"def gcd(a,b):\n     while b!=0:\n         a,b=b,a%b\n     return a\n x1,y1,x2,y2=map(int,input().split())\n print(gcd(abs(x2-x1),abs(y2-y1))+1)\n "~0
"def F1(a,b):\n     while b!=0:\n         a,b=b,a%b\n     return a\n def F2(a,b):\n     return a*b//F1(a,b)\n q=int(input())\n n=list(map(int,input().split()))\n if q==1:\n     print(n[0]+1)\n else:  \n     a=F2(n[0]+1,n[1]+1)\n     for i in range(2,q):\n         a=F2(a,n[i]+1)\n     print(a)\n "~0
"def fpow(x,y):\n     global m\n     if y==0:\n         return 1\n     if y%2==1:\n         return fpow(x%m,y-1)*x%m\n     else:\n         return fpow(x*x%m,y//2)%m\n x,m=map(int,input().split())\n if fpow(x,x)==0:\n     print('YES')\n else:\n     print('NO')\n "~0
"n=int(input())\n for i in range(n):\n     a,b=map(int,input().split('/'))\n     q,w=a,b\n     while b!=0:\n         a,b=b,a%b\n     print(str(q//a)+'/'+str(w//a))\n "~0
"def prime(x):\n     dict={}\n     q=[]\n     d=2\n     while d*d<=x:\n         if x%d==0:\n             if d in dict:\n                 dict[d]=dict[d]+1\n             else:\n                 dict[d]=1\n                 q.append(d)\n             x//=d\n         else:\n             d+=1\n     if x in dict:\n         dict[x]=dict[x]+1\n     else:\n         q.append(x)\n         dict[x]=1\n     return dict,q\n n=int(input())\n dict,q=prime(n)\n ans=''\n for i in q:\n     if dict[i]==1:\n         ans+=str(i)+'*'\n     else:\n         ans+=str(i)+'^'+str(dict[i])+'*'\n print(ans[:-1])\n "~0
"def ext_gcd(a, b):\n     if b == 0:\n         return a, 1, 0\n     g, x, y = ext_gcd(b, a % b)\n     return g, y, x - a // b * y\n \n \n a, b, c = map(int, input().split())\n res = ext_gcd(a, b)\n x0 = res[1]\n y0 = res[2]\n g = res[0]\n ans = []\n for i in range(-1000, 1001):\n     x = x0 * (c // g) + (b // g) * i\n     y = y0 * (c // g) - (a // g) * i\n     if a * x + b * y == c and x > 0 and y > 0:\n         ans.append((x, y))\n ans.sort(key = lambda x: x[0])\n print(len(ans))\n for i in range(len(ans)):\n     print(*ans[i])\n "~1
"x, k = map(int, input().split())\n x1 = x\n arr = [1] * 1000000\n for i in range(1, len(arr)):\n     if arr[i] == 1:\n         for j in range((i + 1) * (i + 1) - 1, len(arr), i + 1):\n             arr[j] = 0\n sq = []\n for i in range(len(arr)):\n     if arr[i] == 1:\n         sq.append(i + 1)\n cnt = dict()\n d = 2\n while d * d <= x:\n     if x % d == 0:\n         x //= d\n         cnt[d] = cnt.get(d, 0) + 1\n     else:\n         d += 1\n cnt[x] = cnt.get(x, 0) + 1\n summa = 0\n for key in cnt:\n     summa += cnt[key]\n if summa < k:\n     print(-1)\n else:\n     for key in cnt:\n         while k > 1 and cnt[key] > 0:\n             print(key, end = " ")\n             x1 //= key\n             cnt[key] -= 1\n             k -= 1\n     print(x1)\n "~1
"n = int(input())\n a = list(map(int, input().split()))\n arr = [1] * 1000000\n for i in range(1, len(arr)):\n     if arr[i] == 1:\n         for j in range((i + 1) * (i + 1) - 1, len(arr), i + 1):\n             arr[j] = 0\n sq = []\n for i in range(len(arr)):\n     if arr[i] == 1:\n         sq.append((i + 1) * (i + 1))\n for i in range(n):\n     l = -1\n     r = len(sq) - 1\n     while r - l > 1:\n         mid = (r + l) // 2\n         if sq[mid] < a[i]:\n             l = mid\n         else:\n             r = mid\n     if (not sq[r] == a[i]) or a[i] == 1:\n         print("NO")\n     else:\n         print("YES")\n "~0
"l, r = map(int, input().split())\n if l == r:\n     print(l)\n else:\n     print(2)\n "~0
"import sys\n sys.set_int_max_str_digits(1000000)\n n = int(input())\n if n % 4 == 0:\n     print(4)\n else:\n     print(0)\n "~1
"l,r=map(int,input().split())\n if l==r and r%2==1: print(l)\n else: print(2)\n "~0
"n,k=map(int,input().split())\n d=2\n a=[]\n count=0\n while d*d<=n and count<k-1:\n     if n%d==0:\n         a.append(d)\n         n//=d\n         count+=1\n     else: d+=1\n a.append(n)\n if len(a)<k: print(-1)\n else: print(*a)\n "~0
"def prime(n):\n     d=2\n     while d*d<=n:\n         if n%d==0:\n             dict[d]=dict.get(d, 0)+1\n             n//=d\n         else:\n             d+=1\n     dict[n] = dict.get(n, 0) + 1\n n=int(input())\n o=10**9+7\n dict=dict()\n for i in range(2,n+1):\n     prime(i)\n p=1\n for i in dict.keys():\n     p=(p*(dict[i]+1)%o)%o\n print(p)\n "~0
"def fast_pow(a,n,m):\n     if n==0: return 1\n     elif n%2==1: return ((fast_pow(a,n-1,m)%m)*(a%m))%m\n     else:\n         x=a%m\n         return fast_pow(x*x,n//2,m)\n x,k=map(int,input().split())\n if fast_pow(x,x,k): print("NO")\n else: print("YES")\n "~0
"n = int(input())\n l = list(map(int, input().split()))\n count = [0] * 8\n for i in l:\n     count[i] += 1\n if count[5] > 0 or count[7] > 0:\n     print(-1)\n else:\n     e = min(count[4], count[2], count[1])\n     count[4] -= e\n     count[2] -= e\n     count[1] -= e\n     if count[6] == count[1] and count[6] == count[3] + count[2]:\n         for _ in range(e):\n             print(1, 2, 4)\n         for _ in range(count[2]):\n             print(1, 2, 6)\n         for _ in range(count[3]):\n             print(1, 3, 6)\n     else:\n         print(-1)\n "~1
"from string import ascii_uppercase\n  \n  \n a = input()\n _ = False\n Up = False\n for i in a:\n     if i in ascii_uppercase:\n         Up = True\n     if i == "_":\n         _ = True\n if _ == Up:\n     if _ == Up == 0:\n         print(a)\n     else:\n         print("Error!")\n elif "__" in a or a[0] == "_" or a[-1] == "_" or a[0] in ascii_uppercase:\n     print("Error!")\n else:\n     if "_" in a:\n         a = a.title()\n         a = a.replace("_", "")\n         a = a.replace(a[0], a[0].lower(), 1)\n         print(a)\n     else:\n         s = ""\n         for i in a:\n             if i.isupper():\n                 s += f"_{i.lower()}"\n             else:\n                 s += i\n         print(s)\n \n "~1
"a = int(input())\n s = []\n for i in range(a):\n     s.append(list(map(int, input().split())))\n input()\n k = list(map(int, input().split()))\n l = 0\n for i in range(a):\n     for j in range(i + 1, a):\n         if s[i][j] == 1 and k[i] != k[j]:\n             l += 1\n print(l)\n "~0
"def is_prime(s):\n     for i in range(2, int(__import__("math").sqrt(s)) + 1):\n         if s % i == 0:\n             return False\n     return True\n  \n  \n a = int(input())\n if is_prime(int("".join(sorted(str(a))))) and is_prime(int("".join(sorted(str(a), reverse=True)))):\n     print("Yes")\n else:\n     print("No")\n "~1
"n = int(input())\n petya = (n / 3) * 1.625\n vasya = (n / 3) * 0.5\n kolya = (n / 3) * 0.875\n print(int(petya), int(vasya), int(kolya))\n "~1
"a, b, c = input().split()\n a = set(a)\n b = set(b)\n c = set(c)\n a = a.intersection(b)\n a = a.intersection(c)\n print(len(a))\n if len(a) > 0:\n     a = sorted(a)\n     print(*a)\n "~0
"a, b = map(int, input().split())\n s = []\n for i in range(a):\n     s.append(list(map(int, input().split())))\n d = list(zip(*s))\n hori = [min(s[i]) for i in range(a)]\n vert = [max(d[i]) for i in range(b)]\n k = 0\n for i in range(a):\n     for j in range(b):\n         if s[i][j] == hori[i] and s[i][j] == vert[j]:\n             k += 1\n print(k)\n \n "~0
"# Получаем ввод числа\n n = int(input())\n # Внешний цикл для создания строк с числами от 1 до n\n for i in range(1, n + 1):\n     # Внутренний цикл для повторения числа i в строке i раз\n     for j in range(i):\n         print(i, end='')  # Выводим число i\n     print()  # Переходим на новую строку после каждой строки\n "~1
"# Получаем ввод числа\n n = int(input())\n # Находим середину пирамиды\n centr = n // 2 + 1\n # Инициализируем счетчик звездочек в строке\n count = 0\n # Проходим по строкам пирамиды от 1 до n\n for i in range(1, n + 1):\n     if i > centr:\n         count -= 1  # Если перешли за середину, уменьшаем количество звездочек\n     else:\n         count += 1  # В противном случае увеличиваем количество звездочек\n     \n     # Выводим звездочки в строке\n     for _ in range(count):\n         print('*', end='')\n     # Переходим на новую строку для следующей строки пирамиды\n     print()\n "~1
"a , b = int(input()), int(input())\n total_maximum = 0                 \n digit = 0                            \n for i in range(a, b + 1):         \n     maximum = 0                   \n     for j in range(1, i + 1):    \n         if i % j == 0:             \n             maximum += j         \n         if maximum >= total_maximum:  \n             total_maximum = maximum\n             digit = j\n print(digit, total_maximum)\n "~1
"n=int(input())\n while n > 9:       \n     s = 0    \n     while (n > 0):\n         last_digit = n % 10\n         s += last_digit\n         n = n // 10          \n     n = s\n     \n print(n)\n "~1
"num = int(input())\n total = 0\n factorial = 1 \n for i in range(1, num+1):\n     for j in range(1, i+1):\n         factorial *= j\n     total += factorial\n     factorial = 1\n print(total)\n "~1
"s = input()  # Считываем первую строку\n r = input()  # Считываем вторую строку\n # Преобразуем первую строку s в список символов\n # Затем объединяем символы из списка, используя вторую строку r в качестве разделителя\n res = r.join(list(s))\n # Выводим результат\n print(res)\n "~1
"def quick_merge(lst1, lst2):\n     res = []       # Результирующий список\n     p1, p2 = 0, 0  # Индексы текущих элементов для lst1 и lst2\n     # Пока есть элементы в обоих списках, сравниваем их и добавляем минимальный в res\n     while p1 < len(lst1) and p2 < len(lst2):\n         if lst1[p1] < lst2[p2]:\n             res.append(lst1[p1])\n             p1 += 1\n         else:\n             res.append(lst2[p2])\n             p2 += 1\n     # Если все элементы lst1 были добавлены, добавляем оставшиеся элементы lst2 и наоборот\n     if p1 == len(lst1):\n         res += lst2[p2:]\n     else:\n         res += lst1[p1:]\n     return res\n res = []  # Результирующий список\n # Считываем количество списков для сортировки\n for _ in range(int(input())):\n     num = [int(c) for c in input().split()]  # Считываем список чисел\n     res = quick_merge(res, num)  # Вызываем quick_merge() для сортировки и объединения списков\n # Выводим отсортированный результирующий список\n print(*res)\n "~1
"\n def merge(list1, list2):\n     l = list1 + list2\n     \n     l.sort()\n     \n     return l\n \n numbers1 = [int(c) for c in input().split()]\n numbers2 = [int(c) for c in input().split()]\n \n print(merge(numbers1, numbers2))\n "~1
"def get_factors(num):\n     l = []\n     for i in range(1, num // 2 + 1):  \n         if num % i == 0: \n             l.append(i)\n     l.append(num)  \n     return l\n \n n = int(input())\n \n print(get_factors(n))\n "~1
"def convert_to_miles(km):\n     return km * 0.6214\n \n num = int(input())\n \n print(convert_to_miles(num))\n "~1
"def get_middle_point(x1, y1, x2, y2):\n     return (x1 + x2) / 2, (y1 + y2) / 2\n \n x_1, y_1 = int(input()), int(input())\n x_2, y_2 = int(input()), int(input())\n \n x, y = get_middle_point(x_1, y_1, x_2, y_2)\n print(x, y)\n "~1
"import math\n def get_circle(radius):\n     return 2 * math.pi * radius, math.pi * (radius ** 2)\n \n r = float(input())\n \n length, square = get_circle(r)\n print(length, square)\n "~1
"def is_palindrome(num):\n     return str(num) == str(num)[::-1]\n \n def is_prime(num):\n     if num == 1:\n         return False\n     \n     for i in range(2, int(num ** 0.5) + 1):\n         if num % i == 0:\n             return False\n         \n     return True\n \n def is_even(num):\n     return num % 2 == 0\n \n def is_valid_password(password):\n     l = password.split(":")\n     \n     if len(l) == 3:  \n         l = [int(el) for el in l]\n         a, b, c = l[0], l[1], l[2]\n         return is_palindrome(a) and is_prime(b) and is_even(c)\n     \n     return False\n \n psw = input()\n \n print(is_valid_password(psw))\n "~1
"a = int(input())\n b = int(input())\n c = int(input())\n d = int(input())\n spisok=[]\n for i in range(c+ (a-c+d-1)//d*d, b+1, d):\n     spisok.append(i)\n print(*spisok)\n "~1
"n = int(input())\n c3 = n // 60\n c2 = (n % 60) // 10\n c1 = n % 10\n if c1 * 15 > 125:\n   c1 = 0\n   c2 += 1\n if c1 * 15 + c2 * 125 > 440:\n   c1 = 0\n   c2 = 0\n   c3 += 1\n print(c1, c2, c3)\n "~0
"def ToLower(S):\n   return s.lower()\n \n s = input()\n print(ToLower(s))\n "~1
"a = int(input())\n if a == 0:\n     print(0)\n else:\n     fib_prev, fib_next = 0, 1\n     n = 1\n     while fib_next <= a:\n         if fib_next == a:\n             print(n)\n             break\n         fib_prev, fib_next = fib_next, fib_prev + fib_next\n         n += 1\n     else:\n         print(-1)\n "~1
"n = int(input())\n l = []\n while n != 0:\n     l.append(n)\n     n = int(input())\n l.remove(max(l))\n print(max(l))\n "~0
"a, b, c = map(int, input().split())\n print(str(a) + "+" + str(b) + "+" + str(c) + "=" + str(a + b + c))\n print(str(a) + "*" + str(b) + "*" + str(c) + "=" + str(a * b * c))\n print("(" + str(a) + "+" + str(b) + "+" + str(c) + ")" + "/3" + "=" + str(f'{((a + b + c) / 3):.3f}'))\n "~1
"s = input()\n if len(s) % 2 == 0:\n     print(s[-(len(s) // 2):] + s[:-(len(s) // 2)])\n else:\n     print(s[-(len(s) // 2):] + s[:-(len(s) // 2)])\n "~0
"n = int(input())\n a = list(map(int, input().split()))\n m = int(input())\n for i in range(m):\n     s = input().split()\n     x, y = int(s[0]), int(s[1])\n     print(sum(a[x - 1:y]))\n "~0
"n = int(input())\n a = [int(i) for i in input().split()]\n pref = [0] * (n + 1)\n minpref = 10 ** 4 + 1\n imn = 0\n jmx = 1\n maxsumm = -10 ** 8\n for i in range(1, len(pref)):\n     pref[i] = pref[i - 1] + a[i - 1]\n \n for i in range(1, len(pref)):\n     if pref[i] < minpref:\n         minpref = pref[i - 1]\n         imn = i - 1\n     if pref[i] - pref[imn] > maxsumm:\n         maxsumm = pref[i] - pref[imn]\n         jmx = i\n         imnotv = imn + 2\n print(imnotv, jmx, maxsumm + 1)\n "~1
"s = list(map(int, input().split()))\n n, r = s[0], s[1]\n i = 0\n j = 1\n cnt = 0\n a = list(map(int, input().split()))\n \n while j < n:\n     if a[j] - a[i] <= r:\n         j += 1\n     else:\n         i += 1\n         cnt += n - j\n \n print(cnt)\n "~0
"s = input()\n l = []\n c = 0\n for i in s:\n     try:\n         a = int(i)\n         c += 1\n     except:\n         a = 0\n print(c)\n "~0
"s = ''\n stack = []\n while s != "exit":\n     s = input()\n     if "push_front" in s:\n         stack.insert(0, s.split()[1])\n     elif "push_back" in s:\n         stack.append(s.split()[1])\n     elif "pop_front" in s:\n         if len(stack) != 0:\n             print(stack.pop(0))\n         else:\n             print("error")\n     elif "pop_back" in s:\n         if len(stack) != 0:\n             print(stack.pop(-1))\n         else:\n             print("error")\n     elif "size" in s:\n         print(len(stack))\n     elif "clear" in s:\n         stack.clear()\n         print("ok")\n     elif "front" in s:\n         if len(stack) != 0:\n             print(stack[0])\n         else:\n             print("error")\n     elif "back" in s:\n         if len(stack) != 0:\n             print(stack[-1])\n         else:\n             print("error")\n     elif "exit" in s:\n         print("bye")\n "~0
"s = input()\n l = []\n for i in s:\n     l.append(i)\n for i in range(len(s)):\n     if (l[i] == "(" and l[i + 1] == ")") or (l[i] == "[" and l[i + 1] == "]") or (l[i] == "{" and l[i + 1] == "}"):\n         l.pop(i)\n         l.pop(i + 1)\n print(l)\n "~0
"a1, a2, a3 = map(int, input().split())\n b1, b2, b3 = map(int, input().split())\n n = 0\n m = 0\n k = 0\n l = 0\n ans = 0\n if a1 > b1:\n     n = a1 - b1\n     ans += b1\n else:\n     k = b1 - a1\n     ans += a1\n \n if a2 > b2:\n     m = a2 - b2\n     ans += b2\n else:\n     l = b2 - a2\n     ans += a2\n \n if a3 > b3:\n     ans += b3\n     ans += min(k + l, a3 - b3)\n else:\n     ans += a3\n     ans += min(n + m, b3 - a3)\n \n print(ans)\n "~0
"import math\n \n n = int(input())\n for i in range(n):\n     m = int(input())\n     if len(str(m)) < 3 or len(str(m)) > 6:\n         print("NO")\n         continue\n     s = str(m)\n     ln = len(s)\n     flag = False\n     for j in range(math.ceil(ln / 3), ln - 1):\n         a = int(s[:j])\n         for k in range(j + math.ceil((ln - j) / 2), ln):\n             b = int(s[j:k])\n             c = int(s[k:])\n             if c <= b <= a < 19:\n                 flag = True\n                 break\n         if flag:\n             break\n     if flag:\n         print("YES")\n     else:\n         print("NO")\n \n "~0
"n = int(input())\n l = list(map(int, input().split()))\n ans = 0\n for i in range(n):\n     ans += i\n if float(l[0]) >= l[n - 1] * 0.8:\n     print(ans)\n else:\n     for i in range(n):\n         for j in range(i + 1, n):\n             if float(l[i]) < l[j]*0.8:\n                 ans -= n - j\n                 break\n     print(ans)\n \n \n "~0
"cnt = 0\n def f(t):\n     global cnt\n     for i in list(range(1, len(t) + 1))[::-1]:\n         if t[:i] == t[:i][::-1]:\n             cnt += 1\n             f(t[i:])\n             break\n \n s = input()\n f(s)\n print(cnt)\n "~0
"n = int(input())\n l = list(map(int, input().split()))\n x = 0\n y = 0\n k = 1\n while x + y != n - 1:\n     if k == 1:\n         if l[x] > l[n - y - 1]:\n             y+=1\n         else:\n             x += 1\n         k = 2\n     else:\n         if l[x] < l[n - y - 1]:\n             y+=1\n         else:\n             x += 1\n         k = 1\n print(l[x])\n "~0
"import math\n \n def extended_gcd(a, b):\n     if b == 0:\n         return (a, 1, 0)\n     else:\n         g, x, y = extended_gcd(b, a % b)\n         return (g, y, x - (a // b) * y)\n \n a, b, c = map(int, input().split())\n g, x, y = extended_gcd(a, b)\n if c % g != 0:\n     print("Impossible")\n else:\n     k = c // g\n     x0 = x * k\n     y0 = y * k\n     # x0 + (b/g)*t >= 0 => t >= -x0 * g / b\n     b_div_g = b // g\n     a_div_g = a // g\n     t = (-x0) // b_div_g\n     min_x = None\n     best_t = None\n     for possible_t in [t - 1, t, t + 1, t + 2]:\n         current_x = x0 + b_div_g * possible_t\n         if current_x >= 0:\n             if min_x is None or current_x < min_x:\n                 min_x = current_x\n                 best_t = possible_t\n     if min_x is not None:\n         x_ans = x0 + b_div_g * best_t\n         y_ans = y0 - a_div_g * best_t\n         print(x_ans, y_ans)\n     else:\n         print("Impossible")\n "~1
"import math\n \n def sieve(max_num):\n     is_prime = [True] * (max_num + 1)\n     is_prime[0] = is_prime[1] = False\n     for i in range(2, int(math.sqrt(max_num)) + 1):\n         if is_prime[i]:\n             for j in range(i * i, max_num + 1, i):\n                 is_prime[j] = False\n     return is_prime\n \n input = input().split()\n N = int(input[0])\n numbers = list(map(int, input[1:N+1]))\n max_num = max(numbers)\n is_prime = sieve(max_num)\n output = []\n for num in numbers:\n     output.append('1' if is_prime[num] else '0')\n print(''.join(output))\n "~1
"n = int(input())\n \n if n % 2 == 0:\n     k = n // 2\n     print(k)\n     print(' '.join(['2'] * k))\n else:\n     k = (n - 3) // 2 + 1\n     print(k)\n     print(' '.join(['2'] * ((n - 3) // 2) + ['3']))\n "~1
"def factorize(k):\n     factors = {}\n     # Обрабатываем делитель 2 отдельно\n     if k % 2 == 0:\n         count = 0\n         while k % 2 == 0:\n             count += 1\n             k = k // 2\n         factors[2] = count\n     # Проверяем нечетные делители от 3 до sqrt(k)\n     i = 3\n     max_factor = int(k**0.5) + 1\n     while i <= max_factor:\n         if k % i == 0:\n             count = 0\n             while k % i == 0:\n                 count += 1\n                 k = k // i\n             factors[i] = count\n             max_factor = int(k**0.5) + 1\n         i += 2\n     if k > 1:\n         factors[k] = 1\n     return factors\n \n def count_p_in_factorial(n, p):\n     count = 0\n     power = p\n     while power <= n:\n         count += n // power\n         power *= p\n     return count\n \n n, k = map(int, input().split())\n factors = factorize(k)\n min_zeros = float('inf')\n \n for p, m in factors.items():\n     cnt = count_p_in_factorial(n, p)\n     min_zeros = min(min_zeros, cnt // m)\n \n print(min_zeros)\n "~1
"import heapq\n \n n, k = map(int, input().split())\n servers = []\n for _ in range(k):\n     heapq.heappush(servers, (0, _))  # (время освобождения, номер сервера)\n \n output = []\n for _ in range(n):\n     s, m = map(int, input().split())\n     free_time, server_id = heapq.heappop(servers)\n     start_time = max(free_time, s)\n     end_time = start_time + m\n     output.append(end_time)\n     heapq.heappush(servers, (end_time, server_id))\n \n print('\n '.join(map(str, output)))\n "~1
"def getdivs(n):\n     start = []\n     end = []\n     i = 1\n     while i * i < n:\n         if n % i == 0:\n             start.append(i)\n             end.append(n // i)\n         i += 1\n     if i * i == n:\n         start.append(i)\n \n     return start, end\n \n def getelem(k):\n     if len(start) > k:\n         return start[k]\n     elif len(start) + len(end) > k:\n         return end[-k + len(start) -1]\n     \n def gcd(a, b):\n     while b != 0:\n         a, b = b, a % b\n     return a\n     \n n = int(input())\n start, end = getdivs(n)\n result = 0\n for i in range(len(start) + len(end) - 1):\n     for j in range(i + 1, len(start) + len(end)):\n         if gcd(getelem(i), getelem(j)) == 1 and getelem(i) * getelem(j) <= n:\n             result += 1\n print(result)\n "~0
"def gcd(a, b):\n     while b != 0:\n         a, b = b, a % b\n     return a\n \n n = int(input())\n for i in range(n):\n     a, b = map(int, input().split(sep = "/"))\n     g = gcd(a, b)\n     print(str(a // g) + "/" + str(b // g))\n "~0
"def pow(a, n):\n     a %= k\n     if n == 1:\n         return a\n     if n % 2 == 1:\n         return pow(a, n - 1) * a\n     else:\n         return pow(a * a, n // 2)\n     \n x, k = map(int, input().split())\n \n if pow(x, x) % k == 0:\n     print("YES")\n else:\n     print("NO")\n "~0









"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n     int n;\n     cin >> n;\n     vector <int> s(n);\n     vector <pair <int, int>> b;\n     for (int i = 0; i < n; i++) {\n         cin >> s[i];\n         if (b.empty()) {\n             b.push_back({s[i], 1});\n         } else {\n             if (b.back().first == s[i]) {\n                 b.back().second++;\n             } else {\n                 b.push_back({s[i], 1});\n             }\n         }\n     }\n     int mn = LLONG_MAX;\n     for (auto i: b) {\n         mn = min(mn, i.first * (n - i.second));\n     }\n     cout << mn << "\n ";\n }\n \n signed main() {\n     int t = 1;\n     cin >> t;\n     while (t--) {\n         solve();\n     }\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n     int n;\n     cin >> n;\n     int a[3];\n     a[0] = 0, a[1] = 0, a[2] = 0;\n     int k = 0;\n     while (a[0] < n || a[1] < n || a[2] < n) {\n         k++;\n         int mn = min({a[0], a[1], a[2]});\n         if (a[0] == mn) {\n             a[0] = min(a[1], a[2]) * 2 + 1;\n         } else if (a[1] == mn) {\n             a[1] = min(a[0], a[2]) * 2 + 1;\n         } else {\n             a[2] = min(a[0], a[1]) * 2 + 1;\n         }\n     }\n     cout << k << "\n ";\n }\n \n signed main() {\n     int t = 1;\n     cin >> t;\n     while (t--) {\n         solve();\n     }\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n void solve() {\n 	int a, b, c, d;\n 	cin >> a >> b >> c >> d; // flower - b, d; gellyfish - a, c\n 	if (min(a, c) < min(b, d)) {\n 		cout << "Flower" << "\n ";\n 	} else {\n 		cout << "Gellyfish" << "\n ";\n 	}\n }\n \n signed main() {\n 	int t = 1;\n 	cin >> t;\n 	while (t--) {\n 		solve();\n 	}\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n 	string s1, s2;\n 	cin >> s1 >> s2;\n 	vector <pair <char, int>> t1, t2;\n 	for (int i = 0; i < s1.size(); i++) {\n 		if (!t1.empty()) {\n 			if (s1[i] == t1.back().first) {\n 				t1.back().second++;\n 			} else {\n 				t1.push_back({s1[i], 1});\n 			}\n 		} else {\n 			t1.push_back({s1[i], 1});\n 		}\n 	}\n 	for (int i = 0; i < s2.size(); i++) {\n 		if (!t2.empty()) {\n 			if (s2[i] == t2.back().first) {\n 				t2.back().second++;\n 			} else {\n 				t2.push_back({s2[i], 1});\n 			}\n 		} else {\n 			t2.push_back({s2[i], 1});\n 		}\n 	}\n 	bool f = true;\n 	if (t1.size() == t2.size()) {\n 		for (int i = 0; i < t1.size(); i++) {\n 			if (t2[i].second > t1[i].second * 2 || t2[i].second < t1[i].second || t2[i].first != t1[i].first) {\n 				f = false;\n 				break;\n 			}\n 		}\n 	} else {\n 		f = false;\n 	}\n 	if (f) cout << "YES" << "\n ";\n 	else cout << "NO" << "\n ";\n 	return ;\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n 	int n;\n 	cin >> n;\n 	vector <int> ans(2 * n);\n 	for (int i = 0; i < n; i++) {\n 		for (int j = 0; j < n; j++) {\n 			cin >> ans[i + j];\n 		}\n 	}\n 	vector <int> t = ans;\n 	sort(t.begin(), t.end());\n 	int x = 1, y = 0;\n 	for (auto i: t) {\n 		if (i == 0) continue;\n 		if (i != x) {\n 			cout << x << " ";\n 			y = 1;\n 			break;\n 		}\n 		x++;\n 	}\n 	if (y == 0) cout << x << " ";\n 	for (auto i: ans) if (i != 0) cout << i << " ";\n 	cout << "\n ";\n 	return ;\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n 	int a, b, c, d;\n 	cin >> a >> b >> c >> d;\n 	b = a - b;\n 	while (c < 0 && b) {\n 		b--;\n 		c++;\n 	}\n 	while (d > 0 && b) {\n 		b--;\n 		d--;\n 	}\n 	cout << c << " " << d << "\n ";\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n void solve() {\n 	string s1, s2, s3;\n 	cin >> s1 >> s2 >> s3;\n 	cout << s1[0] << s2[0] << s3[0] << "\n ";\n 	return ;\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n \n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n #define int long long\n \n signed main() {\n 	int n;\n 	cin >> n;\n 	for (int i = 0; i < n; i++) {\n 		int a;\n 		cin >> a;\n 		if (a == 1 || a == 3) {\n 			cout << -1 << endl;\n 			continue;\n 		}\n 		vector <int> s(a, 0);\n 		s[0] = 6;\n 		s[1] = 6;\n 		if (a % 2 == 0) {\n 			for (int j = 2; j < a; j++) {\n 				s[j] = 3;\n 			}\n 		} else {\n 			s[3] = 6;\n 			for (int j = 2; j < a; j++) {\n 				if (!s[j]) {\n 					s[j] = 3;\n 				}\n 			}\n 		}\n 		reverse(s.begin(), s.end());\n 		for (auto j: s) {\n 			cout << j;\n 		}\n 		cout << endl;\n 	}\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n #define int long long\n \n signed main() {\n 	int n;\n 	cin >> n;\n 	for (int i = 0; i < n; i++) {\n 		int a, b, c, d;\n 		cin >> a >> b >> c >> d;\n 		int ans = (a - c) * b;\n 		ans += (a - c) * (b - 1);\n 		ans += b - d;\n 		cout << ans << endl;\n 	}\n 	return 0;\n }\n \n \n "~0
"#include <bits/stdc++.h>\n  \n using namespace std;\n \n int main() {\n     int n;\n     cin >> n;\n     for (int i = 0; i < n; i++) {\n     	int x;\n     	cin >> x;\n     	cout << x % 10 + x / 10 << endl;\n     }\n     return 0;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <math.h>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n #define all(a) a.begin(), a.end()\n #ifdef LOCAL\n #define debug(x) cerr << __LINE__ << ": " << (#x) << " = " << x << endl;\n #endif\n \n using namespace std;\n \n ll bin_pow(ll a, ll b, ll m) {\n 	if (b == 0) {\n 		return 1;\n 	}\n 	else if (b % 2 == 1) {\n 		return (bin_pow(a, b - 1, m) * a) % m;\n 	}\n 	else {\n 		return bin_pow((a * a) % m, b / 2, m);\n 	}\n }\n \n ll gcd(ll a, ll b) {\n 	while (a != 0 and b != 0) {\n 		if (a < b) {\n 			swap(a, b);\n 		}\n 		a %= b;\n 	}\n 	if (a == 0)\n 		return b;\n 	else\n 		return a;\n }\n \n \n int main() {\n 	int l = 2, r;\n 	cin >> r;\n 	vector <int> a;\n 	vector <bool> vis(r + 1, false);\n 	vector <int> vs(r + 1, 0);\n 	vector <int> prime;\n 	for (int i = 2; i * i <= r; i++) {\n 		if (!vis[i]) {\n 			int c = i * i;\n 			while (c <= r) {\n 				vis[c] = true;\n 				c += i;\n 			}\n 		}\n 	}\n 	for (int i = l; i <= r; i++) {\n 		if (!vis[i] and i != 1) {\n 			prime.push_back(i);\n 		}\n 	}\n 	for (auto i : prime) {\n 		int c = i;\n 		while (c <= r) {\n 			vs[c]++;\n 			c += i;\n 		}\n 	}\n 	for (int i = 2; i <= r; i++) {\n 		if (vs[i] >= 3) {\n 			cout << i << " ";\n 		}\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <math.h>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n #define all(a) a.begin(), a.end()\n #ifdef LOCAL\n #define debug(x) cerr << __LINE__ << ": " << (#x) << " = " << x << endl;\n #endif\n \n using namespace std;\n \n ll bin_pow(ll a, ll b, ll m) {\n 	if (b == 0) {\n 		return 1;\n 	}\n 	else if (b % 2 == 1) {\n 		return (bin_pow(a, b - 1, m) * a) % m;\n 	}\n 	else {\n 		return bin_pow((a * a) % m, b / 2, m);\n 	}\n }\n \n ll gcd(ll a, ll b) {\n 	while (a != 0 and b != 0) {\n 		if (a < b) {\n 			swap(a, b);\n 		}\n 		a %= b;\n 	}\n 	if (a == 0)\n 		return b;\n 	else\n 		return a;\n }\n \n \n int main() {\n 	int n, l = INT_MAX, r = INT_MIN;\n 	cin >> n;\n 	vector <int> b(n);\n 	for (int i = 0; i < n; i++) {\n 		cin >> b[i];\n 		if (b[i] < l) {\n 			l = b[i];\n 		}\n 		if (b[i] > r) {\n 			r = b[i];\n 		}\n 	}\n 	vector <int> a;\n 	vector <bool> vis(r + 1, false);\n 	vector <int> prime;\n 	for (int i = 2; i * i <= r; i++) {\n 		if (!vis[i]) {\n 			int c = i * i;\n 			while (c <= r) {\n 				vis[c] = true;\n 				c += i;\n 			}\n 		}\n 	}\n 	for (auto i : b) {\n 		if (i == 1) {\n 			cout << 0;\n 			continue;\n 		}\n 		if (!vis[i]) {\n 			cout << 1;\n 		}\n 		else {\n 			cout << 0;\n 		}\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <math.h>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n #define all(a) a.begin(), a.end()\n #ifdef LOCAL\n 	#define debug(x) cerr << __LINE__ << ": " << (#x) << " = " << x << endl;\n #endif\n \n using namespace std;\n \n int mod = 1e9 + 9;\n \n ll bin_pow(ll a, ll b, ll m) {\n 	if (b == 0) {\n 		return 1;\n 	}\n 	else if (b % 2 == 1) {\n 		return (bin_pow(a, b - 1, m) * a) % m;\n 	}\n 	else {\n 		return bin_pow((a * a) % m, b / 2, m);\n 	}\n }\n \n ll gcd(ll a, ll b) {\n 	while (a != 0 and b != 0) {\n 		if (a < b) {\n 			swap(a, b);\n 		}\n 		a %= b;\n 	}\n 	if (a == 0)\n 		return b;\n 	else\n 		return a;\n }\n \n vector <ll> gcd_ext(ll a, ll b) {\n 	if (b == 0) {\n 		return { a, 1, 0 };\n 	}\n 	vector <ll> p = gcd_ext(b, a % b);\n 	ll d = p[0];\n 	ll x = p[1];\n 	ll y = p[2];\n 	return { d, y, x - (a / b) * y };\n }\n \n \n int main() {\n 	ll a, b, c;\n 	cin >> a >> b >> c;\n 	vector <ll> p = gcd_ext(a, b);\n 	ll d = p[0];\n 	ll x = p[1];\n 	ll y = p[2];\n 	if (c % d != 0) {\n 		cout << "Impossible";\n 		return 0;\n 	}\n 	a /= d;\n 	b /= d;\n 	c /= d;\n 	x = x * c;\n 	y = y * c;\n 	if (x < 0) {\n 		while (x < 0) {\n 			x += b;\n 			y -= a;\n 		}\n 	}\n 	else {\n 		y += a * (x / b);\n 		x %= b;\n 	}\n 	cout << x << " " << y;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n \n using namespace std;\n \n unsigned ll f(unsigned ll m, vector <unsigned ll>& d) {\n 	unsigned ll sm = 0;\n 	for (int i = 0; i < d.size(); i++) {\n 		sm += min(m, d[i]);\n 	}\n 	return sm;\n }\n \n int main() {\n 	map <string, vector <string>> a;\n 	bool f = false;\n 	string namef;\n 	while (true) {\n 		string t;\n 		cin >> t;\n 		if (t == "endprg") {\n 			break;\n 		}\n \n 		if (t == "function") {\n 			f = true;\n 			cin >> namef;\n 			continue;\n 		}\n \n 		if (t == "end") {\n 			f = false;\n 		}\n \n 		if (f) {\n 			if (t == "print") {\n 				string h;\n 				cin >> h;\n 				a[namef].push_back(h);\n 			}\n 			else if (t == "call") {\n 				string h;\n 				cin >> h;\n 				for (auto i : a[h]) {\n 					a[namef].push_back(i);\n 				}\n 			}\n 		}\n 		else {\n 			if (t == "print") {\n 				string h;\n 				cin >> h;\n 				cout << h << endl;\n 			}\n 			else if (t == "call") {\n 				string h;\n 				cin >> h;\n 				for (auto i : a[h]) {\n 					cout << i << endl;\n 				}\n 			}\n 		}\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n \n using namespace std;\n \n int main() {\n 	int n;\n 	cin >> n;\n 	vector <int> a(n);\n 	vector <int> ans(n, n);\n 	stack <pair<int, int>> st;\n 	for (int i = 0; i < n; i++) {\n 		int t;\n 		cin >> t;\n 		a[i] = t;\n 		while (!st.empty() && st.top().first < t) {\n 			ans[st.top().second] = i;\n 			st.pop();\n 		}\n 		st.push({ t, i });\n 	}\n \n 	vector <int> ans2(n, -1);\n 	stack <pair<int, int>> st2;\n 	for (int i = n - 1; i >= 0; i--) {\n 		while (!st2.empty() && st2.top().first < a[i]) {\n 			ans2[st2.top().second] = i;\n 			st2.pop();\n 		}\n 		st2.push({ a[i], i });\n 	}\n \n 	for (int i = 0; i < n; i++) {\n 		int sm = 0;\n 		if (abs(ans[i] - i) >= 1) {\n 			sm += abs(ans[i] - i) - 1;\n 		}\n \n 		if (abs(ans2[i] - i) >= 1) {\n 			sm += abs(ans2[i] - i) - 1;\n 		}\n 		cout << sm + 1 << " ";\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <stack>\n #define ll long long\n \n using namespace std;\n \n ll f(ll n, ll m, ll d) {\n 	return n * d * 2 + m * d * 2 - d * d * 4;\n }\n \n int main() {\n 	ll n, m, t;\n 	cin >> n >> m >> t;\n 	ll l = -1, r = max(n, m) / 2 + 1;\n 	while (l + 1 < r) {\n 		ll d = (l + r) / 2;\n 		if (f(n, m, d) <= t) {\n 			l = d;\n 		}\n 		else {\n 			r = d;\n 		}\n 	}\n 	cout << l;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n using namespace std;\n #define ll long long\n \n unsigned ll n, k;\n \n void f(int t, vector <int>& a) {\n 	int l = 0, r = a.size();\n 	while (l + 1 < r) {\n 		int m = (l + r) / 2;\n 		if (a[m] > t) {\n 			r = m;\n 		}\n 		else {\n 			l = m;\n 		}\n 	}\n 	if (a[l] == t) {\n 		cout << l + 1 << " ";\n 	}\n 	else {\n 		cout << "-1 ";\n 	}\n }\n \n int main() {\n 	int n;\n 	cin >> n;\n 	vector <int> a(n);\n 	for (int i = 0; i < n; i++) {\n 		cin >> a[i];\n 	}\n \n 	int m;\n 	cin >> m;\n 	for (int i = 0; i < m; i++) {\n 		int t;\n 		cin >> t;\n 		f(t, a);\n 	}\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n using namespace std;\n #define ll long long\n \n int main() {\n 	double c;\n 	cin >> c;\n 	double l = 0.0, r = c;\n 	for (int i = 0; i < 100; i++) {\n 		double m = (r + l) / 2;\n 		if (m * m + sqrt(m) >= c) {\n 			r = m;\n 		}\n 		else {\n 			l = m;\n 		}\n 	}\n 	cout << setprecision(6) << fixed << r;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n #include <deque>\n using namespace std;\n #define ll long long\n \n int main() {\n 	int n, p = 0, q = 0;\n 	bool al = true;\n 	cin >> n;\n 	deque <int> a;\n 	for (int i = 0; i < n; i++) {\n 		int t;\n 		cin >> t;\n 		a.push_back(t);\n 	}\n 	while (!a.empty()) {\n \n 		if (a.size() == 1) {\n 			if (al) {\n 				p++;\n 			}\n 			else {\n 				q++;\n 			}\n 			a.pop_front();\n 			continue;\n 		}\n \n 		if (a.front() < a.back()) {\n 			p++;\n 			int k = a.back();\n 			a.pop_back();\n 			a.push_back(k - a.front());\n 			a.pop_front();\n 			al = false;\n 		}\n 		else if (a.front() == a.back()) {\n 			a.pop_back();\n 			a.pop_front();\n 			p++;\n 			q++;\n 			al = true;\n 		}\n 		else {\n 			q++;\n 			int k = a.front();\n 			a.pop_front();\n 			a.push_front(k - a.back());\n 			a.pop_back();\n 			al = true;\n 		}\n 	}\n 	cout << p << " " << q;\n }\n "~0
"#include <iostream>\n #include <cmath>\n #include <vector>\n #include <climits>\n #include <string>\n #include <set>\n #include <map>\n #include <algorithm>\n #include <unordered_map>\n #include <iomanip>\n using namespace std;\n #define ll long long\n \n int main() {\n 	int n, k;\n 	cin >> n >> k;\n 	vector <int> a(n);\n 	vector <int> suff(n + 1);\n 	vector <int> suffi(n + 1);\n 	suff[n] = INT_MIN;\n 	suffi[n] = -1;\n 	for (int i = 0; i < n; i++) {\n 		cin >> a[i];\n 	}\n 	for (int i = n - 1; i >= 0; i--) {\n 		if (a[i] > suff[i + 1]) {\n 			suff[i] = a[i];\n 			suffi[i] = i;\n 		}\n 		else {\n 			suff[i] = suff[i + 1];\n 			suffi[i] = suffi[i + 1];\n 		}\n 	}\n 	int mx = INT_MIN;\n 	int mxi = INT_MIN;\n 	int mxj = INT_MIN;\n 	for (int i = 1; i < n - k; i++) {\n 		int j = i + k + 1;\n 		if (suff[j - 1] - a[i - 1] > mx) {\n 			mx = suff[j - 1] - a[i - 1];\n 			mxi = i;\n 			mxj = suffi[j - 1] + 1;\n 		}\n 	}\n 	cout << mxi << " " << mxj << endl;\n 	cout << mx;\n }\n "~0
"#include <iostream>\n #include <vector>\n using namespace std;\n typedef long long ll;\n \n ll gcd(ll a, ll b) {\n   while (a && b) {\n     if (a > b)\n       a %= b;\n     else\n       b %= a;\n   }\n   return a + b;\n }\n \n ll lcm(ll a, ll b) {\n   return a / gcd(a, b) * b;\n }\n \n int main() {\n   int n;\n   cin >> n;\n   vector<pair<ll, ll>> drobi(n);\n   char hlam;\n   for (int i = 0; i < n; i++)\n     cin >> drobi[i].first >> hlam >> drobi[i].second;\n   for (auto &[a, b] : drobi) {\n     ll x = gcd(a, b);\n     a /= x;\n     b /= x;\n     cout << a << "/" << b << "\n ";\n   }\n }\n "~0
"#include <iostream>\n using namespace std;\n \n int gcd(int a, int b, int &x, int &y) {\n   if (a == 0) {\n     x = 0;\n     y = 1;\n     return b;\n   }\n   int x1, y1;\n   int d = gcd(b % a, a, x1, y1);\n   x = y1 - (b / a) * x1;\n   y = x1;\n   return d;\n }\n \n int main() {\n   int x, y;\n   int a, b, c;\n   cin >> a >> b >> c;\n   int d = gcd(a, b, x, y);\n   if (c % d == 0) {\n     x *= (c / d);\n     y *= (c / d);\n     cout << d << " " << x << " " << y << "\n ";\n   } else\n     cout << "Impossible\n ";\n }\n "~0
"#include <algorithm>\n #include <deque>\n #include <iostream>\n #include <map>\n #include <queue>\n #include <set>\n #include <stack>\n #include <vector>\n using namespace std;\n typedef long long ll;\n \n void solve() {\n   int n, k;\n   cin >> k >> n;\n   vector<int> a(n + 1);\n   cin >> a[0];\n   for (int i = 1; i <= n; i++) {\n     cin >> a[i];\n     a[i] += a[i - 1];\n   }\n   map<char, string> seats;\n   for (char ch = 'A'; ch < 'A' + k; ch++)\n     seats[ch] = "Boring";\n   seats['A'] = "Window";\n   seats['A' + k - 1] = "Window";\n \n   for (int i = 0; i < n; i++) {\n     if (seats[a[i] + 'A' - 1] == "Window")\n       seats[a[i] + 'A' - 1] = "Both";\n     else\n       seats[a[i] + 'A' - 1] = "Aisle";\n     if (seats[a[i] + 'A'] == "Window")\n       seats[a[i] + 'A'] = "Both";\n     else\n       seats[a[i] + 'A'] = "Aisle";\n   }\n   string s;\n   cin >> s;\n   for (char &ch : s)\n     cout << seats[ch] << "\n ";\n }\n \n int main() {\n   ios::sync_with_stdio(false);\n   cin.tie(NULL);\n \n   solve();\n }\n "~0
"#include <algorithm>\n #include <deque>\n #include <iostream>\n #include <map>\n #include <queue>\n #include <set>\n #include <stack>\n #include <vector>\n using namespace std;\n typedef long long ll;\n \n void solve() {\n   string a, b;\n   cin >> a >> b;\n   size_t sz = a.size();\n   a += b;\n   sort(a.begin(), a.end());\n   cout << a.substr(0, sz) << "\n ";\n }\n \n int main() {\n   ios::sync_with_stdio(false);\n   cin.tie(NULL);\n \n   solve();\n }\n "~0
"#include <iostream>\n #include <map>\n #include <set>\n #include <vector>\n using namespace std;\n \n map<int, int> divs(int n) {\n   map<int, int> res;\n   for (int i = 2; i * i <= n; i++)\n     while (n % i == 0) {\n       res[i]++;\n       n /= i;\n     }\n   if (n > 1)\n     res[n]++;\n   return res;\n }\n \n int main() {\n   int a, b;\n   cin >> a >> b;\n   if (a == b) {\n     cout << "0\n ";\n     return 0;\n   }\n   map<int, int> d1 = divs(a), d2 = divs(b);\n   set<int> keys;\n   for (auto [d, k] : d1)\n     keys.emplace(d);\n   for (auto [d, k] : d2) {\n     keys.emplace(d);\n   }\n   int count = 0;\n   for (int key : keys)\n     if (key == 2 || key == 3 || key == 5) {\n       count += abs(d1[key] - d2[key]);\n     } else if (d1[key] != d2[key]) {\n       cout << "-1\n ";\n       return 0;\n     }\n   cout << count << "\n ";\n }\n "~0
"#include <bits\stdc++.h>\n using namespace std;\n long long a, b, ans;\n void fact(int x) {\n     int z = 0, y = 0;\n     while (a % x == 0) {\n         a /= x;\n         z++;\n     }\n     while (b % x == 0) {\n         b /= x;\n         y++;\n     }\n     ans += abs(z - y);\n }\n int main() {\n     cin >> a >> b;\n     fact(2);\n     fact(3);\n     fact(5);\n     if(a != b) {\n         cout << -1;\n     } else {\n         cout << ans;\n     }\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n const long long N = 2e6 + 1;\n long long t[4 * N][3];\n long long ky[300001];\n map<long long, long long> ky_;\n \n void build(long long v, long long tl, long long tr) {\n     if (tl == tr) {\n         t[v][2] = ky[tl + 1] - ky[tl];\n         return;\n     }\n     long long tm = (tl + tr) / 2;\n     build(v * 2, tl, tm);\n     build(v * 2 + 1, tm + 1, tr);\n     if (t[v * 2][0] == t[v * 2 + 1][0]) {\n         t[v][2] = t[v * 2][2] + t[v * 2 + 1][2];\n         t[v][0] = t[v * 2][0];\n         return;\n     }\n     if (t[v * 2][0] < t[v * 2 + 1][0]) {\n         t[v][2] = t[v * 2][2];\n         t[v][0] = t[v * 2][0];\n         return;\n     }\n     t[v][2] = t[v * 2 + 1][2];\n     t[v][0] = t[v * 2 + 1][0];\n }\n \n pair<long long, long long> get(long long v, long long tl, long long tr, long long l, long long r) {\n     if (l > r) {\n         return {1e18, 0};\n     }\n     if (l == tl && r == tr) {\n         if (l != r) {\n             t[v * 2][0] += t[v][1];\n             t[v * 2][1] += t[v][1];\n             t[v * 2 + 1][0] += t[v][1];\n             t[v * 2 + 1][1] += t[v][1];\n             t[v][1] = 0;\n         } else {\n             t[v][1] = 0;\n         }\n         return {t[v][0], t[v][2]};\n     }\n     t[v * 2][0] += t[v][1];\n     t[v * 2][1] += t[v][1];\n     t[v * 2 + 1][0] += t[v][1];\n     t[v * 2 + 1][1] += t[v][1];\n     t[v][1] = 0;\n     long long tm = (tl + tr) / 2;\n     pair<long long, long long> gt1 = get(v * 2, tl, tm, l, min(r, tm));\n     pair<long long, long long> gt2 = get(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);\n     if (gt1.first == gt2.first) {\n         return {gt1.first, gt1.second + gt2.second};\n     }\n     if (gt1.first < gt2.first) {\n         return gt1;\n     }\n     return gt2;\n }\n \n void upd(long long v, long long tl, long long tr, long long l, long long r, long long x) {\n     if (l > r) {\n         return;\n     }\n     if (l == tl && r == tr) {\n         if (l != r) {\n             t[v * 2][0] += t[v][1];\n             t[v * 2][1] += t[v][1];\n             t[v * 2 + 1][0] += t[v][1];\n             t[v * 2 + 1][1] += t[v][1];\n             t[v][1] = 0;\n         } else {\n             t[v][1] = 0;\n         }\n         t[v][0] += x;\n         t[v][1] += x;\n         return;\n     }\n     t[v * 2][0] += t[v][1];\n     t[v * 2][1] += t[v][1];\n     t[v * 2 + 1][0] += t[v][1];\n     t[v * 2 + 1][1] += t[v][1];\n     t[v][1] = 0;\n     long long tm = (tl + tr) / 2;\n     upd(v * 2, tl, tm, l, min(r, tm), x);\n     upd(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r, x);\n     if (t[v * 2][0] == t[v * 2 + 1][0]) {\n         t[v][2] = t[v * 2][2] + t[v * 2 + 1][2];\n         t[v][0] = t[v * 2][0];\n         return;\n     }\n     if (t[v * 2][0] < t[v * 2 + 1][0]) {\n         t[v][2] = t[v * 2][2];\n         t[v][0] = t[v * 2][0];\n         return;\n     }\n     t[v][2] = t[v * 2 + 1][2];\n     t[v][0] = t[v * 2 + 1][0];\n }\n \n struct point {\n     long long x, y, idx, type;\n \n     point() {\n         x = y = idx = type = 0;\n     }\n \n     point(long long x, long long y, long long idx, long long type) {\n         this->x = x;\n         this->y = y;\n         this->idx = idx;\n         this->type = type;\n     }\n };\n \n struct rect {\n     long long x1, y1, x2, y2;\n \n     rect() {\n         x1 = y1 = x2 = y2 = 0;\n     }\n \n     rect(point s, point e) {\n         this->x1 = s.x;\n         this->y1 = s.y;\n         this->x2 = e.x;\n         this->y2 = e.y;\n     }\n \n     rect(long long x1, long long y1, long long x2, long long y2) {\n         this->x1 = x1;\n         this->y1 = y1;\n         this->x2 = x2;\n         this->y2 = y2;\n     }\n };\n \n istream &operator>>(istream &is, point &p) {\n     is >> p.x >> p.y;\n     return is;\n }\n \n istream &operator>>(istream &is, rect &p) {\n     point s, e;\n     is >> s >> e;\n     p = {s, e};\n     return is;\n }\n \n point events[300000];\n rect arr[200000];\n set<long long> sy;\n long long mx = -1e9;\n long long mn = 1e9;\n \n signed main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n     long long n;\n     cin >> n;\n     for (int i = 0; i < n; ++i) {\n         long long x1, x2, y1, y2;\n         cin >> x1 >> y1 >> x2 >> y2;\n         arr[i] = {x1, y1, x2, y2};\n         sy.insert(y1);\n         sy.insert(y2);\n     }\n     {\n         long long j = 0;\n         for (const long long &i : sy) {\n             mx = max(mx, i);\n             mn = min(mn, i);\n             ky_[i] = j;\n             ky[j] = i;\n             ++j;\n         }\n     }\n     long long n_ = (long long) sy.size();\n     if (n_) {\n         ky[n_] = ky[n_ - 1];\n         build(1, 0, n_ - 1);\n     }\n     for (long long i = 0; i < n; ++i) {\n         events[i * 2] = {arr[i].x1, ky_[arr[i].y1], i, 0};\n         events[i * 2 + 1] = {arr[i].x2, ky_[arr[i].y2], i, 1};\n     }\n     sort(events, events + 2 * n, [](point a, point b) {\n         if (a.x == b.x) {\n             return a.type < b.type;\n         }\n         return a.x < b.x;\n     });\n     long long ans = 0;\n     for (long long i = 0; i < 2 * n; ++i) {\n         if (!events[i].type) {\n             upd(1, 0, n_ - 1, ky_[arr[events[i].idx].y1], ky_[arr[events[i].idx].y2] - 1, 1);\n         } else {\n             upd(1, 0, n_ - 1, ky_[arr[events[i].idx].y1], ky_[arr[events[i].idx].y2] - 1, -1);\n         }\n         auto gt = get(1, 0, n_ - 1, 0, n_ - 1);\n         if (gt.first == 0) {\n             if (i != n * 2 - 1) {\n                 ans += (mx - mn - gt.second) * (events[i + 1].x - events[i].x);\n             }\n         }\n     }\n     cout << ans;\n     return 0;\n }\n \n "~0
"#include <bits/stdc++.h>\n using namespace std;\n struct segtr {\n     vector<pair<int, int>> tree;\n \n     int size;\n \n     void init(int n) {\n         size = 1;\n         while (size < n) size *= 2;\n         tree.assign(2 * size - 1, {-1e9, -1e9});\n     }\n \n     void set(int nom, int i, int v, int x, int lx, int rx) {\n         if (lx == rx - 1) {\n             tree[x] = {v, nom};\n             return;\n         }\n         int mid = (lx + rx) / 2;\n         if (i < mid)\n             set(nom, i, v, 2 * x + 1, lx, mid);\n         else\n             set(nom, i, v, 2 * x + 2, mid, rx);\n         tree[x] = max(tree[2 * x + 1], tree[2 * x + 2]);\n     }\n \n     void set(int i, int v, int nom) {\n         set(nom, i, v, 0, 0, size);\n     }\n \n     pair<int, int> sum(int l, int r, int x, int lx, int rx) {\n         if (l >= rx || lx >= r) {\n             return {-1e9, -1e9};\n         }\n         if (lx >= l && rx <= r) {\n             return tree[x];\n         }\n         int mid = (lx + rx) / 2;\n         return max(sum(l, r, 2 * x + 1, lx, mid), sum(l, r, 2 * x + 2, mid, rx));\n     }\n \n     pair<int, int> sum(int l, int r) {\n         return sum(l, r, 0, 0, size);\n     }\n };\n int main() {\n     ios::sync_with_stdio(false);\n     cin.tie(0);\n     cout.tie(0);\n     int n;\n     cin >> n;\n     vector<int> a;\n     for (int i = 0; i < n; i++) {\n         int cc;\n         cin >> cc;\n         a.push_back(cc);\n     }\n     map<int, int> mapa;\n     int nom = 0;\n     vector<int> srta = a;\n     sort(srta.begin(), srta.end());\n     for (int i = 0; i < n; i++) {\n         if (i == 0 || srta[i] != srta[i - 1]) {\n             nom++;\n             mapa[srta[i]] = nom;\n         } else {\n             mapa[srta[i]] = nom;\n         }\n     }\n     for (auto &x : a) {\n         x = mapa[x];\n     }\n     segtr st;\n     st.init(1000000);\n     vector<int> dp(n + 1), p(n + 1, -1);\n     dp[0] = 1;\n     st.set(a[0], 1, 0);\n     for (int i = 1; i < n; i++) {\n         auto cur = st.sum(a[i], 1000000);\n         if (cur.first == -1e9) {\n             dp[i] = 1;\n             st.set(a[i], 1, i);\n         } else {\n             dp[i] = cur.first + 1;\n             st.set(a[i], dp[i], i);\n             p[i] = cur.second;\n         }\n     }\n     int nomm = 0;\n     for (int i = 0; i < n; i++) {\n         if (dp[i] > dp[nomm]) nomm = i;\n     }\n     vector<int> ans;\n     while (nomm != -1) {\n         ans.push_back((nomm + 1));\n         nomm = p[nomm];\n     }\n     cout << ans.size() << '\n ';\n     reverse(ans.begin(), ans.end());\n     for (auto x : ans) cout << x << ' ';\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n int main() {\n     long long x, y, l, r;\n     cin >> x >> y >> l >> r;\n     set<long long> s;\n     for (long long i = 1; i; i *= i > r / x ? 0 : x) {\n         for (long long j = 1; j; j *= j > r / y ? 0 : y) {\n             s.insert(i + j);\n         }\n     }\n     y = l - 1;\n     long long a = 0;\n     for (auto e : s) {\n         if (l <= e && e <= r) {\n             a = max(a, e - y - 1);\n             y = e;\n         }\n     }\n     cout << max(a, r - y);\n }\n "~0
"#include <bits/stdc++.h>\n using namespace std;\n \n int main() {\n     int n;\n     cin >> n;\n     map<long long, long long> mapa;\n     vector<int> a;\n     for (int i = 0; i < n; i++) {\n         int cc;\n         cin >> cc;\n         a.push_back(cc);\n         mapa[cc]++;\n     }\n     long long ans = 0;\n     for (long long i = 1; i <= 2000000000; i *= 2) {\n         if (i > *max_element(a.begin(), a.end()) * 2) {\n             break;\n         }\n         for (auto x : mapa) {\n             if (i - x.first <= 0) {\n                 continue;\n             }\n             if (i - x.first != x.first && i - x.first > x.first && mapa.count(i - x.first)) {\n                 ans += mapa[x.first] * mapa[i - x.first];\n             } else if (i - x.first == x.first) {\n                 ans += mapa[x.first] * (mapa[x.first] - 1) / 2;\n             }\n         }\n     }\n     cout << ans;\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n int main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int n;\n 	cin >> n;\n 	vector <int> s(n), dp(n);\n 	for (int i = 0; i < n; i++) {\n 		cin >> s[i];\n 	}\n 	for (int i = 1; i < n; i++) {\n 		if (i == 1) {\n 			dp[i] = abs(s[i] - s[i - 1]);\n 			continue;\n 		}\n 		dp[i] = min(3 * abs(s[i] - s[i - 2]) + dp[i - 2], abs(s[i] - s[i - 1]) + dp[i - 1]);\n 	}\n 	cout << dp[n - 1] << "\n ";\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n struct vrm {\n     int a, b, c;\n };\n \n signed main() {\n     int n;\n     cin >> n;\n     vector <vrm> s;\n     for (int i = 0; i < n; i++) {\n         int x, y, z;\n         cin >> x >> y >> z;\n         s.push_back({x, y, z});\n     }\n     vector <int> dp(n + 1);\n     dp[0] = 0;\n     dp[1] = s[0].a;\n     if (n >= 2) {\n         dp[2] = min(s[0].a + s[1].a, s[0].b);\n         for (int i = 3; i <= n; i++) {\n             dp[i] = min(dp[i - 1] + s[i - 1].a, min(dp[i - 2] + s[i - 2].b, dp[i - 3] + s[i - 3].c));\n         }\n     }\n     cout << dp.back() << "\n ";\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n using namespace std;\n  \n bool ok(vector<int> a, int k, int s) {\n     int prev = 0;\n     for (int i = 0; i < k - 1; i++) {\n         int cur = lower_bound(a.begin(), a.end(), a[prev] + s) - a.begin();\n         prev = cur;\n         if (cur == a.size()) {\n             return false;\n         }\n     }\n     return true;\n }\n  \n int cow(vector<int> a, int k) {\n     int l = 0;\n     int r = a[a.size() - 1] - a[0] + 1;\n     while (r - l > 1) {\n         int c = (l + r) / 2;\n         if (ok(a, k, c)) {\n             l = c;\n         } else {\n             r = c;\n         }\n     }\n     return l;\n }\n  \n int main() {\n     int n, k;\n     cin >> n >> k;\n     vector<int> a(n);\n     for (int i = 0; i < n; i++) {\n         cin >> a[i];\n     }\n     cout << cow(a, k) << endl;\n     return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n signed main() {\n 	int a, b, c;\n 	cin >> a >> b >> c;\n 	int l = 0, r = (a - 1) * max(b, c);\n 	while (r > l + 1) {\n 		int m = (l + r) / 2;\n 		if (m / b + m / c < a - 1) {\n 			l = m;\n 		} else {\n 			r = m;\n 		}\n 	}\n 	cout << r + min(b, c) << "\n ";\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n vector <int> p;\n \n int leader(int v) {\n     if (p[v] == v)\n         return v;\n     else\n         return leader(p[v]);\n }\n \n int leaderv(int v, int k = 0) {\n 	if (p[v] == v) {\n 		return k;\n 	} else {\n 		return leaderv(p[v], k + 1);\n 	}\n }\n \n void unite(int a, int b) {\n     a = leader(a);\n     p[a] = b;\n }\n \n signed main() {\n 	int n;\n 	cin >> n;\n 	p = vector <int> (n);\n 	for (int i = 0; i < n; i++) p[i] = i;\n 	map <int, string> m1;\n 	map <string, int> m2;\n 	vector <pair <string, string>> s;\n 	set <string> h1, h2;\n 	for (int i = 0; i < n - 1; i++) {\n 		string a, b;\n 		cin >> a >> b;\n 		s.push_back({a, b});\n 		h1.insert(a);\n 		h2.insert(b);\n 		m2[a] = i;\n 		m1[i] = a;\n 	}\n 	set <string> anss;\n 	set_difference(h2.begin(), h2.end(), h1.begin(), h1.end(), inserter(anss, anss.end()));\n        	string st;\n 	for (auto i: anss) st = i;\n 	m1[n - 1] = st;\n 	m2[st] = n - 1;\n 	for (int i = 0; i < n - 1; i++) {\n 		string a, b;\n 		a = s[i].first;\n 		b = s[i].second;\n 		unite(m2[a], m2[b]);\n 	}\n 	// cout << "Корень дерева: " << st << "\n ";\n 	vector <pair <string, int>> ans;\n 	for (int i = 0; i < p.size(); i++) {\n 		if (p[i] == i) {\n 			ans.push_back({m1[i], 0});\n 		} else {\n 			ans.push_back({m1[i], leaderv(p[i]) + 1});\n 		}\n 	}\n 	sort(ans.begin(), ans.end());\n 	for (auto i: ans) cout << i.first << " " << i.second << "\n ";\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n #define int long long\n \n bool komp(pair <string, int> a, pair <string, int> b) {\n 	if (a.second == b.second) {\n 		return a.first < b.first;\n 	} \n 	return a.second > b.second;\n }\n \n void solve() {\n 	int n;\n 	cin >> n;\n 	map <string, int> m;\n 	for (int i = 0; i < n; i++) {\n 		string a;\n 		int x;\n 		cin >> a >> x;\n 		m[a] = x;\n 	}\n 	int r;\n 	cin >> r;\n 	map <string, map <string, int>> k;\n 	map <string, int> h;\n 	for (int i = 0; i < r; i++) {\n 		string a, b;\n 		cin >> a >> b;\n 		k[a][b]++;\n 		h[b] = 0;\n 	}\n 	for (auto i: k) {\n 		int x = INT_MIN;\n 		string s;\n 		for (auto j: i.second) {\n 			if (j.second > x) {\n 				x = j.second;\n 				s = j.first;\n 			}\n 		}\n 		h[s] += m[i.first];\n 	}\n 	vector <pair <string, int>> q;\n 	for (auto i: h) {\n 		q.push_back({i.first, i.second});\n 	}\n 	sort(q.begin(), q.end(), komp);\n 	for (auto i: q) {\n 		cout << i.first << " " << i.second << "\n ";\n 	}\n 	return ;\n }\n \n signed main() {\n 	ios_base::sync_with_stdio(false);\n 	cin.tie(nullptr);\n 	cout.tie(nullptr);\n 	int t = 1;\n 	// cin >> t;\n 	while (t--) solve();\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n int32_t main() {\n   int n;\n   cin >> n;\n   vector <int> a(15485865);\n   for (int i = 0; i < 15485865; i++)\n     a[i] = i;\n   for (int p = 2; p < 15485865; p++)\n   {\n     if (a[p] != 0)\n     {\n       for (int j = p * p; j < 15485865; j += p)\n         a[j] = 0;\n     }\n   }\n   int x = 0;\n   while (n) {\n   	if (a[x] > 1) {\n 		n--;\n 	}\n 	x++;\n   }\n   cout << a[x - 1] << "\n ";\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std;\n \n #define int long long\n \n int gcd(int a, int b) {\n 	if (a < b) {\n 		swap(a, b);\n 	}\n 	while (b != 0) {\n 		a = a % b;\n 		swap(a, b);\n 	}\n 	return a;\n }\n \n int rs_gcd(int a, int b, int &x, int &y) {\n 	if (a == 0) {\n 		x = 0, y = 1;\n 		return b;\n 	}\n 	int x1, y1;\n 	int ans = rs_gcd(b % a, a, x1, y1);\n 	x = y1 - (b / a) * x1;\n 	y = x1;\n 	return ans;\n }\n \n int euler(int n) {\n 	int ans = n;\n 	int tek = 2;\n 	while (tek * tek <= n) {\n 		if (n % tek == 0) {\n 			while (n % tek == 0) {\n 				n /= tek;\n 			}\n 			ans -= ans / tek;\n 		}\n 		tek++;\n 	}\n 	if (n > 1) {\n 		ans -= ans / n;\n 	}\n 	return ans;\n }\n \n string sol(int a, int b, int c, int &x, int &y, int &u) {\n 	u = rs_gcd(a, b, x, y);\n 	if (c % u != 0) {\n 		return "Impossible";\n 	}\n 	x *= c / u;\n 	y *= c / u;\n 	return "Has solution";\n }\n \n signed main() {\n 	/*\n 	int n;\n 	cin >> n;\n 	int sm = 0;\n 	for (int i = 1; i <= n; i++) {\n 		int x = euler(i);\n 		sm += x;\n 		if (i % 100 == 0) {\n 			cout << sm << " ";\n 			sm = 0;\n 		}\n 		if (n % 100 != 0 && i == n) {\n 			cout << sm << "\n ";\n 			return 0;\n 		}\n 	}\n 	cout << "\n ";\n 	*/\n 	int a, b, c, x, y, t;\n 	cin >> a >> b >> c;\n 	string ans = sol(a, b, c, x, y, t);\n 	if (ans == "Impossible") {\n 		cout << -1 << "\n ";\n 		return 0;\n 	}\n 	int g = gcd(a, b);\n 	// cout << x << " " << y << "\n ";\n 	while (x >= 0) {\n 		if (x - b / g < 0) {\n 			break;\n 		}\n 		x -= b / g;\n 		y += a / g;\n 	}\n 	// cout << x << " " << y << "\n ";\n 	while (x < 0) {\n 		x += b / g;\n 		y -= a / g;\n 	}\n 	cout << x << " " << y << "\n ";\n 	return 0;\n }\n "~0
"#include <bits/stdc++.h>\n \n using namespace std; \n \n signed main() { \n 	int a, b, c, d, x, y, x1, y1, dd, k, xq, yq; \n   	cin >> a >> b >> c >> d; \n 	x = abs(a - c); \n 	y = abs(b - d); \n 	xq = x; \n 	yq = y; \n   	while (x != 0 and y != 0) {\n 		if (x > y) {\n 			x = x % y;\n 		} else {\n 			y = y % x;\n 		}\n 	} \n     	dd = x + y; \n   	cout << xq + yq - dd; \n }\n "~0
"#include <iostream>\n \n using namespace std;\n \n long long gcd(long long a, long long b) {\n     while (a != 0 && b != 0) {\n         if (b > a) {\n             b %= a;\n         } else {\n             a %= b;\n         }\n     }\n     return a + b;\n }\n \n int main() {\n     long long s1, s2;\n     cin >> s1 >> s2;\n     bool f = false;\n     if (s1 < 0) {\n         f = true;\n     }\n     s1 = abs(s1);\n     long long p = gcd(s1, s2);\n     if (f) {\n         cout << -s1 / p << " " << s2 / p << endl;\n     } else {\n         cout << s1 / p << " " << s2 / p << endl;\n     }\n     return 0;\n }\n "~0
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n int main()\n {\n     int n;\n     cin >> n;\n     vector <vector<int>> dp(n + 1, vector<int> (n + 1, 0));\n     dp[0][0] = 1;\n     for (int i = 1; i < n + 1; i++) {\n         for (int j = 1; j < n + 1; j++) {\n             if (i - j >= 0) {\n                 int s = 0;\n                 for (int k = 0; k < j; k++) {\n                     s += dp[i - j][k];\n                 }\n                 dp[i][j] = s;\n             }\n         }\n     }\n     int s = 0;\n     for (int k = 0; k < n + 1; k++) {\n         s += dp[n][k];\n     }\n     cout << s;\n }\n "~0
"#include <iostream>\n using namespace std;\n \n void f(int n, int a, int b, int c) {\n     if (n == 1) {\n         cout << n << " " << a << " " << b << endl;\n         return;\n     }\n     f(n - 1, a, c, b);\n     cout << n << " " << a << " " << b << endl;\n     f(n - 1, c, b, a);\n }\n \n int main() {\n     int n;\n     cin >> n;\n     f(n, 1, 3, 2);\n     return 0;\n }\n "~0
"#include <iostream>\n #include <string>\n #include <vector>\n #include <cctype>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s);\n \n     vector<int> a(26, 0);\n \n     for (char i : s) {\n         if (isalpha(i)) { \n             char c = toupper(i);\n             a[c - 'A']++;\n         }\n     }\n \n     int mx = 0;\n     for (int i : a) {\n         if (i > mx) {\n             mx = i;\n         }\n     }\n \n \n     for (int i = 0; i < 26; ++i) {\n         if (a[i] == mx) {\n             cout << char('A' + i);\n         }\n     }\n     cout << endl;\n \n     cout << mx << endl;\n \n     return 0;\n }\n "~0
"#include <iostream>\n #include <string>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s);\n \n     int c = 0;\n     bool flag = false;\n \n     for (char i : s) {\n         if (i != ' ') {\n             if (!flag) {\n                 c++;\n                 flag = true;\n             }\n         }\n         else {\n             flag = false;\n         }\n     }\n \n     cout << c << endl; \n     return 0;\n }\n "~0
"#include <iostream>\n #include <string>\n #include <vector>\n #include <algorithm>\n #include <climits>\n #include <set>\n \n using namespace std;\n \n set <string> zebra(set <string> a, set <string> b) {\n     set <string> c;\n     for (auto i : a) {\n         if (b.count(i) != 0)\n             c.insert(i);\n     }\n     return c;\n }\n \n int min(int a, int b) {\n     if (a > b) {\n         return a;\n     }\n     else {\n         return b;\n     }\n }\n \n int main() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     long long n, m;\n     cin >> n >> m;\n     vector <vector<int>> dp(n, vector<int>(m, 0));\n     vector <vector<int>> a(n, vector<int>(m));\n     for (int i = 0; i < n; i++) {\n         for (int j = 0; j < m; j++) {\n             cin >> a[i][j];\n         }\n     }\n     dp[0][0] = a[0][0];\n     for (int i = 0; i < n; i++) {\n         for (int j = 0; j < m; j++) {\n             if (i == 0 and j != 0) {\n                 dp[0][j] = dp[0][j - 1] + a[0][j];\n             }\n             else if (j == 0 and i != 0) {\n                 dp[i][0] = dp[i - 1][0] + a[i][0];\n             }\n             else if (j != 0 and i != 0) {\n                 dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + a[i][j];\n             }\n         }\n     }\n     int i = n - 1, j = m - 1;\n     vector <char> res;\n     while (!(i == 0 and j == 0)) {\n         if (i == 0) {\n             res.push_back('R');\n             j--;\n         }\n         else if (j == 0) {\n             res.push_back('D');\n             i--;\n         }\n         else if (dp[i - 1][j] > dp[i][j - 1]) {\n             res.push_back('D');\n             i--;\n         }\n         else {\n             res.push_back('R');\n             j--;\n         }\n     }\n     reverse(res.begin(), res.end());\n     cout << dp[n - 1][m - 1] << endl;\n     for (auto i : res) {\n         cout << i << " ";\n     }\n }\n "~0
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n int main() {\n     int n, m;\n     cin >> n >> m;\n \n     vector<vector<int>> dp(n, vector<int>(m, 0));\n \n     for (int i = 0; i < n; ++i) {\n         dp[i][0] = 1; \n     }\n     for (int j = 0; j < m; ++j) {\n         dp[0][j] = 1; \n     }\n \n     for (int i = 1; i < n; ++i) {\n         for (int j = 1; j < m; ++j) {\n             dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n         }\n     }\n \n     cout << dp[n - 1][m - 1] << endl;\n \n     return 0;\n }\n "~0
"#include <iostream>\n #include <vector>\n #include <cmath>\n #include <climits>\n using namespace std;\n int main() {\n     long long a, b, c, d;\n     cin >> a >> b >> c >> d;\n     a -= c;\n     b -= c;\n     for (int i = (a + d - 1) / d * d + c ; i <= b + c; i += d) {\n         cout << i << " ";\n     }\n }\n "~0
"#include <iostream>\n #include <vector>\n #include <cmath>\n #include <climits>\n using namespace std;\n int main() {\n     int a, b;\n     cin >> a >> b;\n     for (int i = a + (a % 2 != 0); i <= b; i += 2) {\n         cout << i << " ";\n     }\n }\n "~0
"#include <iostream>\n using namespace std;\n \n int main() {\n     int a, b, n;\n     cin >> a >> b;\n     cout << (a * b + 1 ) / 2;\n }\n "~0
"#include <iostream>\n using namespace std;\n \n int main() {\n     int a, b, n;\n     cin >> a >> b;\n     cout << (b - 1) / a + 1 << " " << (b - 1) % a + 1;\n }\n "~0
"#include <iostream>\n #include <string>\n #include <cctype>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s);\n \n     bool start = true; \n \n     for (size_t i = 0; i < s.length(); ++i) {\n         if (isalpha(s[i])) {\n             if (start) {\n                 s[i] = toupper(s[i]);\n                 start = false;\n             }\n             else {\n                 s[i] = tolower(s[i]); \n             }\n         }\n         else {\n             start = true;\n         }\n     }\n \n     cout << s << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <string>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s);\n \n     string res;\n     bool space = false; \n \n     int start = s.find_first_not_of(' ');\n     if (start == string::npos) {\n         cout << "" << endl;\n         return 0;\n     }\n \n     int end = s.find_last_not_of(' ');\n     s = s.substr(start, end - start + 1);\n \n     for (char i : s) {\n         if (i != ' ') {\n             res += i;\n             space = false;\n         }\n         else if (!space) {\n             res += ' '; \n             space = true;\n         }\n     }\n \n     cout << res << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <string>\n \n using namespace std;\n \n int main() {\n     string s;\n     getline(cin, s); // Считываем строку целиком\n \n     int pos = 0;\n     while ((pos = s.find('1', pos)) != string::npos) {\n         s.replace(pos, 1, "one");\n         pos += 3; \n     }\n \n     cout << s << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <algorithm>\n \n using namespace std;\n \n int main() {\n     int A, B, C, D, E;\n     cin >> A >> B >> C >> D >> E;\n \n     int brick1 = min(A, min(B, C));\n     int brick2 = max(min(A, B), min(max(A, B), C));\n     int brick3 = max(A, max(B, C));\n \n     int hole1 = min(D, E);\n     int hole2 = max(D, E);\n \n     if ((min(A, min(B, C)) <= min(D, E) && max(min(A, B), min(max(A, B), C)) <= max(D, E)) || (min(A, min(B, C)) <= max(D, E) && max(min(A, B), min(max(A, B), C)) <= min(D, E))) {\n         cout << "YES" << endl;\n     }\n     else {\n         cout << "NO" << endl;\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <cmath>\n #include <cstdlib>\n \n int main() {\n     double c;\n     std::cin >> c;\n     double xo = sqrt(c);\n     double eps = 1e-5;\n     double x = sqrt(c - xo);\n     \n     while (fabs(x - xo) > eps) {\n         xo = x;\n         x = sqrt(c - sqrt(xo));\n     }\n     \n     std::cout << x << std::endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <cmath>\n \n int main() {\n     int n;\n     std::cin >> n;\n     std::vector<int> h(n);\n     for (int i = 0; i < n; ++i) {\n         std::cin >> h[i];\n     }\n     int m;\n     std::cin >> m;\n     int l = 0;\n     int r = *std::max_element(h.begin(), h.end());\n \n     while (r - l > 1) {\n         int x = (r + l) / 2;\n         int sum = 0;\n         for (int a : h) {\n             sum += std::ceil(static_cast<double>(a) / x);\n         }\n         if (sum <= m) {\n             r = x;\n         } else {\n             l = x;\n         }\n     }\n     if (m < n) {\n         std::cout << -1 << std::endl;\n     } else {\n         std::cout << r << std::endl;\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_map>\n #include <string>\n #include <sstream>\n \n int main() {\n     int n, m;\n     std::cin >> n >> m;\n     std::unordered_map<std::string, int> w;\n     for (int i = 0; i < m; ++i) {\n         std::string s1, s2;\n         std::cin >> s1 >> s2;\n         w[s2] = std::stoi(s1);\n     }\n     std::vector<int> res(n, 0);\n     for (const auto& pair : w) {\n         res[pair.second - 1] += 1;\n     }\n     for (int i = 0; i < n; ++i) {\n         std::cout << res[i];\n         if (i < n - 1) {\n             std::cout << " ";\n         }\n     }\n     std::cout << std::endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <tuple>\n \n std::tuple<int, int, int> gcdExtended(int a, int b) {\n     if (a == 0) {\n         return std::make_tuple(b, 0, 1);\n     }\n     int gcd, x1, y1;\n     std::tie(gcd, x1, y1) = gcdExtended(b % a, a);\n     int x = y1 - (b / a) * x1;\n     int y = x1;\n     return std::make_tuple(gcd, x, y);\n }\n \n int main() {\n     int m, a;\n     std::cin >> m >> a;\n     int gcd, x, y;\n     std::tie(gcd, x, y) = gcdExtended(a, m);\n     if (gcd == 1) {\n         std::cout << (x % m + m) % m << std::endl;\n     } else {\n         std::cout << -1 << std::endl;\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <cmath>\n #include <string>\n #include <sstream>\n \n void solve(int n) {\n     int d = 0;\n     while (!(n & 1)) {\n         d++;\n         n /= 2;\n     }\n \n     std::vector<int> a(d, 2);\n     a.back() *= n;\n \n     if (d == 1) {\n         std::cout << "prime" << std::endl;\n         return;\n     }\n \n     for (int x = 3; x <= static_cast<int>(std::sqrt(n)); x += 2) {\n         if (n % x == 0) {\n             std::vector<int> b = a;\n             b.back() /= x;\n             b[d - 2] *= x;\n             std::cout << "many" << std::endl;\n             for (int i : a) {\n                 std::cout << i << " ";\n             }\n             std::cout << std::endl;\n             for (int i : b) {\n                 std::cout << i << " ";\n             }\n             std::cout << std::endl;\n             return;\n         }\n     }\n \n     std::cout << "single" << std::endl;\n     for (int i : a) {\n         std::cout << i << " ";\n     }\n     std::cout << std::endl;\n }\n \n int main() {\n     std::string line;\n     while (std::getline(std::cin, line)) {\n         std::istringstream iss(line);\n         int n;\n         if (iss >> n) {\n             solve(n);\n         }\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <numeric>\n \n int gcd(int a, int b) {\n     return b == 0 ? a : gcd(b, a % b);\n }\n \n int main() {\n     int n;\n     std::cin >> n;\n     std::vector<int> a(n);\n     \n     for (int i = 0; i < n; ++i) {\n         std::cin >> a[i];\n     }\n     \n     int mx = 0;\n     \n     for (int i = 0; i < n; ++i) {\n         int cur_g = a[i];\n         int p = 0;\n         \n         if (n - i < mx) {\n             break;\n         }\n         \n         for (int j = i; j < n; ++j) {\n             p++;\n             cur_g = gcd(cur_g, a[j]);\n             if (cur_g == 1) {\n                 break;\n             }\n             a[j] /= cur_g;\n             if (mx < p) {\n                 mx = p;\n             }\n         }\n     }\n     \n     std::cout << mx << std::endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <set>\n #include <cmath>\n using namespace std;\n \n vector<int> decomp(int n) { // функция разложения числа на простые множители\n     vector<int> ans;\n     int d = 2;\n     while (d * d <= n) {\n         if (n % d == 0) {\n             ans.push_back(d);\n             n /= d;\n         } else {\n             d += 1;\n         }\n     }\n     if (n > 1) {\n         ans.push_back(n);\n     }\n     return ans;\n }\n \n // Function to calculate (base^exp) % mod efficiently\n long long modPow(long long base, long long exp, long long mod) {\n     if (mod == 1) return 0;\n     long long result = 1;\n     base = base % mod;\n     while (exp > 0) {\n         if (exp % 2 == 1) {\n             result = (result * base) % mod;\n         }\n         exp = exp >> 1;\n         base = (base * base) % mod;\n     }\n     return result;\n }\n \n int main() {\n     int x;\n     cin >> x;\n     \n     vector<int> b = decomp(x); // разложение числа x на простые множители\n     set<int> temp_set(b.begin(), b.end());\n     vector<int> a(temp_set.begin(), temp_set.end()); // разложение числа x на простые множители в единственном экземпляре\n     \n     long long y = 1;\n     for (int i = 0; i < a.size(); i++) { // перемножение простых множителей\n         y *= a[i];\n     }\n     int k = 1;\n     long long n = k * y;\n     \n     if (x == 1) { // если x = 1, то и n = 1\n         cout << 1 << endl;\n     } else if (b.size() >= 30) { // 29 - потому что хотя бы 2**30 уже будет более 10**9, что противоречит условию задачи\n         cout << y << endl; // тогда y**y уже будет делится на n\n     } else {\n         while (modPow(n, n, x) != 0) {\n             n = k * y;\n             k += 1;\n         }\n         cout << n << endl;\n     }\n     \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n const size_t sz = 5e4;\n int dep[sz], up[sz];\n bool used[sz];\n \n vector<pair<int, int>> g[sz];\n bool points[sz];\n \n void dfs(int v, int depth, int edge_id)\n {\n     used[v] = true;\n     dep[v] = depth;\n     up[v] = depth;\n     bool isPoint = false;\n     int child = 0;\n     for (auto [u, idx] : g[v])\n     {\n         if (idx == edge_id)\n             continue;\n         if (!used[u])\n         {\n             child++;\n             dfs(u, depth + 1, idx);\n             up[v] = min(up[u], up[v]);\n             if (up[u] >= dep[v])\n                 isPoint = true;\n         }\n         else\n             up[v] = min(dep[u], up[v]);\n     }\n     if (isPoint && child && depth != 0)\n         points[v] = true;\n     if (depth == 0 && child > 1)\n         points[v] = true;\n }\n \n void solve()\n {\n     int n, m;\n     cin >> n >> m;\n     for (int i = 0; i < min(int(5e5), 3 * n); i++)\n         used[i] = false, points[i] = false;\n     for (int i = 0; i < m; i++)\n     {\n         int s, f;\n         cin >> s >> f;\n         g[s].push_back({f, i});\n         g[f].push_back({s, i});\n     }\n     for (int i = 1; i <= n; i++)\n         if (!used[i])\n             dfs(i, 0, -1);\n     vector<int> ans;\n     for (int i = 1; i <= n; i++)\n         if (points[i])\n             ans.push_back(i);\n     cout << ans.size() << "\n ";\n     for (int v : ans)\n         cout << v << " ";\n     cout << "\n ";\n }\n \n int main()\n {\n     ios::sync_with_stdio(false);\n     cin.tie(NULL);\n \n     solve();\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n const size_t sz = 2e4 + 1;\n int dep[sz], up[sz];\n bool used[sz];\n \n vector<pair<int, int>> g[sz];\n vector<int> points;\n \n void dfs(int v, int depth, int edge_id)\n {\n     used[v] = true;\n     dep[v] = depth;\n     up[v] = depth;\n     for (auto [u, idx] : g[v])\n     {\n         if (idx == edge_id)\n             continue;\n         if (!used[u])\n         {\n             dfs(u, depth + 1, idx);\n             up[v] = min(up[u], up[v]);\n             if (up[u] > dep[v])\n                 points.push_back(idx);\n         }\n         else\n             up[v] = min(dep[u], up[v]);\n     }\n }\n \n void solve()\n {\n     int n, m;\n     cin >> n >> m;\n     for (int i = 0; i < n; i++)\n         used[i] = false;\n     for (int i = 0; i < m; i++)\n     {\n         int s, f;\n         cin >> s >> f;\n         g[s].push_back({f, i});\n         g[f].push_back({s, i});\n     }\n     for (int i = 0; i < n; i++)\n         if (!used[i])\n             dfs(i, 0, -1);\n     cout << points.size() << "\n ";\n     sort(points.begin(), points.end());\n     for (int e : points)\n         cout << e + 1 << "\n ";\n }\n \n int main()\n {\n     ios::sync_with_stdio(false);\n     cin.tie(NULL);\n \n     solve();\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <set>\n #include <map>\n #include <deque>\n #include <string>\n #include <string.h>\n #include <sstream>\n #include <algorithm>\n #include <queue>\n #include <stack>\n #include <cmath>\n #define ll long long\n  \n using namespace std;\n  \n int main() {\n  \n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n  \n     int a, b, c, d, e;\n     cin >> a >> b >> c >> d >> e;\n  \n     int count = 0;\n  \n     int comp = min(a, b);\n  \n     int d_used = min(comp, d);\n     int e_used = min(comp, e);\n     int overall = min(d_used, e_used);\n  \n     d -= overall;\n     e -= overall;\n  \n     count += overall;\n  \n  \n     d_used = min(c, d);\n     e_used = min(c, e);\n     overall = min(d_used, e_used);\n  \n     count += overall;\n  \n     cout << count;\n  \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <set>\n #include <map>\n #include <deque>\n #include <string>\n #include <string.h>\n #include <sstream>\n #include <algorithm>\n #include <queue>\n #include <stack>\n #include <cmath>\n #define ll long long\n  \n using namespace std;\n  \n int main() {\n  \n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n  \n     int n; cin >> n;\n  \n     //ll min;\n     queue<ll> a;\n     ll currmin = LLONG_MAX;\n  \n     for (int i = 0; i < n; i++) {\n         string c;\n         cin >> c;\n         if (c == "push") {\n             ll x; cin >> x;\n             a.push(x);\n             if (x < currmin) {\n                 currmin = x;\n             }\n         }\n         else if (c == "pop") {\n             if (!a.empty()) {\n                 int front = a.front();\n                 a.pop();\n                 if (front == currmin) {\n                     currmin = INT_MAX;\n                     queue<ll> temp = a;\n                     while (!temp.empty()) {\n                         int val = temp.front();\n                         temp.pop();\n                         if (val < currmin) {\n                             currmin = val;\n                         }\n                     }\n                 }\n             }\n         }\n         else if (c == "min?") {\n             cout << (a.empty() ? -1 : currmin) << '\n ';\n         }\n     }\n  \n     return 0;\n }\n "~1
"#include <iostream>\n #include <iomanip>\n #include <algorithm>\n #include <cstdlib>\n #include <cstdio>\n #include <cstring>\n #include <cctype>\n #include <cmath>\n #include <numeric>\n #include <vector>\n #include <string>\n #include <array>\n #include <functional>\n #include <ctime>\n #include <chrono>\n #include <random>\n #include <queue>\n #include <deque>\n #include <set>\n #include <map>\n #include <unordered_set>\n #include <unordered_map>\n #include <bitset>\n #include <cstdint>\n #include <list>\n #include <optional>\n  \n using namespace std;\n  \n #define int long long\n #ifndef ONLINE_JUDGE\n #else\n #define endl '\n '\n #endif\n using ll = long long;\n using ull = unsigned long long;\n using db = double;\n using i32 = int32_t;\n  \n #define all(x) (x).begin(), (x).end()\n #define rall(x) (x).rbegin(), (x).rend()\n #define rep(n) for (int rep_iter = 0; rep_iter < n; rep_iter++)\n #define cin(v) for (auto& el : v) cin >> el;\n  \n void fastW() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n     cout.precision(8);\n }\n  \n int gcd(int a, int b) {\n     if (!b) {\n             return a;\n     }\n     return gcd(b, a % b);\n }\n  \n int lcm(int a, int b) {\n     return a / gcd(a, b) * b;\n }\n  \n int get(int x) {\n     int res = 0;\n     while (x != 0) {\n         res += x % 10;\n         x /= 10;\n     }\n     return res;\n }\n  \n using i128 = __int128_t;\n  \n std::ostream& operator<<(std::ostream& dest, __int128_t value) {\n     std::ostream::sentry s(dest);\n     if (s) {\n         __uint128_t tmp = value < 0 ? -value : value;\n         char buffer[128];\n         char* d = std::end(buffer);\n         do {\n             --d;\n             *d = "0123456789"[tmp % 10];\n             tmp /= 10;\n         } while (tmp != 0);\n         if (value < 0) {\n             --d;\n             *d = '-';\n         }\n         int len = std::end(buffer) - d;\n         if (dest.rdbuf()->sputn(d, len) != len) {\n             dest.setstate(std::ios_base::badbit);\n         }\n     }\n     return dest;\n }\n  \n void solve() {\n     string st;\n     string end = "endprg";\n     map <string, vector <string>> mp;\n     string cur_f = "";\n     while (true) {\n         getline(cin, st);\n         if (st == end) break;\n  \n         string fir, sec;\n         string tmp;\n         for (auto el : st) {\n             if (el == ' ') {\n                 fir = tmp;\n                 tmp = "";\n             } else {\n                 tmp += el;\n             }\n         }\n         if (fir.size() == 0) {\n             fir = tmp;\n         } else {\n             sec = tmp;\n         }\n  \n         if (fir == "function") {\n             cur_f = sec;\n         }\n         else if (fir == "print" && cur_f != "") {\n             mp[cur_f].push_back(sec);\n         }\n         else if (fir == "print" && cur_f == "") {\n             cout << sec << endl;\n         }\n         else if (fir == "end") {\n             cur_f = "";\n         }\n         else if (fir == "call" && cur_f == "") {\n             for (auto el : mp[sec]) {\n                 cout << el << endl;\n             }\n         }\n         else if (fir == "call" && cur_f != "") {\n             for (auto el : mp[sec]) {\n                 mp[cur_f].push_back(el);\n             }\n         } else {\n             abort();\n         }\n     }\n }\n  \n  \n signed main() {\n     fastW();\n     solve();\n }\n "~1
"#include <iostream>\n #include <iomanip>\n #include <algorithm>\n #include <cstdlib>\n #include <cstdio>\n #include <cstring>\n #include <cctype>\n #include <cmath>\n #include <numeric>\n #include <vector>\n #include <string>\n #include <array>\n #include <functional>\n #include <ctime>\n #include <chrono>\n #include <random>\n #include <queue>\n #include <deque>\n #include <set>\n #include <map>\n #include <unordered_set>\n #include <unordered_map>\n #include <bitset>\n #include <cstdint>\n #include <list>\n #include <optional>\n \n using namespace std;\n \n #define int long long\n #ifndef ONLINE_JUDGE\n #else\n #define endl '\n '\n #endif\n using ll = long long;\n using ull = unsigned long long;\n using db = double;\n using i32 = int32_t;\n \n #define all(x) (x).begin(), (x).end()\n #define rall(x) (x).rbegin(), (x).rend()\n #define rep(n) for (int rep_iter = 0; rep_iter < n; rep_iter++)\n #define cin(v) for (auto& el : v) cin >> el;\n \n void fastW() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n     cout.precision(8);\n }\n \n int gcd(int a, int b) {\n     if (!b) {\n             return a;\n     }\n     return gcd(b, a % b);\n }\n \n int lcm(int a, int b) {\n     return a / gcd(a, b) * b;\n }\n \n int get(int x) {\n     int res = 0;\n     while (x != 0) {\n         res += x % 10;\n         x /= 10;\n     }\n     return res;\n }\n \n using i128 = __int128_t;\n \n std::ostream& operator<<(std::ostream& dest, __int128_t value) {\n     std::ostream::sentry s(dest);\n     if (s) {\n         __uint128_t tmp = value < 0 ? -value : value;\n         char buffer[128];\n         char* d = std::end(buffer);\n         do {\n             --d;\n             *d = "0123456789"[tmp % 10];\n             tmp /= 10;\n         } while (tmp != 0);\n         if (value < 0) {\n             --d;\n             *d = '-';\n         }\n         int len = std::end(buffer) - d;\n         if (dest.rdbuf()->sputn(d, len) != len) {\n             dest.setstate(std::ios_base::badbit);\n         }\n     }\n     return dest;\n }\n \n void solve() {\n     int n;\n     cin >> n;\n     vector<int> s(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> s[i];\n     }\n     sort(s.begin(), s.end());\n \n     long long res = 0;\n     for (int j = 1; j < n; ++j) {\n         double target = 0.9 * s[j];\n         int left = 0, right = j;\n         while (left < right) {\n             int mid = left + (right - left) / 2;\n             if (s[mid] < target) {\n                 left = mid + 1;\n             } else {\n                 right = mid;\n             }\n         }\n         res += j - left;\n     }\n \n     cout << res << endl;\n }\n \n \n signed main() {\n     fastW();\n     solve();\n }\n "~1
"#include <iostream>\n #include <iomanip>\n #include <algorithm>\n #include <cstdlib>\n #include <cstdio>\n #include <cstring>\n #include <cctype>\n #include <cmath>\n #include <numeric>\n #include <vector>\n #include <string>\n #include <array>\n #include <functional>\n #include <ctime>\n #include <chrono>\n #include <random>\n #include <queue>\n #include <deque>\n #include <set>\n #include <map>\n #include <unordered_set>\n #include <unordered_map>\n #include <bitset>\n #include <cstdint>\n #include <list>\n #include <optional>\n  \n using namespace std;\n  \n #define int long long\n #ifndef ONLINE_JUDGE\n #else\n #define endl '\n '\n #endif\n using ll = long long;\n using ull = unsigned long long;\n using db = double;\n using i32 = int32_t;\n  \n #define all(x) (x).begin(), (x).end()\n #define rall(x) (x).rbegin(), (x).rend()\n #define rep(n) for (int rep_iter = 0; rep_iter < n; rep_iter++)\n #define cin(v) for (auto& el : v) cin >> el;\n  \n void fastW() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n     cout.precision(8);\n }\n  \n int gcd(int a, int b) {\n     if (!b) {\n             return a;\n     }\n     return gcd(b, a % b);\n }\n  \n int lcm(int a, int b) {\n     return a / gcd(a, b) * b;\n }\n  \n  \n void solve() {\n     int n; cin >> n;\n     string st; cin >> st;\n  \n     map <char, int> mp;\n     for (auto el : st) {\n         mp[el]++;\n     }\n     int ans = 1LL << 61;\n     for (auto [key, val] : mp) {\n         ans = min(ans, abs(n - val));\n     }\n     cout << ans << endl;\n }\n  \n  \n signed main() {\n     fastW();\n     solve();\n }\n "~1
"#include <iostream>\n #include <iomanip>\n #include <algorithm>\n #include <cstdlib>\n #include <cstdio>\n #include <cstring>\n #include <cctype>\n #include <cmath>\n #include <numeric>\n #include <vector>\n #include <string>\n #include <array>\n #include <functional>\n #include <ctime>\n #include <chrono>\n #include <random>\n #include <queue>\n #include <deque>\n #include <set>\n #include <map>\n #include <unordered_set>\n #include <unordered_map>\n #include <bitset>\n #include <cstdint>\n #include <list>\n #include <optional>\n  \n using namespace std;\n  \n #define int long long\n #ifndef ONLINE_JUDGE\n #else\n #define endl '\n '\n #endif\n using ll = long long;\n using ull = unsigned long long;\n using db = double;\n using i32 = int32_t;\n  \n #define all(x) (x).begin(), (x).end()\n #define rall(x) (x).rbegin(), (x).rend()\n #define rep(n) for (int rep_iter = 0; rep_iter < n; rep_iter++)\n #define cin(v) for (auto& el : v) cin >> el;\n  \n void fastW() {\n     ios_base::sync_with_stdio(0);\n     cin.tie(0);\n     cout.tie(0);\n     cout.precision(8);\n }\n  \n int gcd(int a, int b) {\n     if (!b) {\n             return a;\n     }\n     return gcd(b, a % b);\n }\n  \n int lcm(int a, int b) {\n     return a / gcd(a, b) * b;\n }\n  \n  \n void solve() {\n     int a, b, c, d, e;\n     cin >> a >> b >> c >> d >> e;\n  \n     int fir = min(a, b);\n     int sec = c;\n     int thir = min(e, d);\n  \n     int ans = min(max(fir, sec), thir);\n     // cout << max(fir, sec) << endl;\n     thir -= max(fir, sec);\n     if (thir > 0) {\n         ans += min(min(sec, fir), thir);\n     }\n     cout << ans << endl;\n }\n  \n  \n signed main() {\n     fastW();\n     solve();\n }\n "~1
"#include <bits/stdc++.h>\n using namespace std;\n using ll = long long;\n using ld = long double;\n \n void solve() {\n     static const ld EPS = 1e-7L;\n \n     ld L; ll N;\n     cin >> L >> N;\n \n     vector<ld> T(N), V(N);\n     for (ll i = 0; i < N; ++i) cin >> T[i] >> V[i];\n \n     vector<ld> P(N + 1, 0.0L), D(N + 1, 0.0L);\n     for (ll i = 0; i < N; ++i) P[i + 1] = P[i] + T[i], D[i + 1] = D[i] + V[i] * T[i];\n \n     ld stt = P[N];\n     ld dtt = D[N];\n \n     auto s = [&](ld t) {\n         if (t >= stt) return dtt;\n \n         auto it = upper_bound(P.begin(), P.end(), t);\n         ll djj = it - P.begin(), k = djj - 1;\n         ld dt = t - P[k];\n         return D[k] + V[k] * dt;\n     };\n \n     auto mng = [&](ld d) {\n         ld lmt = stt - d;\n         if (lmt < 0) return dtt;\n \n         vector<ld> cc;\n         cc.reserve(2 * (N + 1) + 2);\n         cc.push_back(0.0L), cc.push_back(lmt);\n \n         for (ll i = 0; i <= N; ++i) {\n             ld t = P[i];\n             if (t >= 0.0L && t <= lmt) cc.push_back(t);\n         }\n \n         for (ll j = 0; j <= N; ++j) {\n             ld t = P[j] - d;\n             if (t >= 0.0L && t <= lmt) cc.push_back(t);\n         }\n \n         sort(cc.begin(), cc.end());\n         auto lst = unique(cc.begin(), cc.end());\n         cc.erase(lst, cc.end());\n \n         ld ang = numeric_limits<ld>::infinity();\n         for (auto tau : cc) {\n             ld g = s(tau + d) - s(tau);\n             if (g < ang) ang = g;\n         }\n \n         return ang;\n     };\n \n     if (mng(stt) < L - EPS) {\n         cout << fixed << setprecision(3) << stt << '\n ';\n         return;\n     }\n \n     ld lp = 0.0L, rp = stt;\n     for (ll it = 0; it < 80; it++) {\n         ld mp = (lp + rp) / 2.0L;\n         if (mng(mp) >= L) rp = mp;\n         else lp = mp;\n     }\n \n     cout << fixed << setprecision(3) << rp << '\n ';\n }\n \n int main() {\n     cin.tie(nullptr)->sync_with_stdio(false);\n \n     ll t = 1; // cin >> t;\n     while (t--) solve();\n }\n "~1
"#include <bits/stdc++.h>\n using namespace std;\n using ll = long long;\n \n void solve() {\n     freopen("input.txt", "r", stdin);\n     freopen("output.txt", "w", stdout);\n \n     ll n; cin >> n;\n \n     vector<array<ll, 4>> a(n);\n     for (ll i = 0; i < n; ++i) {\n         ll t, s, p; cin >> t >> s >> p;\n         a[i] = {t, s, p, i};\n     }\n \n     sort(a.begin(), a.end());\n \n     vector<ll> t(n), s(n), p(n), ind(n);\n     for (ll i = 0; i < n; ++i) {\n         t[i] = a[i][0], s[i] = a[i][1], p[i] = a[i][2];\n         ind[a[i][3]] = i;\n     }\n \n     ll T; cin >> T;\n \n     vector<ll> P = p;\n     sort(P.rbegin(), P.rend()), P.pop_back(), reverse(P.begin(), P.end());\n \n     vector<ll> v;\n     if (P.empty() || P[0] != 1) v.push_back(1);\n \n     for (ll i = 0; i < P.size(); ++i) {\n         if (i == P.size() - 1 || P[i + 1] > P[i] + 1) v.push_back(P[i] + 1);\n     }\n \n     ll L = 0, R = v.size();\n     while (R - L > 1) {\n         ll M = (L + R) / 2, now = v[M];\n \n         vector<ll> rm = s;\n         priority_queue<pair<ll, ll>> q;\n \n         ll j = 0, nwt = 0, ex = 0;\n         while (j < n || !q.empty()) {\n             if (q.empty()) {\n                 nwt = t[j];\n                 while (j < n && t[j] == nwt) {\n                     q.push({(p[j] == -1 ? now : p[j]), j});\n                     ++j;\n                 }\n             }\n \n             ll jj = q.top().second; q.pop();\n \n             ll ntt = (j < n ? t[j] : LLONG_MAX), ww = min(rm[jj], ntt - nwt);\n \n             nwt += ww, rm[jj] -= ww;\n \n             if (rm[jj] > 0) q.push({(p[jj] == -1 ? now : p[jj]), jj});\n             else if (p[jj] == -1) ex = nwt;\n \n             while (j < n && t[j] == nwt) {\n                 q.push({(p[j] == -1 ? now : p[j]), j});\n                 ++j;\n             }\n         }\n \n         if (ex < T) R = M;\n         else L = M;\n     }\n \n     ll ch = v[L];\n     cout << ch << '\n ';\n \n     vector<ll> rm = s, ans(n);\n     priority_queue<pair<ll, ll>> q;\n \n     ll j = 0, nwt = 0;\n     while (j < n || !q.empty()) {\n         if (q.empty()) {\n             nwt = t[j];\n             while (j < n && t[j] == nwt) {\n                 q.push({(p[j] == -1 ? ch : p[j]), j});\n                 ++j;\n             }\n         }\n \n         ll jj = q.top().second; q.pop();\n \n         ll ntt = (j < n ? t[j] : LLONG_MAX), ww = min(rm[jj], ntt - nwt);\n \n         nwt += ww, rm[jj] -= ww;\n \n         if (rm[jj] > 0) q.push({(p[jj] == -1 ? ch : p[jj]), jj});\n         else ans[jj] = nwt;\n \n         while (j < n && t[j] == nwt) {\n             q.push({(p[j] == -1 ? ch : p[j]), j});\n             ++j;\n         }\n     }\n \n     for (ll i = 0; i < n; ++i) cout << ans[ind[i]] << ' ';\n     cout << '\n ';\n }\n \n int main() {\n     cin.tie(nullptr)->sync_with_stdio(false);\n     solve();\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n \n long long gcd(long long a, long long b) {\n     while (b != 0) {\n         long long temp = b;\n         b = a % b;\n         a = temp;\n     }\n     return a;\n }\n \n long long lcm(long long a, long long b) {\n     return (a / gcd(a, b)) * b;\n }\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n;\n     cin >> n;\n     vector<long long> t(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> t[i];\n         t[i] += 1; // Преобразуем t_i в t_i + 1\n     }\n \n     long long current_lcm = 1;\n     for (long long num : t) {\n         current_lcm = lcm(current_lcm, num);\n     }\n \n     cout << current_lcm << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n using namespace std;\n \n const int MOD = 1e9 + 7;\n \n vector<int> sieve(int n) {\n     vector<int> primes;\n     vector<bool> is_prime(n + 1, true);\n     is_prime[0] = is_prime[1] = false;\n     for (int p = 2; p <= n; ++p) {\n         if (is_prime[p]) {\n             primes.push_back(p);\n             for (int multiple = p * 2; multiple <= n; multiple += p) {\n                 is_prime[multiple] = false;\n             }\n         }\n     }\n     return primes;\n }\n \n int count_exponents(int n, int p) {\n     int exponent = 0;\n     while (n > 0) {\n         n /= p;\n         exponent += n;\n     }\n     return exponent;\n }\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int N;\n     cin >> N;\n \n     if (N == 0 || N == 1) {\n         cout << 1 << endl;\n         return 0;\n     }\n \n     vector<int> primes = sieve(N);\n \n     long long result = 1;\n     for (int p : primes) {\n         int exponent = count_exponents(N, p);\n         result = (result * (exponent + 1)) % MOD;\n     }\n \n     cout << result << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <cmath>\n using namespace std;\n \n int gcd(int a, int b) {\n     while (b != 0) {\n         int temp = b;\n         b = a % b;\n         a = temp;\n     }\n     return a;\n }\n \n int main() {\n     int x1, y1, x2, y2;\n     cin >> x1 >> y1 >> x2 >> y2;\n \n     int dx = abs(x2 - x1);\n     int dy = abs(y2 - y1);\n \n     int g = gcd(dx, dy);\n     int points = g + 1;\n \n     cout << points << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n;\n     long long k;\n     cin >> n >> k;\n \n     vector<long long> a(n);\n     long long total = 0;\n     long long max_a = 0;\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n         total += a[i];\n         max_a = max(max_a, a[i]);\n     }\n \n     if (total < k) {\n         cout << -1 << endl;\n         return 0;\n     }\n \n     long long left = 0;\n     long long right = max_a;\n     long long answer = max_a;\n \n     while (left <= right) {\n         long long mid = (left + right) / 2;\n         long long sum = 0;\n         for (int i = 0; i < n; ++i) {\n             sum += min(a[i], mid);\n         }\n \n         if (sum >= k) {\n             answer = mid;\n             right = mid - 1;\n         } else {\n             left = mid + 1;\n         }\n     }\n \n     cout << answer << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n using namespace std;\n \n int sumOfDigits(int k) {\n     int sum = 0;\n     while (k > 0) {\n         sum += k % 10;\n         k /= 10;\n     }\n     return sum;\n }\n \n int main() {\n     int n;\n     cin >> n;\n \n     int k = n;\n     while (true) {\n         int sum = sumOfDigits(k);\n         if (k % sum == 0) {\n             cout << k << endl;\n             break;\n         }\n         k++;\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <climits>\n using namespace std;\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n;\n     cin >> n;\n     vector<int> t(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> t[i];\n     }\n     string s;\n     cin >> s;\n \n     int min_tmax = INT_MAX;\n     int max_tmin = INT_MIN;\n \n     for (int i = 5; i < n; ++i) {\n         if (s[i-1] == '0' && s[i] == '1') {\n             // Переход с 0 на 1: tmin > max(t[i-4..i])\n             int max_temp = t[i-4];\n             for (int j = i-3; j <= i; ++j) {\n                 if (t[j] > max_temp) {\n                     max_temp = t[j];\n                 }\n             }\n             if (max_temp > max_tmin) {\n                 max_tmin = max_temp;\n             }\n         } else if (s[i-1] == '1' && s[i] == '0') {\n             // Переход с 1 на 0: tmax < min(t[i-4..i])\n             int min_temp = t[i-4];\n             for (int j = i-3; j <= i; ++j) {\n                 if (t[j] < min_temp) {\n                     min_temp = t[j];\n                 }\n             }\n             if (min_temp < min_tmax) {\n                 min_tmax = min_temp;\n             }\n         }\n     }\n \n     // Учитываем, что tmin <= tmax\n     if (max_tmin == INT_MIN) {\n         // Нет переходов 0 -> 1, tmin может быть любым <= tmax\n         max_tmin = -1e9;\n     }\n     if (min_tmax == INT_MAX) {\n         // Нет переходов 1 -> 0, tmax может быть любым >= tmin\n         min_tmax = 1e9;\n     }\n \n     // tmin должно быть > max_tmin, tmax должно быть < min_tmax\n     int tmin = max_tmin + 1;\n     int tmax = min_tmax - 1;\n \n     // Если tmin > tmax, корректируем\n     if (tmin > tmax) {\n         // Находим середину\n         int mid = (max_tmin + min_tmax) / 2;\n         tmin = mid;\n         tmax = mid;\n     }\n \n     cout << tmin << " " << tmax << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_map>\n #include <algorithm>\n using namespace std;\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int n, k;\n     cin >> n >> k;\n     vector<int> a(n);\n     unordered_map<int, int> freq;\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n         freq[a[i]]++;\n     }\n \n     int result = 0;\n     vector<bool> disabled(n, false);\n \n     for (int i = 0; i < n; ++i) {\n         if (disabled[i]) continue;\n         int complement = k - a[i];\n         if (freq.find(complement) != freq.end()) {\n             if (complement == a[i]) {\n                 result += freq[complement] / 2;\n                 freq[complement] = 0;\n             } else {\n                 if (freq[a[i]] > freq[complement]) {\n                     result += freq[complement];\n                     freq[a[i]] -= freq[complement];\n                     freq[complement] = 0;\n                 } else {\n                     result += freq[a[i]];\n                     freq[complement] -= freq[a[i]];\n                     freq[a[i]] = 0;\n                 }\n             }\n         }\n     }\n \n     cout << result << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <string>\n #include <unordered_map>\n using namespace std;\n \n unordered_map<string, vector<string>> functions;\n vector<string> output;\n \n void execute(const vector<string>& commands) {\n     for (const string& cmd : commands) {\n         if (cmd.rfind("print ", 0) == 0) {\n             output.push_back(cmd.substr(6));\n         }\n         else if (cmd.rfind("call ", 0) == 0) {\n             string func_name = cmd.substr(5);\n             execute(functions[func_name]);\n         }\n     }\n }\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     vector<string> lines;\n     string line;\n     while (getline(cin, line)) {\n         if (line == "endprg") break;\n         if (!line.empty()) lines.push_back(line);\n     }\n \n     size_t i = 0;\n     while (i < lines.size() && lines[i].rfind("function ", 0) == 0) {\n         string func_name = lines[i].substr(9);\n         i++;\n         vector<string> func_body;\n         while (i < lines.size() && lines[i] != "end") {\n             func_body.push_back(lines[i]);\n             i++;\n         }\n         functions[func_name] = func_body;\n         i++; // skip "end"\n     }\n \n     vector<string> main_commands(lines.begin() + i, lines.end());\n     execute(main_commands);\n \n     for (const string& s : output) {\n         cout << s << '\n ';\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n using namespace std;\n \n int main() {\n     int n, x;\n     cin >> n >> x;\n     n %= 6;\n \n     for (int i = n; i >= 1; --i) {\n         if (i % 2 == 1) {\n             if (x == 0) x = 1;\n             else if (x == 1) x = 0;\n         } else {\n             if (x == 1) x = 2;\n             else if (x == 2) x = 1;\n         }\n     }\n \n     cout << x << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n using namespace std;\n \n struct SegmentTree {\n     int size;\n     vector<long long> tree;\n \n     SegmentTree(int n) {\n         size = 1;\n         while (size < n) size *= 2;\n         tree.assign(2 * size, 0LL);\n     }\n \n     void update(int i, int v, int x, int lx, int rx) {\n         if (rx - lx == 1) {\n             tree[x] = v;\n             return;\n         }\n         int m = (lx + rx) / 2;\n         if (i < m) {\n             update(i, v, 2 * x + 1, lx, m);\n         } else {\n             update(i, v, 2 * x + 2, m, rx);\n         }\n         tree[x] = tree[2 * x + 1] + tree[2 * x + 2];\n     }\n \n     void update(int i, int v) {\n         update(i, v, 0, 0, size);\n     }\n \n     long long query(int l, int r, int x, int lx, int rx) {\n         if (l >= rx || r <= lx) return 0;\n         if (l <= lx && rx <= r) return tree[x];\n         int m = (lx + rx) / 2;\n         return query(l, r, 2 * x + 1, lx, m) + query(l, r, 2 * x + 2, m, rx);\n     }\n \n     long long query(int l, int r) {\n         return query(l, r + 1, 0, 0, size);\n     }\n };\n \n int main() {\n     ios_base::sync_with_stdio(false);\n     cin.tie(nullptr);\n \n     int N, K;\n     cin >> N >> K;\n \n     SegmentTree st(N);\n \n     while (K--) {\n         char type;\n         cin >> type;\n         if (type == 'A') {\n             int i, x;\n             cin >> i >> x;\n             st.update(i - 1, x); // Переход к 0-индексации\n         } else if (type == 'Q') {\n             int l, r;\n             cin >> l >> r;\n             cout << st.query(l - 1, r - 1) << '\n '; // Переход к 0-индексации\n         }\n     }\n \n     return 0;\n }\n "~1
"#include <bits/stdc++.h>\n \n using namespace std;\n \n struct Node{\n     long long sum = 0;\n };\n \n vector<Node> tree;\n vector<long long> a;\n vector<long long> add;\n const long long INF = 1e18;\n \n void update(long long x, long long l, long long r){\n     tree[x].sum = tree[x*2+1].sum + tree[x*2+2].sum;\n }\n \n void push(long long x, long long l, long long r){\n     if (add[x] == INF){\n         return;\n     }\n     tree[x].sum = add[x]*(r-l);\n     if (r - l > 1) {\n         add[x*2+1] = add[x];\n         add[x*2+2] = add[x];\n     }\n     add[x] = INF;\n }\n \n void build(long long x, long long l, long long r){\n     add[x] = INF;\n     if (r - l == 1){\n         if (l < a.size()) {\n             tree[x].sum = a[l];\n         } else {\n             tree[x].sum = 0;\n         }\n         return;\n     }\n     long long m = (l + r) / 2;\n     build(x*2+1, l, m);\n     build(x*2+2, m, r);\n     update(x, l, r);\n }\n \n void add_range(long long x, long long l, long long r, long long value, long long lq, long long rq){\n     push(x, l, r);\n     if (l >= rq  r <= lq){\n         return;\n     }\n     if (l >= lq && r <= rq){\n         add[x] = value;\n         push(x, l, r);\n         return;\n     }\n     long long m = (l + r) / 2;\n     add_range(x*2+1, l, m, value, lq, rq);\n     add_range(x*2+2, m, r, value, lq, rq);\n     update(x, l, r);\n }\n \n long long get_ans(long long x, long long l, long long r, long long lq, long long rq){\n     push(x, l, r);\n     if (l >= rq  r <= lq){\n         return 0;\n     }\n     if (l >= lq && r <= rq){\n         return tree[x].sum;\n     }\n     long long m = (l + r) / 2;\n     long long child1Value = get_ans(x*2+1, l, m, lq, rq);\n     long long child2Value = get_ans(x*2+2, m, r, lq, rq);\n     return child1Value + child2Value;\n }\n \n int main(){\n     int n, m; cin >> n >> m;\n     long long size = 1;\n     while (size < n){\n         size *= 2;\n     }\n     tree.resize(2 * size - 1);\n     add.resize(2 * size - 1, INF);\n     build(0, 0, size);\n     int l, r; char ch; long long val;\n     for (int i = 0; i < m; i++){\n         cin >> ch;\n         if (ch == 'Q'){\n             cin >> l >> r;\n             cout << get_ans(0, 0, size, l - 1, r) << "\n ";\n         } else {\n             cin >> l >> r >> val;\n             add_range(0, 0, size, val, l - 1, r);\n         }\n     }\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n \n using namespace std;\n \n vector<int> longestCommonSubsequence(const vector<int>& seq1, const vector<int>& seq2) {\n     int n = seq1.size();\n     int m = seq2.size();\n     \n     // Создаем DP-таблицу (n+1) x (m+1), инициализированную нулями\n     vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n     \n     // Заполняем DP-таблицу\n     for (int i = 1; i <= n; ++i) {\n         for (int j = 1; j <= m; ++j) {\n             if (seq1[i - 1] == seq2[j - 1]) {\n                 dp[i][j] = dp[i - 1][j - 1] + 1;\n             } else {\n                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n             }\n         }\n     }\n     \n     // Восстанавливаем НОП\n     vector<int> lcs;\n     int i = n, j = m;\n     while (i > 0 && j > 0) {\n         if (seq1[i - 1] == seq2[j - 1]) {\n             lcs.push_back(seq1[i - 1]);\n             --i;\n             --j;\n         } else if (dp[i - 1][j] > dp[i][j - 1]) {\n             --i;\n         } else {\n             --j;\n         }\n     }\n     \n     // Разворачиваем результат, так как собирали с конца\n     reverse(lcs.begin(), lcs.end());\n     return lcs;\n }\n \n int main() {\n     vector<int> seq1 = {1, 2, 3, 4, 5};\n     vector<int> seq2 = {2, 4, 5, 8, 10};\n     \n     vector<int> result = longestCommonSubsequence(seq1, seq2);\n     \n     cout << 'Наибольшая общая подпоследовательность: ';\n     for (int num : result) {\n         cout << num << " ";\n     }\n     cout << endl;\n     \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_set>\n #include <algorithm>\n \n using namespace std;\n \n vector<string> splitText(const string& text, const unordered_set<string>& dictionary) {\n     int n = text.size();\n     vector<bool> dp(n + 1, false);\n     dp[0] = true;  // Пустая строка\n \n     // Заполняем dp\n     for (int i = 1; i <= n; ++i) {\n         for (int j = 0; j < i; ++j) {\n             if (dp[j] && dictionary.count(text.substr(j, i - j))) {\n                 dp[i] = true;\n                 break;\n             }\n         }\n     }\n \n     // Если разбиение невозможно\n     if (!dp[n]) {\n         return {};\n     }\n \n     // Восстанавливаем слова\n     vector<string> words;\n     int end = n;\n     while (end > 0) {\n         for (int start = end - 1; start >= 0; --start) {\n             string candidate = text.substr(start, end - start);\n             if (dp[start] && dictionary.count(candidate)) {\n                 words.push_back(candidate);\n                 end = start;\n                 break;\n             }\n         }\n     }\n \n     reverse(words.begin(), words.end());\n     return words;\n }\n \n int main() {\n     string text = 'thisisatest';\n     unordered_set<string> dictionary = {'this', 'is', 'a', 'test', 'his'};\n \n     vector<string> result = splitText(text, dictionary);\n \n     if (result.empty()) {\n         cout << 'Невозможно разбить текст на слова из словаря.' << endl;\n     } else {\n         cout << 'Разбитый текст: ';\n         for (const string& word : result) {\n             cout << word << " ";\n         }\n         cout << endl;\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n int main() {\n     // Вводим последовательность чисел\n     vector<int> sequence;\n     int num;\n     \n     cout << 'Введите последовательность целых чисел (для завершения введите любой нечисловой символ):\n ';\n     while (cin >> num) {\n         sequence.push_back(num);\n     }\n \n     // Выводим последовательность в обратном порядке\n     cout << 'Последовательность в обратном порядке:\n ';\n     for (int i = sequence.size() - 1; i >= 0; --i) {\n         cout << sequence[i] << " ";\n     }\n     cout << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_set>\n #include <algorithm>\n \n using namespace std;\n \n // Функция для вычисления MEX массива\n int computeMex(const vector<int>& v) {\n     unordered_set<int> s(v.begin(), v.end());\n     int mex = 0;\n     while (s.count(mex)) mex++;\n     return mex;\n }\n \n // Функция для проверки, можно ли разбить массив на k подотрезков с MEX >= target\n bool canSplit(const vector<int>& a, int k, int target) {\n     unordered_set<int> required;\n     for (int i = 0; i < target; i++) required.insert(i);\n \n     int segments = 0;\n     unordered_set<int> current;\n \n     for (int num : a) {\n         if (num < target) current.insert(num);\n         if (current == required) {\n             segments++;\n             current.clear();\n             if (segments == k) return true;\n         }\n     }\n     return false;\n }\n \n int main() {\n     int n, k;\n     cin >> n >> k;\n     vector<int> a(n);\n     for (int i = 0; i < n; i++) cin >> a[i];\n \n     int global_mex = computeMex(a);\n \n     // Бинарный поиск по ответу\n     int left = 0, right = global_mex;\n     int answer = 0;\n \n     while (left <= right) {\n         int mid = (left + right) / 2;\n         if (canSplit(a, k, mid)) {\n             answer = mid;\n             left = mid + 1;\n         } else {\n             right = mid - 1;\n         }\n     }\n \n     cout << answer << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n using namespace std;\n \n int minOperations(vector<int>& a) {\n     int operations = 0;\n     bool changed;\n     do {\n         changed = false;\n         for (int i = 0; i < a.size() - 1; ++i) {\n             if (a[i] > a[i + 1]) {\n                 // Оптимальное разбиение: x = min(a[i] // 2, a[i + 1])\n                 int x = min(a[i] / 2, a[i + 1]);\n                 if (x < 1) x = 1;  // x должен быть ≥ 1\n                 a.insert(a.begin() + i + 1, a[i] - x);\n                 a[i] = x;\n                 operations++;\n                 changed = true;\n                 break;  // После разбиения перепроверяем массив с начала\n             }\n         }\n     } while (changed);\n     return operations;\n }\n \n int main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; ++i) cin >> a[i];\n     cout << minOperations(a) << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n \n using namespace std;\n \n // Структура для хранения индекса и частоты запроса цвета\n struct Box {\n     int index;\n     int r;\n };\n \n // Компаратор для сортировки коробок по убыванию r\n bool compareBoxes(const Box &a, const Box &b) {\n     return a.r > b.r;\n }\n \n vector<vector<int>> distributeBoxes(int n, int s1, int s2, const vector<int> &r) {\n     vector<Box> boxes(n);\n     for (int i = 0; i < n; ++i) {\n         boxes[i] = {i + 1, r[i]}; // Нумерация коробок с 1\n     }\n \n     // Сортируем коробки по убыванию r\n     sort(boxes.begin(), boxes.end(), compareBoxes);\n \n     vector<int> a, b;\n \n     for (const Box &box : boxes) {\n         // Вычисляем потенциальные позиции в a и b\n         int posA = a.size() + 1;\n         int posB = b.size() + 1;\n \n         // Сравниваем вклады\n         if (s1 * posA <= s2 * posB) {\n             a.push_back(box.index);\n         } else {\n             b.push_back(box.index);\n         }\n     }\n \n     return {a, b};\n }\n \n int main() {\n     int n, s1, s2;\n     cin >> n >> s1 >> s2;\n \n     vector<int> r(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> r[i];\n     }\n \n     vector<vector<int>> result = distributeBoxes(n, s1, s2, r);\n \n     // Вывод результатов\n     cout << 'Робот A: ';\n     for (int box : result[0]) {\n         cout << box << ' ';\n     }\n     cout << '\n Робот B: ';\n     for (int box : result[1]) {\n         cout << box << ' ';\n     }\n     cout << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <set>\n #include <algorithm>\n \n using namespace std;\n \n vector<pair<int, int>> build_tree(int n) {\n     vector<pair<int, int>> edges;\n     if (n == 1) return edges;\n \n     // Начинаем с вершины 1\n     set<int> known;\n     known.insert(1);\n \n     for (int i = 2; i <= n; ++i) {\n         vector<int> candidates(known.begin(), known.end());\n         int parent = -1;\n \n         // Ищем родителя для вершины i\n         for (int candidate : candidates) {\n             cout << "? " << i << " " << candidate << endl;\n             cout.flush();\n             int x;\n             cin >> x;\n             if (x == candidate) {\n                 parent = candidate;\n                 break;\n             } else if (x != i) {\n                 // Продолжаем искать\n             }\n         }\n \n         if (parent == -1) {\n             // Если не нашли, то i соединена с 1\n             parent = 1;\n         }\n \n         edges.emplace_back(parent, i);\n         known.insert(i);\n     }\n \n     return edges;\n }\n \n int main() {\n     int n;\n     cin >> n;\n \n     vector<pair<int, int>> edges = build_tree(n);\n \n     cout << '!' << endl;\n     for (auto edge : edges) {\n         cout << edge.first << ' ' << edge.second << endl;\n     }\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <numeric>\n \n using namespace std;\n \n int gcd(int a, int b) {\n     while (b != 0) {\n         int temp = b;\n         b = a % b;\n         a = temp;\n     }\n     return a;\n }\n \n int main() {\n     int n, a, b;\n     cin >> n >> a >> b;\n     vector<int> c(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> c[i];\n     }\n     if (a == b) {\n         // Все операции одинаковы, диапазон не меняется\n         int min_val = *min_element(c.begin(), c.end());\n         int max_val = *max_element(c.begin(), c.end());\n         cout << max_val - min_val << endl;\n     } else {\n         int d = gcd(a, b);\n         vector<int> remainders(n);\n         for (int i = 0; i < n; ++i) {\n             remainders[i] = c[i] % d;\n         }\n         int min_remainder = *min_element(remainders.begin(), remainders.end());\n         int max_remainder = *max_element(remainders.begin(), remainders.end());\n         cout << max_remainder - min_remainder << endl;\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <queue>\n \n using namespace std;\n \n int main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n     }\n \n     priority_queue<int, vector<int>, greater<int>> min_heap;\n     long long health = 0;\n     int count = 0;\n \n     for (int i = 0; i < n; ++i) {\n         if (a[i] >= 0) {\n             health += a[i];\n             count++;\n         } else {\n             if (health + a[i] >= 0) {\n                 health += a[i];\n                 count++;\n                 min_heap.push(a[i]);\n             } else if (!min_heap.empty() && min_heap.top() < a[i]) {\n                 health -= min_heap.top();\n                 health += a[i];\n                 min_heap.pop();\n                 min_heap.push(a[i]);\n             }\n         }\n     }\n \n     cout << count << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n #include <cmath>\n \n using namespace std;\n \n vector<int> getDivisors(int p) {\n     vector<int> divisors;\n     if (p == 0) {\n         // 0 делится на любое число, но в задаче, скорее всего, p_i ≠ 0\n         return divisors;\n     }\n     int abs_p = abs(p);\n     for (int i = 1; i <= sqrt(abs_p); ++i) {\n         if (abs_p % i == 0) {\n             divisors.push_back(i);\n             if (i != abs_p / i) {\n                 divisors.push_back(abs_p / i);\n             }\n         }\n     }\n     return divisors;\n }\n \n int findMaxX(int p, int q) {\n     if (p == 0) {\n         // Если p = 0, любое x ≠ 0 подходит, но максимального нет\n         return -1;\n     }\n     vector<int> divisors = getDivisors(p);\n     sort(divisors.begin(), divisors.end(), greater<int>());\n     for (int x : divisors) {\n         if (q == 0) {\n             // Если q = 0, условие x % q не определено (деление на 0)\n             // Но по условию x не должен делиться на q, что невозможно, если q = 0\n             // В этом случае возвращаем максимальный делитель\n             return x;\n         }\n         if (x % q != 0) {\n             return x;\n         }\n     }\n     return -1;\n }\n \n int main() {\n     int t;\n     cin >> t;\n     while (t--) {\n         int p, q;\n         cin >> p >> q;\n         int res = findMaxX(p, q);\n         cout << res << endl;\n     }\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <unordered_map>\n #include <algorithm>\n #include <climits>\n \n using namespace std;\n \n int minDeletionsToBeautifulArray(vector<int>& a) {\n     unordered_map<int, int> freq;\n     for (int num : a) {\n         freq[num]++;\n     }\n \n     vector<int> frequencies;\n     for (auto& [num, cnt] : freq) {\n         frequencies.push_back(cnt);\n     }\n \n     sort(frequencies.begin(), frequencies.end());\n     int min_deletions = INT_MAX;\n \n     // Перебираем все возможные C (все уникальные частоты + 0)\n     for (int C : frequencies) {\n         int deletions = 0;\n         for (int f : frequencies) {\n             if (f < C) {\n                 deletions += f; // Удаляем все вхождения числа\n             } else {\n                 deletions += (f - C); // Удаляем лишние вхождения\n             }\n         }\n         if (deletions < min_deletions) {\n             min_deletions = deletions;\n         }\n     }\n \n     // Проверяем случай, когда C = 0 (удаляем все элементы)\n     int total_elements = a.size();\n     if (total_elements < min_deletions) {\n         min_deletions = total_elements;\n     }\n \n     return min_deletions;\n }\n \n int main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n     }\n \n     cout << minDeletionsToBeautifulArray(a) << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n \n using namespace std;\n \n int main() {\n     int n, x;\n     cin >> n >> x;\n     vector<int> a(n);\n     bool has_x = false;\n     for (int i = 0; i < n; ++i) {\n         cin >> a[i];\n         if (a[i] == x) {\n             has_x = true;\n         }\n     }\n \n     int infected = 0;\n     for (int num : a) {\n         if (num == x) {\n             infected++;\n         }\n     }\n \n     if (has_x) {\n         // Если x уже есть, то заражаем все такие аккаунты\n         int remaining = n - infected;\n         if (remaining == 0) {\n             cout << 0 << endl;\n         } else {\n             // Проверяем, можно ли остальные сделать равными x за 1 контест\n             long long sum = 0;\n             for (int num : a) {\n                 if (num != x) {\n                     sum += (x - num);\n                 }\n             }\n             if (sum == 0) {\n                 cout << 1 << endl;\n             } else {\n                 cout << 2 << endl;\n             }\n         }\n     } else {\n         // Если x нет, то нужно хотя бы один аккаунт сделать равным x\n         // Затем остальные можно заразить за 1 или 2 контеста\n         long long sum = 0;\n         for (int num : a) {\n             sum += (x - num);\n         }\n         if (sum == 0) {\n             // Можно за 2 контеста:\n             // 1. Сделать один аккаунт равным x\n             // 2. Остальные сделать равными x\n             cout << 2 << endl;\n         } else {\n             // Нужно 3 контеста:\n             // 1. Сделать один аккаунт равным x\n             // 2. Скорректировать суммы\n             // 3. Остальные сделать равными x\n             cout << 3 << endl;\n         }\n     }\n \n     return 0;\n }\n "~1
"#include <vector>\n #include <algorithm>\n using namespace std;\n \n struct Square {\n     int x, y; // Левый верхний угол\n     int size; // Длина стороны\n };\n \n Square findMaxSquare(const vector<vector<int>>& matrix) {\n     if (matrix.empty() || matrix[0].empty()) return {-1, -1, 0};\n \n     int rows = matrix.size();\n     int cols = matrix[0].size();\n \n     // Создаём DP-таблицу\n     vector<vector<int>> dp(rows, vector<int>(cols, 0));\n     int max_size = 0;\n     int max_i = 0, max_j = 0;\n \n     // Заполняем DP-таблицу\n     for (int i = 0; i < rows; ++i) {\n         for (int j = 0; j < cols; ++j) {\n             if (matrix[i][j] == 1) {\n                 if (i == 0 || j == 0) {\n                     dp[i][j] = 1;\n                 } else {\n                     dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});\n                 }\n \n                 if (dp[i][j] > max_size) {\n                     max_size = dp[i][j];\n                     max_i = i;\n                     max_j = j;\n                 }\n             }\n         }\n     }\n \n     // Восстанавливаем ответ\n     if (max_size == 0) return {-1, -1, 0}; // Если нет единиц (но по условию гарантируется)\n \n     int start_i = max_i - max_size + 1;\n     int start_j = max_j - max_size + 1;\n \n     return {start_i, start_j, max_size};\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <cmath>\n \n using namespace std;\n \n vector<int> sieve(int n) {\n     vector<bool> is_prime(n + 1, true);\n     is_prime[0] = is_prime[1] = false;\n     for (int i = 2; i * i <= n; ++i) {\n         if (is_prime[i]) {\n             for (int j = i * i; j <= n; j += i) {\n                 is_prime[j] = false;\n             }\n         }\n     }\n     vector<int> primes;\n     for (int i = 2; i <= n; ++i) {\n         if (is_prime[i]) {\n             primes.push_back(i);\n         }\n     }\n     return primes;\n }\n \n int sum_of_divisors(int n, const vector<int>& primes) {\n     if (n == 0) return 0;\n     int sum = 1;\n     int temp = n;\n     for (int p : primes) {\n         if (p * p > temp) break;\n         if (temp % p == 0) {\n             int exponent = 0;\n             while (temp % p == 0) {\n                 temp /= p;\n                 exponent++;\n             }\n             sum *= (pow(p, exponent + 1) - 1) / (p - 1);\n         }\n     }\n     if (temp > 1) {\n         sum *= (temp * temp - 1) / (temp - 1);\n     }\n     return sum;\n }\n \n int main() {\n     int n;\n     cout << "Enter a number: ";\n     cin >> n;\n     \n     int limit = sqrt(n) + 1;\n     vector<int> primes = sieve(limit);\n     \n     cout << "Sum of divisors of " << n << " is: " << sum_of_divisors(n, primes) << endl;\n     \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n using namespace std;\n \n int minOperations(vector<int>& a) {\n     int operations = 0;\n     bool changed;\n     do {\n         changed = false;\n         for (int i = 0; i < a.size() - 1; ++i) {\n             if (a[i] > a[i + 1]) {\n                 // Оптимальное разбиение: x = min(a[i] // 2, a[i + 1])\n                 int x = min(a[i] / 2, a[i + 1]);\n                 if (x < 1) x = 1;  // x должен быть ≥ 1\n                 a.insert(a.begin() + i + 1, a[i] - x);\n                 a[i] = x;\n                 operations++;\n                 changed = true;\n                 break;  // После разбиения перепроверяем массив с начала\n             }\n         }\n     } while (changed);\n     return operations;\n }\n \n int main() {\n     int n;\n     cin >> n;\n     vector<int> a(n);\n     for (int i = 0; i < n; ++i) cin >> a[i];\n     cout << minOperations(a) << endl;\n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n #include <algorithm>\n using namespace std;\n \n bool isValid(const vector<int>& fence) {\n     for (int i = 0; i < fence.size() - 1; i++) {\n         if (fence[i] == fence[i+1]) {\n             return false;\n         }\n     }\n     return true;\n }\n \n vector<int> buildFence(vector<int> colors) {\n     // Проверим тривиальный случай\n     if (colors.size() == 1) {\n         return colors;\n     }\n     \n     // Проверим, есть ли цвет, который встречается слишком часто\n     unordered_map<int, int> freq;\n     for (int color : colors) {\n         freq[color]++;\n         if (freq[color] > (colors.size() + 1) / 2) {\n             return {-1};\n         }\n     }\n     \n     // Будем перебирать все перестановки, пока не найдем подходящую\n     sort(colors.begin(), colors.end());\n     do {\n         if (isValid(colors)) {\n             return colors;\n         }\n     } while (next_permutation(colors.begin(), colors.end()));\n     \n     return {-1};\n }\n \n int main() {\n     int n;\n     cin >> n;\n     \n     vector<int> colors(n);\n     for (int i = 0; i < n; i++) {\n         cin >> colors[i];\n     }\n     \n     vector<int> fence = buildFence(colors);\n     if (fence[0] == -1) {\n         cout << -1;\n     } else {\n         for (int color : fence) {\n             cout << color << " ";\n         }\n     }\n     \n     return 0;\n }\n "~1
"#include <iostream>\n using namespace std;\n \n // Функция для вычисления суммы цифр числа\n int sumOfDigits(int n) {\n     int sum = 0;\n     while (n > 0) {\n         sum += n % 10;\n         n /= 10;\n     }\n     return sum;\n }\n \n // Функция для поиска минимального x\n int findMinX(int a, int b) {\n     int x = 1;\n     while (true) {\n         if (sumOfDigits(x) == a && sumOfDigits(2 * x) == b) {\n             return x;\n         }\n         x++;\n     }\n }\n \n int main() {\n     int a, b;\n     cin >> a;\n     cin >> b;\n \n     int result = findMinX(a, b);\n     cout << result << endl;\n \n     return 0;\n }\n "~1
"#include <iostream>\n #include <vector>\n \n using namespace std;\n \n // Функция для нахождения наибольшего делителя d числа s, где d <= s/n\n int findMaxDivisor(int s, int n) {\n     int max_possible_d = s / n;\n     int best_d = 1; // минимально возможный НОД (если не найдётся лучше)\n     \n     // Перебираем возможные делители s от 1 до max_possible_d\n     for (int d = 1; d * d <= s; d++) {\n         if (s % d == 0) {\n             // Проверяем оба делителя: d и s/d\n             if (d <= max_possible_d && d > best_d) {\n                 best_d = d;\n             }\n             int counterpart = s / d;\n             if (counterpart <= max_possible_d && counterpart > best_d) {\n                 best_d = counterpart;\n             }\n         }\n     }\n     return best_d;\n }\n \n vector<int> distributeCandies(int n, int s) {\n     vector<int> a(n);\n     int d = findMaxDivisor(s, n);\n     \n     // Распределяем конфеты\n     for (int i = 0; i < n - 1; i++) {\n         a[i] = d;\n     }\n     a[n - 1] = s - (n - 1) * d; // Оставшиеся конфеты\n     \n     return a;\n }\n \n int main() {\n     int n, s;\n     cin >> n;\n     cin >> s;\n     \n     if (s < n) {\n         return 0;\n     }\n     \n     vector<int> distribution = distributeCandies(n, s);\n     for (int i = 0; i < n; i++) {\n         cout << i + 1 << ": " << distribution[i] << endl;\n     }\n     \n     // Проверка НОД (для демонстрации)\n     int current_gcd = distribution[0];\n     for (int num : distribution) {\n         current_gcd = __gcd(current_gcd, num);\n     }\n     cout << current_gcd << endl;\n     \n     return 0;\n }\n "~1
